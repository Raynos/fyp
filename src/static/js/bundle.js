var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

require.define("path", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("/core.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "\"use strict\"\n\nvar EventEmitter = require(\"eventemitter-light\"),\n    pd = require(\"pd\");\n\n/*\n    Modules have four phases. The first two are handled for you\n\n    The definition phase:\n\n        When a module is used on the core, the core will inspect the module\n            by reading it's expose property. It then copies the methods in the\n            expose array out of the array and calls it the interface of the \n            module\n\n        At this the interface is wrapped in a proxy that invokes it indirectly.\n            this proxy is the public interface, this indirection is added to\n            support hot reloading of interfaces\n\n    Someone calls Core.init() and then the following three phases occur\n\n    The injection phase:\n\n        When the core is initialized all the dependencies are injected into\n            all the modules. This injection is based on the dependency mapping\n            passed into the core when it's constructed\n\n        Injection basically means mixing in the dependencies into the module\n\n    The setup phase:\n\n        The setup phase happens after dependencies are injected for all the\n            modules. In this phase the core calls the setup method of\n            the modules with an optional done callback\n\n        This allows modules to do asynchronous setup logic and tell the Core\n            \"hey I'm ready to go now\"\n\n    The init phase:\n\n        After all the modules are ready the init method is invoked on \n            modules that have it.\n\n        The init method is used to start your application, i.e. create your \n            HTTP server or start your cron jobs, etc.\n\n    Note that inside the interfaces methods the thisContext value is the module\n        itself.\n*/\nmodule.exports = {\n    /*\n        Construct a Core with dependencies and an optional EventEmitter \n            prototype. \n\n        The dependencies contain the dependency mapping setup for\n            modules, so the core knows what dependencies to inject into what\n            modules. \n\n        The eventemitter prototype is used to choose the eventEmitter \n            implementation that interfaces have.\n\n        @param {Object} dependencies - This is a map of dependencies.\n            {\n                <ModuleName>: {\n                    <PropertyName>: <OtherModuleName>\n                }\n            }\n\n            This means that <ModuleName> will have a deps object injected with\n                a property <PropertyName> which contains the public interface\n                of <OtherModuleName>\n\n        @param {Object} [ee] - An optional EventEmitter prototype. Used if you \n            want the interface to inherit from a different EventEmitter then\n            eventemitter-light\n    */\n    constructor: function constructor(dependencies, ee) {\n        var that = this;\n        that.interfaces  = {};\n        that._ee = ee || EventEmitter;\n        that._modules = {};\n        that._interfaces = {};\n        that.dependencies = dependencies || {};\n        return that;\n    },\n    /*\n        This is used to attach a module to the core. When a module is attached\n            the core asks the module what interface it exposes\n        \n        @param {String} name - The name of this module\n\n        @param {Object} module - The implementation of the module. \n\n        @return {Object} interface - the public interface of this module is\n            returned\n    */\n    use: function use(name, module) {\n        var _interface = pd.bindAll({}, this._ee);\n        pd.bindAll(module, {\n            emit: _interface.emit\n        })\n        _interface.constructor()\n        if (Array.isArray(module.expose)) {\n            module.expose.forEach(addToInterface)\n        } else {\n            pd.extend(_interface, module.expose || module)\n        }\n        _interface.on && _interface.on(\"ncore::expose\", addPropsToInterface)\n        var proxy = this._makeProxy(name, _interface, module)\n        return proxy\n\n        function addPropsToInterface(obj) {\n            pd.extend(proxy, obj)\n        }\n\n        function addToInterface(name) {\n            _interface[name] = module[name]\n        }\n    },\n    /*\n        init will initialize the Core. This means injecting the dependencies\n            into modules based on the dependency mapping. \n\n        @param {Function} [callback] - optional callback to be invoked when\n            all modules are done injecting dependencies\n    */\n    init: function init(callback) {\n        var that = this,\n            counter = 1\n\n        Object.keys(that._interfaces).forEach(injectDeps)\n        Object.keys(that._interfaces).forEach(setupModules)\n        next()\n\n        function injectDeps(name) {\n            var module = that._modules[name],\n                deps = {}\n\n            if (that.dependencies[name]) {\n                Object.keys(that.dependencies[name]).forEach(mapToInterface)\n            }\n            pd.extend(module, deps);\n\n            function mapToInterface(key) {\n                var dependency = that.dependencies[name][key]\n                if (typeof dependency === \"string\") {\n                    deps[key] = that.interfaces[dependency]   \n                } else if (Array.isArray(dependency)) {\n                    deps[key] = dependency.map(returnInterface)\n                } else if (typeof dependency === \"object\") {\n                    deps[key] = {}\n                    Object.keys(dependency).forEach(setDependency)\n                }\n                \n                function returnInterface(dependency) {\n                    return that.interfaces[dependency]\n                }\n\n                function setDependency(name) {\n                    deps[key][name] = that.interfaces[dependency[name]]\n                }\n            }\n        }\n\n        function setupModules(name) {\n            var module = that._modules[name]\n\n            if (module.setup) {\n                if (module.setup.length === 1) {\n                    counter++\n                }\n                module.setup(next)\n            }\n        }\n\n        function next() {\n            if (--counter === 0) {\n                callback && callback()\n                Object.keys(that._modules).forEach(invokeInit)\n            }\n        }\n\n        function invokeInit(name) {\n            var module = that._modules[name]\n            module.init && module.init()\n        }\n    },\n    /*\n        remove, removes the module from the Core. It will also invoke the \n            module's destroy method, allowing the module to do clean up logic.  \n\n        @param {String} name - The module to remove\n    */\n    remove: function remove(name) {\n        var that = this,\n            module = that._modules[name]\n\n        delete that.interfaces[name]\n        delete that._interfaces[name]\n        delete that._modules[name]\n\n        module.destroy && module.destroy()\n    },\n    /*\n        purge just removes all modules from the Core. basically resetting the\n            core to a clean state.\n    */\n    purge: function purge() {\n        Object.keys(this.interfaces).forEach(callRemove, this)\n        \n        function callRemove(name) {\n            this.remove(name)\n        }\n    },\n    /*\n        makeProxy takes an interface and a module and stores a proxy of the \n            interface as the public interface under Core.interfaces\n\n        @param {String} name - name of module\n\n        @param {Object} interface - internal interface object\n\n        @param {Object} module - module object of module\n    */\n    _makeProxy: function _makeProxy(name, _interface, module) {\n        var proxy = {},\n            that = this\n\n        Object.keys(_interface).forEach(proxyProperty)\n        that._interfaces[name] = _interface\n        that._modules[name] = module\n        that.interfaces[name] = proxy\n\n        return proxy\n\n        function proxyProperty(name) {\n            var value = _interface[name]\n            if (typeof value === \"function\") {\n                _interface[name] = value.bind(module)\n                proxy[name] = proxyFunction(name)\n            } else {\n                proxy[name] = value\n            }\n        }\n\n        function proxyFunction(functionName) {\n            return proxy\n\n            function proxy() {\n                return that._interfaces[name][functionName]\n                    .apply(this, arguments)\n            }\n        }\n    }\n}\n//@ sourceURL=/core.js"
));

require.define("/node_modules/eventemitter-light/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/ee\"}\n//@ sourceURL=/node_modules/eventemitter-light/package.json"
));

require.define("/node_modules/eventemitter-light/lib/ee.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    on: function on(ev, handler) {\n        var events = this._events;\n\n        (events[ev] || (events[ev] = [])).push(handler);\n    },\n    removeListener: function removeListener(ev, handler) {\n        var array = this._events[ev];\n\n        array && array.splice(array.indexOf(handler), 1);\n    },\n    emit: function emit(ev) {\n        var args = [].slice.call(arguments, 1),\n            array = this._events[ev] || [];\n\n        for (var i = 0, len = array.length; i < len; i++) {\n            array[i].apply(this, args);\n        }\n    },\n    once: function once(ev, handler) {\n        this.on(ev, proxy);\n\n        function proxy() {\n            handler.apply(this, arguments);\n            this.removeListener(ev, handler);\n        }\n    },\n    constructor: function constructor() {\n        this._events = {};\n        return this;\n    }\n};\n//@ sourceURL=/node_modules/eventemitter-light/lib/ee.js"
));

require.define("/node_modules/pd/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/pd\"}\n//@ sourceURL=/node_modules/pd/package.json"
));

require.define("/node_modules/pd/lib/pd.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n    pd(obj) -> propertyDescriptorsOfObject {\n        bindAll: function that binds all the methods of an object to the object,\n        extend: function that extends the first argument with the rest\n        Name: returns a namespace(anyKey) -> uniqueObject function\n    }\n    \n    pd requires ES5. Uses the shimmable subset of ES5.\n*/\n;(function (Object, slice) {\n    \"use strict\"\n    \n    pd.bindAll = bindAll\n    pd.extend = extend\n    pd.Name = Name\n    \n    typeof module !== \"undefined\" ? module.exports = pd : window.pd = pd\n\n    /*\n        pd will return all the own propertydescriptors of the object\n\n        @param Object object - object to get pds from.\n\n        @return Object - A hash of key/propertyDescriptors\n    */    \n    function pd(obj) {\n        var pds = {}\n        Object.getOwnPropertyNames(obj).forEach(function(key) {\n            pds[key] = Object.getOwnPropertyDescriptor(obj, key)\n        })\n        return pds\n    }\n\n    /*\n        Extend will extend the firat parameter with any other parameters \n        passed in. Only the own property names will be extended into\n        the object\n\n        @param Object target - target to be extended\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the target\n\n        @return Object - the target\n    */\n    function extend(target) {\n        slice.call(arguments, 1).forEach(function(source) {\n            Object.defineProperties(target, pd(source))\n        });\n        return target\n    }\n\n    /*\n        defines a namespace object. This hides a \"privates\" object on object \n        under the \"key\" namespace\n\n        @param Object object - object to hide a privates object on\n        @param Object key - key to hide it under\n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Object privates\n    */\n    function namespace(object, key) {\n        var privates = Object.create(object),\n            valueOf = object.valueOf\n        \n        Object.defineProperty(object, \"valueOf\", {\n            value: function(value) {\n                return value !== key ? valueOf.apply(this, arguments) : privates\n            },\n            writable: true,\n            configurable: true\n        })\n        \n        return privates\n    }\n    \n    /*\n        Constructs a Name function, when given an object it will return a\n        privates object. \n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Function name\n    */\n    function Name() {\n        var key = {}\n        return name\n        \n        function name(object) {\n            var privates = object.valueOf(key)\n            return privates !== object ? privates : namespace(object, key)\n        }\n    }\n    \n    /*\n        bindAll binds all methods to have their context set to the object\n\n        @param Object obj - the object to bind methods on\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the obj\n\n        @return Object - the bound object\n    */\n    function bindAll(obj) {\n        pd.extend.apply(null, arguments) \n        Object.keys(obj).filter(isMethod).forEach(bindMethods)\n        return obj\n        \n        function isMethod(name) {\n            return obj[name] && obj[name].bind === isMethod.bind\n        }\n        \n        function bindMethods(name) {\n            obj[name] = obj[name].bind(obj)\n        }\n    }\n\n})(Object, [].slice)\n//@ sourceURL=/node_modules/pd/lib/pd.js"
));

require.define("/shared/domains/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var pd = require(\"pd\")\n\nvar GetUser = {\n    start: function () {\n        this.collection.findOne({ \n            email: this.user.email \n        }, this.createIfNeeded)\n    },\n    createIfNeeded: function (err, user) {\n        if (err) return this.callback(err)\n        if (user === null) {\n            this.collection.insert(this.user, (function (err, result) {\n                this.callback(null, user)\n            }).bind(this))\n        } else {\n            this.callback(null, user)    \n        }\n    }\n}\n\nmodule.exports = {\n    setup: function () {\n        this.collection = this.dataSources.user.mongo\n    },\n    updateUser: function (user, callback) {\n        this.collection.update({\n            email: user.email\n        }, {\n            $set: user\n        }, {\n            safe: true,\n            upsert: true\n        }, callback)\n    }\n}\n//@ sourceURL=/shared/domains/user.js"
));

require.define("/node_modules/pd/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/pd\"}\n//@ sourceURL=/node_modules/pd/package.json"
));

require.define("/node_modules/pd/lib/pd.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n    pd(obj) -> propertyDescriptorsOfObject {\n        bindAll: function that binds all the methods of an object to the object\n        extend: function that extends the first argument with the rest\n        Name: returns a namespace(anyKey) -> uniqueObject function\n        memoize: returns a memoized version of the function\n    }\n*/\n;(function (Object, slice) {\n    \"use strict\"\n    \n    pd.bindAll = bindAll\n    pd.extend = extend\n    pd.Name = Name\n    pd.memoize = asyncMemoize\n    \n    typeof module !== \"undefined\" ? module.exports = pd : window.pd = pd\n\n    /*\n        pd will return all the own propertydescriptors of the object\n\n        @param Object object - object to get pds from.\n\n        @return Object - A hash of key/propertyDescriptors\n    */    \n    function pd(obj) {\n        var pds = {}\n        Object.getOwnPropertyNames(obj).forEach(function(key) {\n            pds[key] = Object.getOwnPropertyDescriptor(obj, key)\n        })\n        return pds\n    }\n\n    /*\n        Extend will extend the firat parameter with any other parameters \n        passed in. Only the own property names will be extended into\n        the object\n\n        @param Object target - target to be extended\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the target\n\n        @return Object - the target\n    */\n    function extend(target) {\n        slice.call(arguments, 1).forEach(function(source) {\n            Object.defineProperties(target, pd(source))\n        });\n        return target\n    }\n\n    /*\n        defines a namespace object. This hides a \"privates\" object on object \n        under the \"key\" namespace\n\n        @param Object object - object to hide a privates object on\n        @param Object key - key to hide it under\n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Object privates\n    */\n    function namespace(object, key) {\n        var privates = Object.create(object),\n            valueOf = object.valueOf\n        \n        Object.defineProperty(object, \"valueOf\", {\n            value: function(value) {\n                return value !== key ? valueOf.apply(this, arguments) : privates\n            },\n            writable: true,\n            configurable: true\n        })\n        \n        return privates\n    }\n    \n    /*\n        Constructs a Name function, when given an object it will return a\n        privates object. \n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Function name\n    */\n    function Name() {\n        var key = {}\n        return name\n        \n        function name(object) {\n            var privates = object.valueOf(key)\n            return privates !== object ? privates : namespace(object, key)\n        }\n    }\n    \n    /*\n        bindAll binds all methods to have their context set to the object\n\n        @param Object obj - the object to bind methods on\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the obj\n\n        @return Object - the bound object\n    */\n    function bindAll(obj) {\n        pd.extend.apply(null, arguments) \n        Object.keys(obj).filter(isMethod).forEach(bindMethods)\n        return obj\n        \n        function isMethod(name) {\n            return obj[name] && obj[name].bind === isMethod.bind\n        }\n        \n        function bindMethods(name) {\n            obj[name] = obj[name].bind(obj)\n        }\n    }\n\n    /*\n        default hasher for memoize. Takes the first arguments and returns it\n            if it's a string, otherwise returns the string \"void\"\n\n        @param Any x - argument to hash on\n\n        @return String - a hash key\n    */\n    function defaultHasher(x) { \n        if (typeof x === \"object\" || typeof x === \"function\" ||\n                typeof x === \"undefined\"\n        ) {\n            return \"void\"\n        }\n        return x.toString()\n    }\n\n    /*\n        memoizes asynchronous functions. The asynchronous function must have\n            a callback as a last argument, and that callback must be called.\n        \n        Memoization means that the function you pass in will only be called once\n            for every different type of argument. If the async function only\n            has a callback argument then it will only be called once. The \n            results of invocation are cached\n\n        @param Function fn - function to memoize\n        @param Object context - optional context for the function\n        @param Function hasher - optional custom hasher function. This will\n            be called on the arguments of the memoized function. The result\n            of the hasher will be the key the cached data will be stored under.\n\n        @return Function - the memoized function\n    */\n    function asyncMemoize(fn, context, hasher) {\n        var caches = {},\n            callbackLists = {}\n\n        if (typeof context === \"function\") {\n            hasher = context\n            context = null\n        }\n\n        if (typeof hasher === \"undefined\") {\n            hasher = defaultHasher\n        }\n\n        return callProxy\n\n        function callProxy() {\n            var args = [].slice.call(arguments),\n                cb = args.pop(),\n                key = hasher.apply(null, args)\n\n            if (caches[key]) {\n                return typeof cb === \"function\" && cb.apply(null, caches[key])\n            } else if (callbackLists[key]) {\n                return callbackLists[key].push(cb)\n            }\n\n            callbackLists[key] = [cb]\n\n            args.push(callbackProxy)\n\n            fn.apply(context, args)\n\n            function callbackProxy() {\n                caches[key] = arguments\n                var list = callbackLists[key]\n                delete callbackLists[key]\n                list.forEach(function (cb) {\n                    typeof cb === \"function\" && cb.apply(this, caches[key])\n                }, this)\n            }\n        }\n    }\n\n})(Object, [].slice)\n//@ sourceURL=/node_modules/pd/lib/pd.js"
));

require.define("/shared/domains/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var pd = require(\"pd\"),\n    after = require(\"after\"),\n    uuid = require(\"node-uuid\"),\n    observable = require(\"observable/lib/observable\")\n\nvar GetPosts = {\n    start: function () {\n        console.log(\"searching for posts\", this.user)\n        var cursor = this.collection.find({\n            \"user.email\": this.user.email\n        })\n        cursor.toArray(this.checkForResults)    \n    },\n    checkForResults: error(function (err, results) {\n        console.log(\"checkForResults\", arguments)\n        if (results.length !== 0) {\n            /*this.data = results\n            this.constructRelatedLinks()*/\n            //return this.callback(null, results)\n            return results.filter(function (post) {\n                return post.forwardLinks.length > 2 &&\n                    post.forwardLinks.length < 10\n                    post.backLinks.length > 2 &&\n                    post.backLinks.length < 10\n            }).forEach(function (post) {\n                this.posts.set(post.uri, post)\n            }, this)\n        }\n        this.getResults()\n    }),\n    getResults: function () {\n        console.log(\"getResults\")\n        this.reader.login(this.user.email, this.user.password,\n            this.readPosts, this.callback)\n    },\n    readPosts: function () {\n        console.log(\"readPosts\")\n        this.set(\"greader-max\", 1000)\n        this.set(\"greader-progress\", 0)\n        this.reader.getItems(\"\", this.transformData, {\n            n: 1000\n        })\n    },\n    transformData: function (data) {\n        console.log(\"transforming data\")\n        data = after.map(data, this.transformGoogleData, this.storeThem)\n    },\n    storeThem: error(function (err, data) {\n        this.data = data = data.filter(function (item) {\n            return item !== null\n        })\n        console.log(\"storing data\", err, data)\n\n        this.collection.insert(data, {\n            safe: true\n        }, this.constructRelatedLinks)\n    }),\n    transformGoogleData: function (data, callback) {\n        var uri = data.alternate[0].href,\n            self = this\n\n        this.findLinksInPage(uri, function (err, uris) {\n            if (err) {\n                return callback(err)\n            } else if (uris === null) {\n                updateProgress()\n                return callback(null, null)\n            }\n            updateProgress()\n            \n            callback(null, {\n                googleId: data.id,\n                id: uuid(),\n                title: data.title,\n                publishedTime: data.published,\n                summary: (data.summary || data.content || {}).content,\n                uri: data.alternate[0].href,\n                backLinks: [],\n                forwardLinks: [],\n                user: self.user,\n                uris: uris\n            })\n\n            function updateProgress() {\n                var counter = self.get(\"greader-progress\")\n                counter++\n                self.set(\"greader-progress\", counter)    \n            }\n        })\n    },\n    constructRelatedLinks: error(function (err, success) {\n        console.log(\"constructing relations\")\n        var self = this\n        // for each post in g reader\n        this.set(\"linking-progress\", 0)\n        this.set(\"linking-max\", this.data.length)\n        after.forEach(this.data, function (item, callback) {\n            process.nextTick(function () {\n                createForwardAndBackwardLinks(item, callback)\n            })\n        }, this, this.finish)\n\n        function createForwardAndBackwardLinks(item, callback) {\n            var collection = self.collection\n            //console.log(\"looping over links in\", item)\n            var linkingMax = self.get(\"linking-max\")\n            linkingMax += item.uris.length\n            self.set(\"linking-max\", linkingMax)\n            // for each link in post\n            after.forEach(item.uris, function (uri, key, callback) {\n                process.nextTick(function () {\n                    insertForwardLinks(uri, key, callback)\n                })\n            }, self, insertBackwardLinks)\n\n            function insertForwardLinks(uri, key, callback) {\n                // find all posts of that link\n                // and insert the item.link into the forwardLinks\n                collection.update({\n                    uri: uri\n                }, {\n                    $addToSet: {\n                        forwardLinks: item.uri\n                    }\n                }, {\n                    multi: true,\n                    safe: true\n                // inner loop done\n                }, function (err) {\n                    var linkingProgress = self.get(\"linking-progress\")\n                    linkingProgress++\n                    self.set(\"linking-progress\", linkingProgress)\n                    callback(err)\n                })\n            }\n\n            function insertBackwardLinks() {\n                //console.log(\"done updating ever uri in items.uri\", item)\n                // find all documents which contain me in forwardLinks\n                collection.find({\n                    forwardLinks: item.uri\n                }).toArray(updateItemWithBackwardLinks)\n\n                function updateItemWithBackwardLinks(err, array) {\n                    //console.log(\"found all forwardLinks, now updating\")\n                    // map the documents to their links\n                    array = array.map(extractUri)\n\n                    // add all those links into my backLinks\n\n                    collection.update({\n                        uri: item.uri\n                    }, {\n                        $addToSet: {\n                            backLinks: { \n                                $each: array \n                            }\n                        }\n                    }, {\n                        multi: true,\n                        safe: true\n                    // outer loop done\n                    }, function (err) {\n                        var linkingProgress = self.get(\"linking-progress\")\n                        linkingProgress++\n                        self.set(\"linking-progress\", linkingProgress)\n                        callback(err)\n                    })\n                }\n            }\n        // all data is done\n        }\n\n        function extractUri(item) {\n            return item.uri\n        }\n    }),\n    finish: error(function (err, posts) {\n        console.log(\"finished like a boss\")\n        this.start()\n    })\n}\n\nmodule.exports = pd.extend({}, observable(), {\n    setup: function () {\n        this.scraper = this.dataSources.scraper.scraper\n        this.collection = this.dataSources.post.mongo\n        this.reader = this.dataSources.gReader.reader\n    },\n    posts: observable(),\n    findLinksInPage: function (uri, callback) {\n        this.scraper(uri, callback)\n    },\n    getPosts: function (user, callback) {\n        var getposts = pd.bindAll({}, this, GetPosts, observable(), {\n            user: user,\n            callback: callback\n        })\n        getposts.start()\n        this.push(getposts)\n    }\n})\n\nfunction error(cb) {\n    return proxy\n\n    function proxy(err) {\n        if (err) {\n            console.log(\"error occured\", err)\n            console.dir(err)\n            return this.callback(err)\n        }\n        return cb.apply(this, arguments)\n    }\n}\n//@ sourceURL=/shared/domains/post.js"
));

require.define("/node_modules/after/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/after\"}\n//@ sourceURL=/node_modules/after/package.json"
));

require.define("/node_modules/after/lib/after.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function _anonymousWrapper() {\n    \"use strict\";   \n\n    var slice = [].slice;\n\n    after.forEach = handleMultipleArguments(forEach);\n    after.map = handleMultipleArguments(map);\n    after.reduce = handleMultipleArguments(reduce);\n    after.filter = handleMultipleArguments(filter);\n    after.some = handleMultipleArguments(some);\n    after.every = handleMultipleArguments(every);\n    after.reduceRight = handleMultipleArguments(reduceRight);\n    after.unpack = unpack;\n\n    if (typeof module !== \"undefined\") {\n        module.exports = after;\n    } else {\n        window.after = after;\n    }\n\n    /*\n        after takes a callback and returns a proxy function. If you invoke the\n            proxy function count number of times then the callback fires\n\n        @param Number count - number of times you need to invoke proxy\n            before the callback fires\n        @param Function callback - callback to fire\n\n        @return Function proxy { count: Number } - proxy function you \n            need to invoke count times before callback fires. \n            The count property of the proxy function is the internal \n            counter for when the callback should fire. \n            If the internal counter is 0 then the callback fires.\n    */\n    function after(count, callback) {\n        var results = [];\n\n        proxy.count = count;\n\n        return (count === 0) ? callback() : proxy;\n\n        function proxy() {\n            results.push(arguments);\n\n            --proxy.count === 0 && callback.apply(this, results);\n        }\n    }\n\n    function unpack(data) {\n        var obj = {};\n        [].forEach.call(data, function (tuple) {\n            obj[tuple[0]] = tuple[1];\n        });\n        return obj;\n    }\n\n    /*\n        forEach takes a set and invokes the callback on it for each key \n            in the set. The callback should invoke the next function passed \n            to it when it's done.\n    */\n    function forEach(obj, callback, context, next, keys, length) {\n        keys.forEach(loop);\n\n        function loop(key) {\n            var value = obj[key];\n\n            invokeCallback(callback, context, value, key, obj, proxy);\n\n            function proxy(err) {\n                if (err) return next(err);\n                if (--length === 0) {\n                    return next();\n                }\n            }\n        }\n    }\n\n    function map(obj, callback, context, next, keys, length) {\n        var returnValue = createReturnValue(obj);\n        keys.forEach(loop);\n\n        function loop(key) {\n            var value = obj[key];\n\n            invokeCallback(callback, context, value, key, obj, proxy);\n\n            function proxy(err, value) {\n                if (err) return next(err);\n                returnValue[key] = value;\n                if (--length === 0) {\n                    return next(null, returnValue);\n                }\n            }\n        }\n    }\n\n\n    function reduce(obj, callback, memo, next, keys, length) {\n        if (memo === null) {\n            memo = obj[keys.shift()];\n            length--;\n        }\n\n        (function loop() {\n            var key = keys.shift(),\n                value = obj[key];\n            \n            if (length-- === 0) {\n                return next(null, memo);\n            }\n\n            invokeCallback(callback, null, memo, value, key, obj, proxy);\n\n            function proxy(err, value) {\n                if (err) return next(err);\n                memo = value;\n                loop(); \n            }\n        }());\n    }\n\n    function filter(obj, callback, context, next, keys, length) {\n        var returnValue = createReturnValue(obj);\n        keys.forEach(loop);\n        \n        function loop (key) {\n            var value = obj[key];\n\n            invokeCallback(callback, context, value, key, obj, proxy);\n\n            function proxy(err, bool) {\n                if (err) return next(err);\n                if (bool) returnValue[key] = value;\n                if (--length === 0) {\n                    return next(null, returnValue);\n                }\n            }\n        }\n    }\n\n    function some(obj, callback, context, next, keys, length) {\n        keys.forEach(loop);\n\n        function loop (key) {\n            var value = obj[key];\n\n            invokeCallback(callback, context, value, key, obj, proxy);\n\n            function proxy(err, bool) {\n                if (err) {\n                    next(err);\n                    next = noop;\n                } else if (bool === true) {\n                    next(null, true);\n                    next = noop;\n                } else if (--length === 0) {\n                    next(null, false);\n                }\n            }\n        }\n    }\n\n    function every(obj, callback, context, next, keys, length) {\n        keys.forEach(loop);\n\n        function loop(key) {\n            var value = obj[key];\n\n            invokeCallback(callback, context, value, key, obj, proxy);\n\n            function proxy(err, bool) {\n                if (err) {\n                    next(err);\n                    next = noop;\n                } else if (bool === false) {\n                    next(null, false);\n                    next = noop;\n                } else if  (--length === 0) {\n                    next(null, true);\n                }\n            }\n        }\n    }\n\n    function createReturnValue(obj) {\n        if (Array.isArray(obj)) {\n            return [];\n        } else {\n            return Object.create(Object.getPrototypeOf(obj));\n        }\n    }\n\n    function reduceRight(obj, callback, memo, next, keys, length) {\n        reduce(obj, callback, memo, next, keys.reverse(), length);\n    }\n\n    function noop() { }\n\n    function handleMultipleArguments(f) {\n        return proxy;\n\n        function proxy(obj, callback, context, next) {\n            if (typeof context === \"function\") {\n                next = context;\n                context = null;\n            }\n\n            var keys = Object.keys(obj);\n            if (keys.length === 0) {\n                next(null, obj)\n            } else {\n                f(obj, callback, context, next, keys, keys.length);\n            }\n        }\n    }\n\n    function invokeCallback(callback, context, memo, value, key, obj, next) {\n        var callbackLength = callback.length;\n\n        if (typeof obj === \"function\") {\n            next = obj;\n            obj = null;\n        }\n\n        if (callbackLength === 1) {\n            callback.call(context, next);\n        } else if (callbackLength === 2) {\n            callback.call(context, memo, next);\n        } else if (callbackLength === 3) {\n            callback.call(context, memo, value, next);\n        } else if (callbackLength === 4) {\n            callback.call(context, memo, value, key, next);\n        } else {\n            callback.call(context, memo, value, key, obj, next);\n        }\n    }\n}());\n\n//@ sourceURL=/node_modules/after/lib/after.js"
));

require.define("/node_modules/node-uuid/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"
));

require.define("/node_modules/node-uuid/uuid.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"
));

require.define("crypto", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// todo\n\n//@ sourceURL=crypto"
));

require.define("/node_modules/observable/lib/observable.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var EventEmitter = require(\"eventemitter-light\"),\n    extend = require(\"pd\").extend,\n    uuid = require(\"node-uuid\")\n\nvar Observable = extend({}, EventEmitter, {\n    constructor: function (name, state, synchronizer) {\n        EventEmitter.constructor.call(this)\n        this._state = state || {}\n        this.synchronizer = synchronizer\n        this._id = name || uuid()\n        return this\n    },\n    push: function (value, callback) {\n        this.set(uuid(), value, callback)\n    },\n    set: function (key, value, callback) {\n        this._state[key] = value\n        var observ\n        if (typeof value === \"object\") {\n            observ = observable(this.synchronizer, uuid(), value)\n        } else {\n            observ = null\n        }\n        this.emit(\"change\", key, value, observ)\n        this.synchronizer && this.synchronizer(this, callback)\n    },\n    get: function (key) {\n        return this._state[key]\n    },\n    remove: function (key, callback) {\n        this.set(key, undefined, callback)\n    }\n})\n\nmodule.exports = observable\n\nfunction observable(synchronizer, name, state) {\n    return extend({}, Observable).constructor(name, state, synchronizer)\n}\n//@ sourceURL=/node_modules/observable/lib/observable.js"
));

require.define("/node_modules/eventemitter-light/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/ee\"}\n//@ sourceURL=/node_modules/eventemitter-light/package.json"
));

require.define("/node_modules/eventemitter-light/lib/ee.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    on: function (ev, handler) {\n        var events = this._events\n\n        ;(events[ev] || (events[ev] = [])).push(handler)\n    },\n    removeListener: function (ev, handler) {\n        var array = this._events[ev]\n\n        array && array.splice(array.indexOf(handler), 1)\n    },\n    emit: function (ev) {\n        var args = [].slice.call(arguments, 1),\n            array = this._events[ev] || []\n\n        for (var i = 0, len = array.length; i < len; i++) {\n            array[i].apply(this, args)\n        }\n    },\n    once: function (ev, handler) {\n        this.on(ev, function () {\n            handler.apply(this, arguments)\n            this.removeListener(ev, handler)\n        })\n    },\n    constructor: function constructor() {\n        this._events = {}\n        return this\n    }\n}\n\nmodule.exports.constructor.prototype = module.exports\n\n//@ sourceURL=/node_modules/eventemitter-light/lib/ee.js"
));

require.define("/client/controllers/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var DelegateListener = require(\"DelegateListener\"),\n    store = require(\"../util/store\")\n\nElement.prototype.matchesSelector = \n    Element.prototype.webkitMatchesSelector\n\nmodule.exports = {\n    setup: function (done) {\n        var user = store.get(\"user\")\n        if (user) {\n            done()\n        }\n        var domain = this.domain,\n            root = this.view.root\n\n        root.addEventListener(\"click\", \n            new DelegateListener(\".submit\", function (event) {\n                event.preventDefault()\n                var email = root.elements.email.value,\n                    password = root.elements.password.value,\n                    user = {\n                        email: email,\n                        password: password\n                    }\n\n                store.set(\"user\", user)\n                done && done()\n                done = null\n                return false\n            }))\n    }\n}\n//@ sourceURL=/client/controllers/user.js"
));

require.define("/node_modules/DelegateListener/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {}\n//@ sourceURL=/node_modules/DelegateListener/package.json"
));

require.define("/node_modules/DelegateListener/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = require(\"./__SRC/DelegateListener\")\n//@ sourceURL=/node_modules/DelegateListener/index.js"
));

require.define("/node_modules/DelegateListener/__SRC/DelegateListener.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @warning_level VERBOSE\n// @jscomp_warning missingProperties\n// @output_file_name DelegateListener.js\n// @check_types\n// ==/ClosureCompiler==\n\n;(function(global){\n\n\"use strict\";\n\n/**\n * @constructor\n */\nfunction DelegateListener(filter, callback) {\n\tvar thisObj = this;\n\tif(!(thisObj instanceof DelegateListener))return new DelegateListener(filter, callback);\n\t\n\tif(callback && callback.handleEvent) {\n\t\tthisObj.context = callback;\n\t\tcallback = callback.handleEvent;\n\t}\n\n\tthisObj.filter = filter;\n\tthisObj.callback =callback;\n}\nDelegateListener.prototype.handleEvent = function(event) {\n\tvar elem = event.target,\n\t\tstopElement = event.currentTarget,\n\t\tresult;\n\n\tdo {\n\t\tif(elem.nodeType !== 1 || !this.match(elem, this.filter))continue;\n\n\t\tevent.currentTarget = stopElement;\n\t\tif(event.currentTarget !== stopElement) {\n\t\t\tdelete event.currentTarget;//IE < 9 throw exception here\n\t\t\tevent.currentTarget = stopElement;\n\t\t}\n\t\t\t\n\t\tevent.target = elem;\n\t\tif(event.target !== elem) {\n\t\t\tdelete event.target;\n\t\t\tevent.target = elem;\n\t\t}\n\t\t\n\n\t\tif(this.callback)result = this.callback.call(this.context || stopElement, event);\n\t} while(result !== false && elem != stopElement && (elem = elem.parentNode));\n\n\treturn result;\n}\nDelegateListener.prototype.match = function(node, filter) {\n\tswitch(typeof filter) {\n\t\tcase \"string\"://CSS selector\n\t\t\treturn node.matchesSelector(filter);\n\n\t\tcase \"object\"://Attributes filter\n\t\t\treturn Object.keys(filter).every(function(key) {\n\t\t\t\treturn filter[key] !== void 0 ?\n\t\t\t\t\tnode.getAttribute(key) === filter[key] :\n\t\t\t\t\tnode.hasAttribute(key);\n\t\t\t})\n\n\t\tcase \"function\"://Custom filter\n\t\t\treturn filter(node);\n\t}\n}\n\nif (typeof module !== \"undefined\" && module[\"exports\"]) {\n\tmodule[\"exports\"] = DelegateListener\n} else if (typeof global !== \"undefined\") {\n\tglobal[\"DelegateListener\"] = DelegateListener\n}\n\n})(this);\n//@ sourceURL=/node_modules/DelegateListener/__SRC/DelegateListener.js"
));

require.define("/client/util/store.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var localStorage = window.localStorage\n\nmodule.exports = {\n    get: function (key) {\n        return JSON.parse(window.localStorage.getItem(key))\n    },\n    set: function (key, value) {\n        window.localStorage.setItem(key, JSON.stringify(value))\n    }\n}\n//@ sourceURL=/client/util/store.js"
));

require.define("/client/controllers/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var store = require(\"../util/store\")\n\nmodule.exports = {\n    init: function () {\n        window.posts = this.domain\n        var user = store.get(\"user\")\n\n        console.log(\"init getposts\", this.domain)\n\n        this.domain.getPosts(user, function () {\n            console.log(\"should render\")\n        })\n    }\n}\n//@ sourceURL=/client/controllers/post.js"
));

require.define("/client/views/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var DelegateListener = require(\"DelegateListener\")\n\nElement.prototype.matchesSelector = \n    Element.prototype.webkitMatchesSelector\n\nmodule.exports = {\n    root: document.getElementById(\"login\")\n}\n//@ sourceURL=/client/views/user.js"
));

require.define("/client/views/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var pd = require(\"pd\"),\n    xhr = require(\"xhr\"),\n    dust = require(\"dustjs-linkedin\"),\n    fragment = require(\"fragment\"),\n    cache = {}\n\nvar ProgressRenderer = {\n    constructor: function () {\n        this.observable.on(\"change\", this.handleProgressChange)\n    },\n    handleProgressChange: function (key, value) {\n        if (key === \"greader-progress\") {\n            this.greaderNode.value = value\n        } else if (key === \"greader-max\") {\n            this.greaderNode.max = value\n        } else if (key === \"linking-progress\") {\n            this.linkingNode.value = value\n        } else if (key === \"linking-max\") {\n            this.linkingNode.max = value\n        }\n    }\n}\n\nvar PostRenderer = {\n    constructor: function () {\n        var self = this,\n            middlePosts = this.middlePosts = \n                this.middle.getElementsByClassName(\"posts\")[0]\n            \n        self.open = false\n\n        template(\"/client/post.dust\", this.post, function (err, frag) {\n            middlePosts.appendChild(frag)\n            self.postDiv = middlePosts.lastElementChild\n            self.postDiv.addEventListener(\"click\", self.handleClick)\n        })\n    },\n    handleClick: function () {\n        this.open = !this.open\n        if (this.open) {\n            this.addLinksTo(this.left, this.post.backLinks)\n            this.addLinksTo(this.right, this.post.forwardLinks)    \n        } else {\n            this.left.textContent = \"\"\n            this.right.textContent = \"\"\n        }\n    },\n    addLinksTo: function (elem, links) {\n        elem.textContent = \"\"\n        links.map(function (uri) {\n            return this.domain.posts.get(uri)\n        }, this).forEach(function (post) {\n            template(\"/client/post.dust\", post, function (err, frag) {\n                elem.appendChild(frag)\n            })\n        })\n    }\n}\n\nmodule.exports = {\n    setup: function () {\n        this.domain.on(\"change\", this.handleDomainChange)\n        this.domain.posts.on(\"change\", this.handlePostsChange)\n    },\n    greaderNode: document.getElementById(\"greader\"),\n    linkingNode: document.getElementById(\"linking\"),\n    left: document.getElementsByClassName(\"left\")[0],\n    middle: document.getElementsByClassName(\"middle\")[0],\n    right: document.getElementsByClassName(\"right\")[0],\n    outer: document.getElementById(\"outer\"),\n    handleDomainChange: function (key, value) {\n        pd.bindAll({}, ProgressRenderer, this, {\n            observable: value\n        }).constructor()\n    },\n    handlePostsChange: function (key, value) {\n        this.outer.hidden = true\n        pd.bindAll({}, PostRenderer, this, {\n            post: value\n        }).constructor()\n    }\n}\n\nfunction template(uri, context, callback) {\n    if (cache[uri]) {\n        return compile(cache[uri])\n    }\n\n    loadWithXHR()\n\n    function loadWithXHR() {\n        xhr({\n            method: \"GET\",\n            uri: uri\n        }, function (err, response) {\n            if (this.status === 404) {\n                return callback(new Error(\"template not found\"))\n            }\n            if (err) {\n                return callback(err)\n            }\n            compileSource(response)\n        })\n    }\n\n    function compileSource(source) {\n        var fn = dust.compileFn(source)\n        cache[uri] = fn\n\n        compile(fn)\n    }\n\n    function compile(fn) {\n        fn(context, function (err, out) {\n            if (err) {\n                return callback(err)\n            }\n            return callback(null, fragment(out))\n        })\n    }\n}\n//@ sourceURL=/client/views/post.js"
));

require.define("/node_modules/xhr/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {}\n//@ sourceURL=/node_modules/xhr/package.json"
));

require.define("/node_modules/xhr/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var extend = require(\"pd\").extend\n\ncreateXHR.defaults = {}\n\nmodule.exports = createXHR\n\nfunction createXHR(options, callback) {\n    options = extend({}, createXHR.defaults, options)\n    var xhr = new XMLHttpRequest\n    xhr.onreadystatechange = function () {\n        if (this.readyState === 4) {\n            callback.call(this, null, this.response || \n                this.responseText || this.responseXML)\n        }\n    }\n    xhr.onerror = function (evt) {\n        callback.call(this, evt)\n    }\n    xhr.open(options.method, options.uri)\n    if (options.headers) {\n        Object.keys(options.headers).forEach(function (key) {\n            xhr.setRequestHeader(key, options.headers[key])\n        })\n    }\n    xhr.send(options.data)\n    return xhr\n}\n//@ sourceURL=/node_modules/xhr/index.js"
));

require.define("/node_modules/dustjs-linkedin/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/dust\"}\n//@ sourceURL=/node_modules/dustjs-linkedin/package.json"
));

require.define("/node_modules/dustjs-linkedin/lib/dust.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var dust = {};\n\n(function(dust) {\n\ndust.cache = {};\n\ndust.register = function(name, tmpl) {\n  if (!name) return;\n  dust.cache[name] = tmpl;\n};\n\ndust.render = function(name, context, callback) {\n  var chunk = new Stub(callback).head;\n  dust.load(name, chunk, Context.wrap(context)).end();\n};\n\ndust.stream = function(name, context) {\n  var stream = new Stream();\n  dust.nextTick(function() {\n    dust.load(name, stream.head, Context.wrap(context)).end();\n  });\n  return stream;\n};\n\ndust.renderSource = function(source, context, callback) {\n  return dust.compileFn(source)(context, callback);\n};\n\ndust.compileFn = function(source, name) {\n  var tmpl = dust.loadSource(dust.compile(source, name));\n  return function(context, callback) {\n    var master = callback ? new Stub(callback) : new Stream();\n    dust.nextTick(function() {\n      tmpl(master.head, Context.wrap(context)).end();\n    });\n    return master;\n  }\n};\n\ndust.load = function(name, chunk, context) {\n  var tmpl = dust.cache[name];\n  if (tmpl) {\n    return tmpl(chunk, context);\n  } else {\n    if (dust.onLoad) {\n      return chunk.map(function(chunk) {\n        dust.onLoad(name, function(err, src) {\n          if (err) return chunk.setError(err);\n          if (!dust.cache[name]) dust.loadSource(dust.compile(src, name));\n          dust.cache[name](chunk, context).end();\n        });\n      });\n    }\n    return chunk.setError(new Error(\"Template Not Found: \" + name));\n  }\n};\n\ndust.loadSource = function(source, path) {\n  return eval(source);\n};\n\nif (Array.isArray) {\n  dust.isArray = Array.isArray;\n} else {\n  dust.isArray = function(arr) {\n    return Object.prototype.toString.call(arr) == \"[object Array]\";\n  };\n}\n\ndust.nextTick = function(callback) {\n  setTimeout(callback, 0);\n}\n\ndust.isEmpty = function(value) {\n  if (dust.isArray(value) && !value.length) return true;\n  if (value === 0) return false;\n  return (!value);\n};\n\ndust.filter = function(string, auto, filters) {\n  if (filters) {\n    for (var i=0, len=filters.length; i<len; i++) {\n      var name = filters[i];\n      if (name === \"s\") {\n        auto = null;\n      } else {\n        string = dust.filters[name](string);\n      }\n    }\n  }\n  if (auto) {\n    string = dust.filters[auto](string);\n  }\n  return string;\n};\n\ndust.filters = {\n  h: function(value) { return dust.escapeHtml(value); },\n  j: function(value) { return dust.escapeJs(value); },\n  u: encodeURI,\n  uc: encodeURIComponent\n}\n\nfunction Context(stack, global, blocks) {\n  this.stack  = stack;\n  this.global = global;\n  this.blocks = blocks;\n}\n\ndust.makeBase = function(global) {\n  return new Context(new Stack(), global);\n}\n\nContext.wrap = function(context) {\n  if (context instanceof Context) {\n    return context;\n  }\n  return new Context(new Stack(context));\n}\n\nContext.prototype.get = function(key) {\n  var ctx = this.stack, value;\n\n  while(ctx) {\n    if (ctx.isObject) {\n      value = ctx.head[key];\n      if (!(value === undefined)) {\n        return value;\n      }\n    }\n    ctx = ctx.tail;\n  }\n  return this.global ? this.global[key] : undefined;\n};\n\nContext.prototype.getPath = function(cur, down) {\n  var ctx = this.stack,\n      len = down.length;\n\n  if (cur && len === 0) return ctx.head;\n  if (!ctx.isObject) return undefined;\n  ctx = ctx.head;\n  var i = 0;\n  while(ctx && i < len) {\n    ctx = ctx[down[i]];\n    i++;\n  }\n  return ctx;\n};\n\nContext.prototype.push = function(head, idx, len) {\n  if( head ){\n   // loop index for a block section\n   head['$idx'] = idx;\n   // loop size for a block section\n   head['$len'] = len;\n  }\n  return new Context(new Stack(head, this.stack, idx, len), this.global, this.blocks);\n};\n\nContext.prototype.rebase = function(head) {\n  return new Context(new Stack(head), this.global, this.blocks);\n};\n\nContext.prototype.current = function() {\n  return this.stack.head;\n};\n\nContext.prototype.getBlock = function(key) {\n  var blocks = this.blocks;\n\n  if (!blocks) return;\n  var len = blocks.length, fn;\n  while (len--) {\n    fn = blocks[len][key];\n    if (fn) return fn;\n  }\n}\n\nContext.prototype.shiftBlocks = function(locals) {\n  var blocks = this.blocks;\n\n  if (locals) {\n    if (!blocks) {\n      newBlocks = [locals];\n    } else {\n      newBlocks = blocks.concat([locals]);\n    }\n    return new Context(this.stack, this.global, newBlocks);\n  }\n  return this;\n}\n\nfunction Stack(head, tail, idx, len) {\n  this.tail = tail;\n  this.isObject = !dust.isArray(head) && head && typeof head === \"object\";\n  this.head = head;\n  this.index = idx;\n  this.of = len;\n}\n\nfunction Stub(callback) {\n  this.head = new Chunk(this);\n  this.callback = callback;\n  this.out = '';\n}\n\nStub.prototype.flush = function() {\n  var chunk = this.head;\n\n  while (chunk) {\n    if (chunk.flushable) {\n      this.out += chunk.data;\n    } else if (chunk.error) {\n      this.callback(chunk.error);\n      this.flush = function() {};\n      return;\n    } else {\n      return;\n    }\n    chunk = chunk.next;\n    this.head = chunk;\n  }\n  this.callback(null, this.out);\n}\n\nfunction Stream() {\n  this.head = new Chunk(this);\n}\n\nStream.prototype.flush = function() {\n  var chunk = this.head;\n\n  while(chunk) {\n    if (chunk.flushable) {\n      this.emit('data', chunk.data);\n    } else if (chunk.error) {\n      this.emit('error', chunk.error);\n      this.flush = function() {};\n      return;\n    } else {\n      return;\n    }\n    chunk = chunk.next;\n    this.head = chunk;\n  }\n  this.emit('end');\n}\n\nStream.prototype.emit = function(type, data) {\n  var events = this.events;\n\n  if (events && events[type]) {\n    events[type](data);\n  }\n}\n\nStream.prototype.on = function(type, callback) {\n  if (!this.events) {\n    this.events = {};\n  }\n  this.events[type] = callback;\n  return this;\n}\n\nfunction Chunk(root, next, taps) {\n  this.root = root;\n  this.next = next;\n  this.data = '';\n  this.flushable = false;\n  this.taps = taps;\n}\n\nChunk.prototype.write = function(data) {\n  var taps  = this.taps;\n\n  if (taps) {\n    data = taps.go(data);\n  }\n  this.data += data;\n  return this;\n}\n\nChunk.prototype.end = function(data) {\n  if (data) {\n    this.write(data);\n  }\n  this.flushable = true;\n  this.root.flush();\n  return this;\n}\n\nChunk.prototype.map = function(callback) {\n  var cursor = new Chunk(this.root, this.next, this.taps),\n      branch = new Chunk(this.root, cursor, this.taps);\n\n  this.next = branch;\n  this.flushable = true;\n  callback(branch);\n  return cursor;\n}\n\nChunk.prototype.tap = function(tap) {\n  var taps = this.taps;\n\n  if (taps) {\n    this.taps = taps.push(tap);\n  } else {\n    this.taps = new Tap(tap);\n  }\n  return this;\n}\n\nChunk.prototype.untap = function() {\n  this.taps = this.taps.tail;\n  return this;\n}\n\nChunk.prototype.render = function(body, context) {\n  return body(this, context);\n}\n\nChunk.prototype.reference = function(elem, context, auto, filters) {\n  if (typeof elem === \"function\") {\n    elem = elem(this, context, null, {auto: auto, filters: filters});\n    if (elem instanceof Chunk) {\n      return elem;\n    }\n  }\n  if (!dust.isEmpty(elem)) {\n    return this.write(dust.filter(elem, auto, filters));\n  } else {\n    return this;\n  }\n};\n\nChunk.prototype.section = function(elem, context, bodies, params) {\n  if (typeof elem === \"function\") {\n    elem = elem(this, context, bodies, params);\n    if (elem instanceof Chunk) {\n      return elem;\n    }\n  }\n\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (params) {\n    context = context.push(params);\n  }\n\n  if (dust.isArray(elem)) {\n    if (body) {\n      var len = elem.length, chunk = this;\n      for (var i=0; i<len; i++) {\n        chunk = body(chunk, context.push(elem[i], i, len));\n      }\n      return chunk;\n    }\n  } else if (elem === true) {\n    if (body) return body(this, context);\n  } else if (elem || elem === 0) {\n    if (body) return body(this, context.push(elem));\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.exists = function(elem, context, bodies) {\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (!dust.isEmpty(elem)) {\n    if (body) return body(this, context);\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n}\n\nChunk.prototype.notexists = function(elem, context, bodies) {\n  var body = bodies.block,\n      skip = bodies['else'];\n\n  if (dust.isEmpty(elem)) {\n    if (body) return body(this, context);\n  } else if (skip) {\n    return skip(this, context);\n  }\n  return this;\n}\n\nChunk.prototype.block = function(elem, context, bodies) {\n  var body = bodies.block;\n\n  if (elem) {\n    body = elem;\n  }\n\n  if (body) {\n    return body(this, context);\n  }\n  return this;\n};\n\nChunk.prototype.partial = function(elem, context) {\n  if (typeof elem === \"function\") {\n    return this.capture(elem, context, function(name, chunk) {\n      dust.load(name, chunk, context).end();\n    });\n  }\n  return dust.load(elem, this, context);\n};\n\nChunk.prototype.helper = function(name, context, bodies, params) {\n  return dust.helpers[name](this, context, bodies, params);\n};\n\nChunk.prototype.capture = function(body, context, callback) {\n  return this.map(function(chunk) {\n    var stub = new Stub(function(err, out) {\n      if (err) {\n        chunk.setError(err);\n      } else {\n        callback(out, chunk);\n      }\n    });\n    body(stub.head, context).end();\n  });\n};\n\nChunk.prototype.setError = function(err) {\n  this.error = err;\n  this.root.flush();\n  return this;\n};\n\nfunction Tap(head, tail) {\n  this.head = head;\n  this.tail = tail;\n}\n\nTap.prototype.push = function(tap) {\n  return new Tap(tap, this);\n};\n\nTap.prototype.go = function(value) {\n  var tap = this;\n\n  while(tap) {\n    value = tap.head(value);\n    tap = tap.tail;\n  }\n  return value;\n};\n\nvar HCHARS = new RegExp(/[&<>\\\"]/),\n    AMP    = /&/g,\n    LT     = /</g,\n    GT     = />/g,\n    QUOT   = /\\\"/g;\n\ndust.escapeHtml = function(s) {\n  if (typeof s === \"string\") {\n    if (!HCHARS.test(s)) {\n      return s;\n    }\n    return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;');\n  }\n  return s;\n};\n\nvar BS = /\\\\/g,\n    CR = /\\r/g,\n    LS = /\\u2028/g,\n    PS = /\\u2029/g,\n    NL = /\\n/g,\n    LF = /\\f/g,\n    SQ = /'/g,\n    DQ = /\"/g,\n    TB = /\\t/g;\n\ndust.escapeJs = function(s) {\n  if (typeof s === \"string\") {\n    return s\n      .replace(BS, '\\\\\\\\')\n      .replace(DQ, '\\\\\"')\n      .replace(SQ, \"\\\\'\")\n      .replace(CR, '\\\\r')\n      .replace(LS, '\\\\u2028')\n      .replace(PS, '\\\\u2029')\n      .replace(NL, '\\\\n')\n      .replace(LF, '\\\\f')\n      .replace(TB, \"\\\\t\");\n  }\n  return s;\n};\n\n})(dust);\n\nif (typeof exports !== \"undefined\") {\n  dust.helpers = require(\"./dust-helpers\").helpers;\n  if (typeof process !== \"undefined\") {\n      require('./server')(dust);\n  }\n  module.exports = dust;\n}\n\n//@ sourceURL=/node_modules/dustjs-linkedin/lib/dust.js"
));

require.define("/node_modules/dustjs-linkedin/lib/dust-helpers.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function(dust){\n  \nvar helpers = {\n  \n  sep: function(chunk, context, bodies) {\n    if (context.stack.index === context.stack.of - 1) {\n      return chunk;\n    }\n    return bodies.block(chunk, context);\n  },\n\n  idx: function(chunk, context, bodies) {\n    return bodies.block(chunk, context.push(context.stack.index));\n  },\n  \n  if: function( chunk, context, bodies, params ){\n    var cond = ( params.cond );\n    \n    if( params && params.cond ){\n      // resolve dust references in the expression\n      if( typeof cond === \"function\" ){\n        cond = '';\n        chunk.tap( function( data ){\n          cond += data;\n          return '';\n        } ).render( params.cond, context ).untap();\n        if( cond === '' ){\n          cond = false;\n        }\n      }\n      // eval expressions with no dust references\n      if( eval( cond ) ){\n       return chunk.render( bodies.block, context );\n      } \n      if( bodies['else'] ){\n       return chunk.render( bodies['else'], context );\n      }\n    } \n    // no condition\n    else {\n      if( window.console ){\n        window.console.log( \"No expression given!\" );\n      }\n    }\n    return chunk;\n  }\n};\n\ndust.helpers = helpers;\n\n})(typeof exports !== 'undefined' ? exports : window.dust);\n//@ sourceURL=/node_modules/dustjs-linkedin/lib/dust-helpers.js"
));

require.define("/node_modules/dustjs-linkedin/lib/server.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var path = require('path'),\n    parser = require('./parser'),\n    compiler = require('./compiler'),\n    vm = require('vm');\n\nmodule.exports = function(dust) {\n  compiler.parse = parser.parse;\n  dust.compile = compiler.compile;\n\n  dust.loadSource = function(source, path) {\n    return vm.runInNewContext(source, {dust: dust}, path);\n  };\n\n  dust.nextTick = process.nextTick;\n\n  // expose optimizers in commonjs env too\n  dust.optimizers = compiler.optimizers;\n}\n\n//@ sourceURL=/node_modules/dustjs-linkedin/lib/server.js"
));

require.define("/node_modules/dustjs-linkedin/lib/parser.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function(dust){\n\nvar parser = (function(){\n  /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */\n  \n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function(input, startRule) {\n      var parseFunctions = {\n        \"bodies\": parse_bodies,\n        \"body\": parse_body,\n        \"buffer\": parse_buffer,\n        \"comment\": parse_comment,\n        \"context\": parse_context,\n        \"end_tag\": parse_end_tag,\n        \"eol\": parse_eol,\n        \"esc\": parse_esc,\n        \"filters\": parse_filters,\n        \"identifier\": parse_identifier,\n        \"inline\": parse_inline,\n        \"inline_part\": parse_inline_part,\n        \"key\": parse_key,\n        \"ld\": parse_ld,\n        \"literal\": parse_literal,\n        \"params\": parse_params,\n        \"part\": parse_part,\n        \"partial\": parse_partial,\n        \"path\": parse_path,\n        \"rd\": parse_rd,\n        \"reference\": parse_reference,\n        \"sec_tag_start\": parse_sec_tag_start,\n        \"section\": parse_section,\n        \"special\": parse_special,\n        \"tag\": parse_tag,\n        \"ws\": parse_ws\n      };\n      \n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"body\";\n      }\n      \n      var pos = 0;\n      var reportMatchFailures = true;\n      var rightmostMatchFailuresPos = 0;\n      var rightmostMatchFailuresExpected = [];\n      var cache = {};\n      \n      function padLeft(input, padding, length) {\n        var result = input;\n        \n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        \n        return result;\n      }\n      \n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        \n        if (charCode <= 0xFF) {\n          var escapeChar = 'x';\n          var length = 2;\n        } else {\n          var escapeChar = 'u';\n          var length = 4;\n        }\n        \n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      \n      function quote(s) {\n        /*\n         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n         * string literal except for the closing quote character, backslash,\n         * carriage return, line separator, paragraph separator, and line feed.\n         * Any character may appear in the form of an escape sequence.\n         */\n        return '\"' + s\n          .replace(/\\\\/g, '\\\\\\\\')            // backslash\n          .replace(/\"/g, '\\\\\"')              // closing quote character\n          .replace(/\\r/g, '\\\\r')             // carriage return\n          .replace(/\\n/g, '\\\\n')             // line feed\n          .replace(/[\\x80-\\uFFFF]/g, escape) // non-ASCII characters\n          + '\"';\n      }\n      \n      function matchFailed(failure) {\n        if (pos < rightmostMatchFailuresPos) {\n          return;\n        }\n        \n        if (pos > rightmostMatchFailuresPos) {\n          rightmostMatchFailuresPos = pos;\n          rightmostMatchFailuresExpected = [];\n        }\n        \n        rightmostMatchFailuresExpected.push(failure);\n      }\n      \n      function parse_body() {\n        var cacheKey = 'body@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var savedPos0 = pos;\n        var result1 = [];\n        var result3 = parse_part();\n        while (result3 !== null) {\n          result1.push(result3);\n          var result3 = parse_part();\n        }\n        var result2 = result1 !== null\n          ? (function(p) { return [\"body\"].concat(p) })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_part() {\n        var cacheKey = 'part@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var result6 = parse_comment();\n        if (result6 !== null) {\n          var result0 = result6;\n        } else {\n          var result5 = parse_section();\n          if (result5 !== null) {\n            var result0 = result5;\n          } else {\n            var result4 = parse_partial();\n            if (result4 !== null) {\n              var result0 = result4;\n            } else {\n              var result3 = parse_special();\n              if (result3 !== null) {\n                var result0 = result3;\n              } else {\n                var result2 = parse_reference();\n                if (result2 !== null) {\n                  var result0 = result2;\n                } else {\n                  var result1 = parse_buffer();\n                  if (result1 !== null) {\n                    var result0 = result1;\n                  } else {\n                    var result0 = null;;\n                  };\n                };\n              };\n            };\n          };\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_section() {\n        var cacheKey = 'section@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos2 = pos;\n        var savedPos3 = pos;\n        var result10 = parse_sec_tag_start();\n        if (result10 !== null) {\n          var result11 = parse_rd();\n          if (result11 !== null) {\n            var result12 = parse_body();\n            if (result12 !== null) {\n              var result13 = parse_bodies();\n              if (result13 !== null) {\n                var result14 = parse_end_tag();\n                if (result14 !== null) {\n                  var result15 = (function() {if (!result8) return true; return result8[1].text === result12.text})() ? '' : null;\n                  if (result15 !== null) {\n                    var result8 = [result10, result11, result12, result13, result14, result15];\n                  } else {\n                    var result8 = null;\n                    pos = savedPos3;\n                  }\n                } else {\n                  var result8 = null;\n                  pos = savedPos3;\n                }\n              } else {\n                var result8 = null;\n                pos = savedPos3;\n              }\n            } else {\n              var result8 = null;\n              pos = savedPos3;\n            }\n          } else {\n            var result8 = null;\n            pos = savedPos3;\n          }\n        } else {\n          var result8 = null;\n          pos = savedPos3;\n        }\n        var result9 = result8 !== null\n          ? (function(t, b, e, n) { e.push([\"param\", [\"literal\", \"block\"], b]); t.push(e); return t })(result8[0], result8[2], result8[3], result8[4])\n          : null;\n        if (result9 !== null) {\n          var result7 = result9;\n        } else {\n          var result7 = null;\n          pos = savedPos2;\n        }\n        if (result7 !== null) {\n          var result0 = result7;\n        } else {\n          var savedPos0 = pos;\n          var savedPos1 = pos;\n          var result4 = parse_sec_tag_start();\n          if (result4 !== null) {\n            if (input.substr(pos, 1) === \"/\") {\n              var result5 = \"/\";\n              pos += 1;\n            } else {\n              var result5 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result5 !== null) {\n              var result6 = parse_rd();\n              if (result6 !== null) {\n                var result2 = [result4, result5, result6];\n              } else {\n                var result2 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result2 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result2 = null;\n            pos = savedPos1;\n          }\n          var result3 = result2 !== null\n            ? (function(t) { t.push([\"bodies\"]); return t })(result2[0])\n            : null;\n          if (result3 !== null) {\n            var result1 = result3;\n          } else {\n            var result1 = null;\n            pos = savedPos0;\n          }\n          if (result1 !== null) {\n            var result0 = result1;\n          } else {\n            var result0 = null;;\n          };\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"section\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_sec_tag_start() {\n        var cacheKey = 'sec_tag_start@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          if (input.substr(pos).match(/^[#?^<+@%]/) !== null) {\n            var result4 = input.charAt(pos);\n            pos++;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"[#?^<+@%]\");\n            }\n          }\n          if (result4 !== null) {\n            var result5 = parse_identifier();\n            if (result5 !== null) {\n              var result6 = parse_context();\n              if (result6 !== null) {\n                var result7 = parse_params();\n                if (result7 !== null) {\n                  var result1 = [result3, result4, result5, result6, result7];\n                } else {\n                  var result1 = null;\n                  pos = savedPos1;\n                }\n              } else {\n                var result1 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(t, n, c, p) { return [t, n, c, p] })(result1[1], result1[2], result1[3], result1[4])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_end_tag() {\n        var cacheKey = 'end_tag@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          if (input.substr(pos, 1) === \"/\") {\n            var result4 = \"/\";\n            pos += 1;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result4 !== null) {\n            var result5 = parse_identifier();\n            if (result5 !== null) {\n              var result6 = parse_rd();\n              if (result6 !== null) {\n                var result1 = [result3, result4, result5, result6];\n              } else {\n                var result1 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(n) { return n })(result1[2])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"end tag\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_context() {\n        var cacheKey = 'context@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        if (input.substr(pos, 1) === \":\") {\n          var result6 = \":\";\n          pos += 1;\n        } else {\n          var result6 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\":\\\"\");\n          }\n        }\n        if (result6 !== null) {\n          var result7 = parse_identifier();\n          if (result7 !== null) {\n            var result4 = [result6, result7];\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result4 = null;\n          pos = savedPos2;\n        }\n        var result5 = result4 !== null\n          ? (function(n) {return n})(result4[1])\n          : null;\n        if (result5 !== null) {\n          var result3 = result5;\n        } else {\n          var result3 = null;\n          pos = savedPos1;\n        }\n        var result1 = result3 !== null ? result3 : '';\n        var result2 = result1 !== null\n          ? (function(n) { return n ? [\"context\", n] : [\"context\"] })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_params() {\n        var cacheKey = 'params@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var result1 = [];\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        var result6 = parse_ws();\n        if (result6 !== null) {\n          var result7 = parse_key();\n          if (result7 !== null) {\n            if (input.substr(pos, 1) === \"=\") {\n              var result8 = \"=\";\n              pos += 1;\n            } else {\n              var result8 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"=\\\"\");\n              }\n            }\n            if (result8 !== null) {\n              var result11 = parse_identifier();\n              if (result11 !== null) {\n                var result9 = result11;\n              } else {\n                var result10 = parse_inline();\n                if (result10 !== null) {\n                  var result9 = result10;\n                } else {\n                  var result9 = null;;\n                };\n              }\n              if (result9 !== null) {\n                var result4 = [result6, result7, result8, result9];\n              } else {\n                var result4 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result4 = null;\n          pos = savedPos2;\n        }\n        var result5 = result4 !== null\n          ? (function(k, v) {return [\"param\", [\"literal\", k], v]})(result4[1], result4[3])\n          : null;\n        if (result5 !== null) {\n          var result3 = result5;\n        } else {\n          var result3 = null;\n          pos = savedPos1;\n        }\n        while (result3 !== null) {\n          result1.push(result3);\n          var savedPos1 = pos;\n          var savedPos2 = pos;\n          var result6 = parse_ws();\n          if (result6 !== null) {\n            var result7 = parse_key();\n            if (result7 !== null) {\n              if (input.substr(pos, 1) === \"=\") {\n                var result8 = \"=\";\n                pos += 1;\n              } else {\n                var result8 = null;\n                if (reportMatchFailures) {\n                  matchFailed(\"\\\"=\\\"\");\n                }\n              }\n              if (result8 !== null) {\n                var result11 = parse_identifier();\n                if (result11 !== null) {\n                  var result9 = result11;\n                } else {\n                  var result10 = parse_inline();\n                  if (result10 !== null) {\n                    var result9 = result10;\n                  } else {\n                    var result9 = null;;\n                  };\n                }\n                if (result9 !== null) {\n                  var result4 = [result6, result7, result8, result9];\n                } else {\n                  var result4 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result4 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n          var result5 = result4 !== null\n            ? (function(k, v) {return [\"param\", [\"literal\", k], v]})(result4[1], result4[3])\n            : null;\n          if (result5 !== null) {\n            var result3 = result5;\n          } else {\n            var result3 = null;\n            pos = savedPos1;\n          }\n        }\n        var result2 = result1 !== null\n          ? (function(p) { return [\"params\"].concat(p) })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"params\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_bodies() {\n        var cacheKey = 'bodies@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var result1 = [];\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        var result6 = parse_ld();\n        if (result6 !== null) {\n          if (input.substr(pos, 1) === \":\") {\n            var result7 = \":\";\n            pos += 1;\n          } else {\n            var result7 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result7 !== null) {\n            var result8 = parse_key();\n            if (result8 !== null) {\n              var result9 = parse_rd();\n              if (result9 !== null) {\n                var result10 = parse_body();\n                if (result10 !== null) {\n                  var result4 = [result6, result7, result8, result9, result10];\n                } else {\n                  var result4 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result4 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result4 = null;\n          pos = savedPos2;\n        }\n        var result5 = result4 !== null\n          ? (function(k, v) {return [\"param\", [\"literal\", k], v]})(result4[2], result4[4])\n          : null;\n        if (result5 !== null) {\n          var result3 = result5;\n        } else {\n          var result3 = null;\n          pos = savedPos1;\n        }\n        while (result3 !== null) {\n          result1.push(result3);\n          var savedPos1 = pos;\n          var savedPos2 = pos;\n          var result6 = parse_ld();\n          if (result6 !== null) {\n            if (input.substr(pos, 1) === \":\") {\n              var result7 = \":\";\n              pos += 1;\n            } else {\n              var result7 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\":\\\"\");\n              }\n            }\n            if (result7 !== null) {\n              var result8 = parse_key();\n              if (result8 !== null) {\n                var result9 = parse_rd();\n                if (result9 !== null) {\n                  var result10 = parse_body();\n                  if (result10 !== null) {\n                    var result4 = [result6, result7, result8, result9, result10];\n                  } else {\n                    var result4 = null;\n                    pos = savedPos2;\n                  }\n                } else {\n                  var result4 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result4 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n          var result5 = result4 !== null\n            ? (function(k, v) {return [\"param\", [\"literal\", k], v]})(result4[2], result4[4])\n            : null;\n          if (result5 !== null) {\n            var result3 = result5;\n          } else {\n            var result3 = null;\n            pos = savedPos1;\n          }\n        }\n        var result2 = result1 !== null\n          ? (function(p) { return [\"bodies\"].concat(p) })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"bodies\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_reference() {\n        var cacheKey = 'reference@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          var result4 = parse_identifier();\n          if (result4 !== null) {\n            var result5 = parse_filters();\n            if (result5 !== null) {\n              var result6 = parse_rd();\n              if (result6 !== null) {\n                var result1 = [result3, result4, result5, result6];\n              } else {\n                var result1 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(n, f) { return [\"reference\", n, f] })(result1[1], result1[2])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"reference\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_partial() {\n        var cacheKey = 'partial@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          if (input.substr(pos, 1) === \">\") {\n            var result4 = \">\";\n            pos += 1;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\">\\\"\");\n            }\n          }\n          if (result4 !== null) {\n            var savedPos2 = pos;\n            var result11 = parse_key();\n            var result12 = result11 !== null\n              ? (function(k) {return [\"literal\", k]})(result11)\n              : null;\n            if (result12 !== null) {\n              var result10 = result12;\n            } else {\n              var result10 = null;\n              pos = savedPos2;\n            }\n            if (result10 !== null) {\n              var result5 = result10;\n            } else {\n              var result9 = parse_inline();\n              if (result9 !== null) {\n                var result5 = result9;\n              } else {\n                var result5 = null;;\n              };\n            }\n            if (result5 !== null) {\n              var result6 = parse_context();\n              if (result6 !== null) {\n                if (input.substr(pos, 1) === \"/\") {\n                  var result7 = \"/\";\n                  pos += 1;\n                } else {\n                  var result7 = null;\n                  if (reportMatchFailures) {\n                    matchFailed(\"\\\"/\\\"\");\n                  }\n                }\n                if (result7 !== null) {\n                  var result8 = parse_rd();\n                  if (result8 !== null) {\n                    var result1 = [result3, result4, result5, result6, result7, result8];\n                  } else {\n                    var result1 = null;\n                    pos = savedPos1;\n                  }\n                } else {\n                  var result1 = null;\n                  pos = savedPos1;\n                }\n              } else {\n                var result1 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(n, c) { return [\"partial\", n, c] })(result1[2], result1[3])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"partial\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_filters() {\n        var cacheKey = 'filters@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var result1 = [];\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        if (input.substr(pos, 1) === \"|\") {\n          var result6 = \"|\";\n          pos += 1;\n        } else {\n          var result6 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"|\\\"\");\n          }\n        }\n        if (result6 !== null) {\n          var result7 = parse_key();\n          if (result7 !== null) {\n            var result4 = [result6, result7];\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result4 = null;\n          pos = savedPos2;\n        }\n        var result5 = result4 !== null\n          ? (function(n) {return n})(result4[1])\n          : null;\n        if (result5 !== null) {\n          var result3 = result5;\n        } else {\n          var result3 = null;\n          pos = savedPos1;\n        }\n        while (result3 !== null) {\n          result1.push(result3);\n          var savedPos1 = pos;\n          var savedPos2 = pos;\n          if (input.substr(pos, 1) === \"|\") {\n            var result6 = \"|\";\n            pos += 1;\n          } else {\n            var result6 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"|\\\"\");\n            }\n          }\n          if (result6 !== null) {\n            var result7 = parse_key();\n            if (result7 !== null) {\n              var result4 = [result6, result7];\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n          var result5 = result4 !== null\n            ? (function(n) {return n})(result4[1])\n            : null;\n          if (result5 !== null) {\n            var result3 = result5;\n          } else {\n            var result3 = null;\n            pos = savedPos1;\n          }\n        }\n        var result2 = result1 !== null\n          ? (function(f) { return [\"filters\"].concat(f) })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"filters\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_special() {\n        var cacheKey = 'special@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          if (input.substr(pos, 1) === \"~\") {\n            var result4 = \"~\";\n            pos += 1;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"~\\\"\");\n            }\n          }\n          if (result4 !== null) {\n            var result5 = parse_key();\n            if (result5 !== null) {\n              var result6 = parse_rd();\n              if (result6 !== null) {\n                var result1 = [result3, result4, result5, result6];\n              } else {\n                var result1 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(k) { return [\"special\", k] })(result1[2])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"special\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_identifier() {\n        var cacheKey = 'identifier@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos1 = pos;\n        var result5 = parse_path();\n        var result6 = result5 !== null\n          ? (function(p) { return wrap([\"path\"].concat(p), cacheKey) })(result5)\n          : null;\n        if (result6 !== null) {\n          var result4 = result6;\n        } else {\n          var result4 = null;\n          pos = savedPos1;\n        }\n        if (result4 !== null) {\n          var result0 = result4;\n        } else {\n          var savedPos0 = pos;\n          var result2 = parse_key();\n          var result3 = result2 !== null\n            ? (function(k) { return wrap([\"key\", k], cacheKey) })(result2)\n            : null;\n          if (result3 !== null) {\n            var result1 = result3;\n          } else {\n            var result1 = null;\n            pos = savedPos0;\n          }\n          if (result1 !== null) {\n            var result0 = result1;\n          } else {\n            var result0 = null;;\n          };\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"identifier\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_path() {\n        var cacheKey = 'path@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        var result14 = parse_key();\n        var result7 = result14 !== null ? result14 : '';\n        if (result7 !== null) {\n          var savedPos3 = pos;\n          var savedPos4 = pos;\n          if (input.substr(pos, 1) === \".\") {\n            var result12 = \".\";\n            pos += 1;\n          } else {\n            var result12 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result12 !== null) {\n            var result13 = parse_key();\n            if (result13 !== null) {\n              var result10 = [result12, result13];\n            } else {\n              var result10 = null;\n              pos = savedPos4;\n            }\n          } else {\n            var result10 = null;\n            pos = savedPos4;\n          }\n          var result11 = result10 !== null\n            ? (function(k) {return k})(result10[1])\n            : null;\n          if (result11 !== null) {\n            var result9 = result11;\n          } else {\n            var result9 = null;\n            pos = savedPos3;\n          }\n          if (result9 !== null) {\n            var result8 = [];\n            while (result9 !== null) {\n              result8.push(result9);\n              var savedPos3 = pos;\n              var savedPos4 = pos;\n              if (input.substr(pos, 1) === \".\") {\n                var result12 = \".\";\n                pos += 1;\n              } else {\n                var result12 = null;\n                if (reportMatchFailures) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result12 !== null) {\n                var result13 = parse_key();\n                if (result13 !== null) {\n                  var result10 = [result12, result13];\n                } else {\n                  var result10 = null;\n                  pos = savedPos4;\n                }\n              } else {\n                var result10 = null;\n                pos = savedPos4;\n              }\n              var result11 = result10 !== null\n                ? (function(k) {return k})(result10[1])\n                : null;\n              if (result11 !== null) {\n                var result9 = result11;\n              } else {\n                var result9 = null;\n                pos = savedPos3;\n              }\n            }\n          } else {\n            var result8 = null;\n          }\n          if (result8 !== null) {\n            var result5 = [result7, result8];\n          } else {\n            var result5 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result5 = null;\n          pos = savedPos2;\n        }\n        var result6 = result5 !== null\n          ? (function(k, d) {\n              if (k) { d.unshift(k); return [false, d]; }\n              return [true, d];\n            })(result5[0], result5[1])\n          : null;\n        if (result6 !== null) {\n          var result4 = result6;\n        } else {\n          var result4 = null;\n          pos = savedPos1;\n        }\n        if (result4 !== null) {\n          var result0 = result4;\n        } else {\n          var savedPos0 = pos;\n          if (input.substr(pos, 1) === \".\") {\n            var result2 = \".\";\n            pos += 1;\n          } else {\n            var result2 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          var result3 = result2 !== null\n            ? (function() { return [true, []] })()\n            : null;\n          if (result3 !== null) {\n            var result1 = result3;\n          } else {\n            var result1 = null;\n            pos = savedPos0;\n          }\n          if (result1 !== null) {\n            var result0 = result1;\n          } else {\n            var result0 = null;;\n          };\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"path\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_key() {\n        var cacheKey = 'key@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        if (input.substr(pos).match(/^[a-zA-Z_$]/) !== null) {\n          var result3 = input.charAt(pos);\n          pos++;\n        } else {\n          var result3 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"[a-zA-Z_$]\");\n          }\n        }\n        if (result3 !== null) {\n          var result4 = [];\n          if (input.substr(pos).match(/^[0-9a-zA-Z_$]/) !== null) {\n            var result5 = input.charAt(pos);\n            pos++;\n          } else {\n            var result5 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"[0-9a-zA-Z_$]\");\n            }\n          }\n          while (result5 !== null) {\n            result4.push(result5);\n            if (input.substr(pos).match(/^[0-9a-zA-Z_$]/) !== null) {\n              var result5 = input.charAt(pos);\n              pos++;\n            } else {\n              var result5 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"[0-9a-zA-Z_$]\");\n              }\n            }\n          }\n          if (result4 !== null) {\n            var result1 = [result3, result4];\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(h, t) { return h + t.join('') })(result1[0], result1[1])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"key\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_inline() {\n        var cacheKey = 'inline@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos4 = pos;\n        var savedPos5 = pos;\n        if (input.substr(pos, 1) === \"\\\"\") {\n          var result17 = \"\\\"\";\n          pos += 1;\n        } else {\n          var result17 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"\\\\\\\"\\\"\");\n          }\n        }\n        if (result17 !== null) {\n          if (input.substr(pos, 1) === \"\\\"\") {\n            var result18 = \"\\\"\";\n            pos += 1;\n          } else {\n            var result18 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result18 !== null) {\n            var result15 = [result17, result18];\n          } else {\n            var result15 = null;\n            pos = savedPos5;\n          }\n        } else {\n          var result15 = null;\n          pos = savedPos5;\n        }\n        var result16 = result15 !== null\n          ? (function() { return [\"literal\", \"\"] })()\n          : null;\n        if (result16 !== null) {\n          var result14 = result16;\n        } else {\n          var result14 = null;\n          pos = savedPos4;\n        }\n        if (result14 !== null) {\n          var result0 = result14;\n        } else {\n          var savedPos2 = pos;\n          var savedPos3 = pos;\n          if (input.substr(pos, 1) === \"\\\"\") {\n            var result11 = \"\\\"\";\n            pos += 1;\n          } else {\n            var result11 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result11 !== null) {\n            var result12 = parse_literal();\n            if (result12 !== null) {\n              if (input.substr(pos, 1) === \"\\\"\") {\n                var result13 = \"\\\"\";\n                pos += 1;\n              } else {\n                var result13 = null;\n                if (reportMatchFailures) {\n                  matchFailed(\"\\\"\\\\\\\"\\\"\");\n                }\n              }\n              if (result13 !== null) {\n                var result9 = [result11, result12, result13];\n              } else {\n                var result9 = null;\n                pos = savedPos3;\n              }\n            } else {\n              var result9 = null;\n              pos = savedPos3;\n            }\n          } else {\n            var result9 = null;\n            pos = savedPos3;\n          }\n          var result10 = result9 !== null\n            ? (function(l) { return [\"literal\", l] })(result9[1])\n            : null;\n          if (result10 !== null) {\n            var result8 = result10;\n          } else {\n            var result8 = null;\n            pos = savedPos2;\n          }\n          if (result8 !== null) {\n            var result0 = result8;\n          } else {\n            var savedPos0 = pos;\n            var savedPos1 = pos;\n            if (input.substr(pos, 1) === \"\\\"\") {\n              var result4 = \"\\\"\";\n              pos += 1;\n            } else {\n              var result4 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"\\\\\\\"\\\"\");\n              }\n            }\n            if (result4 !== null) {\n              var result7 = parse_inline_part();\n              if (result7 !== null) {\n                var result5 = [];\n                while (result7 !== null) {\n                  result5.push(result7);\n                  var result7 = parse_inline_part();\n                }\n              } else {\n                var result5 = null;\n              }\n              if (result5 !== null) {\n                if (input.substr(pos, 1) === \"\\\"\") {\n                  var result6 = \"\\\"\";\n                  pos += 1;\n                } else {\n                  var result6 = null;\n                  if (reportMatchFailures) {\n                    matchFailed(\"\\\"\\\\\\\"\\\"\");\n                  }\n                }\n                if (result6 !== null) {\n                  var result2 = [result4, result5, result6];\n                } else {\n                  var result2 = null;\n                  pos = savedPos1;\n                }\n              } else {\n                var result2 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result2 = null;\n              pos = savedPos1;\n            }\n            var result3 = result2 !== null\n              ? (function(p) { return [\"body\"].concat(p) })(result2[1])\n              : null;\n            if (result3 !== null) {\n              var result1 = result3;\n            } else {\n              var result1 = null;\n              pos = savedPos0;\n            }\n            if (result1 !== null) {\n              var result0 = result1;\n            } else {\n              var result0 = null;;\n            };\n          };\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"inline\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_inline_part() {\n        var cacheKey = 'inline_part@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var result5 = parse_special();\n        if (result5 !== null) {\n          var result0 = result5;\n        } else {\n          var result4 = parse_reference();\n          if (result4 !== null) {\n            var result0 = result4;\n          } else {\n            var savedPos0 = pos;\n            var result2 = parse_literal();\n            var result3 = result2 !== null\n              ? (function(l) { return [\"buffer\", l] })(result2)\n              : null;\n            if (result3 !== null) {\n              var result1 = result3;\n            } else {\n              var result1 = null;\n              pos = savedPos0;\n            }\n            if (result1 !== null) {\n              var result0 = result1;\n            } else {\n              var result0 = null;;\n            };\n          };\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_buffer() {\n        var cacheKey = 'buffer@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos6 = pos;\n        var savedPos7 = pos;\n        var result17 = parse_eol();\n        if (result17 !== null) {\n          var result18 = [];\n          var result19 = parse_ws();\n          while (result19 !== null) {\n            result18.push(result19);\n            var result19 = parse_ws();\n          }\n          if (result18 !== null) {\n            var result15 = [result17, result18];\n          } else {\n            var result15 = null;\n            pos = savedPos7;\n          }\n        } else {\n          var result15 = null;\n          pos = savedPos7;\n        }\n        var result16 = result15 !== null\n          ? (function(e, w) { return [\"format\", e, w.join('')] })(result15[0], result15[1])\n          : null;\n        if (result16 !== null) {\n          var result14 = result16;\n        } else {\n          var result14 = null;\n          pos = savedPos6;\n        }\n        if (result14 !== null) {\n          var result0 = result14;\n        } else {\n          var savedPos0 = pos;\n          var savedPos1 = pos;\n          var savedPos2 = pos;\n          var savedPos5 = pos;\n          var savedReportMatchFailuresVar2 = reportMatchFailures;\n          reportMatchFailures = false;\n          var result13 = parse_tag();\n          reportMatchFailures = savedReportMatchFailuresVar2;\n          if (result13 === null) {\n            var result7 = '';\n          } else {\n            var result7 = null;\n            pos = savedPos5;\n          }\n          if (result7 !== null) {\n            var savedPos4 = pos;\n            var savedReportMatchFailuresVar1 = reportMatchFailures;\n            reportMatchFailures = false;\n            var result12 = parse_eol();\n            reportMatchFailures = savedReportMatchFailuresVar1;\n            if (result12 === null) {\n              var result8 = '';\n            } else {\n              var result8 = null;\n              pos = savedPos4;\n            }\n            if (result8 !== null) {\n              var savedPos3 = pos;\n              var savedReportMatchFailuresVar0 = reportMatchFailures;\n              reportMatchFailures = false;\n              var result11 = parse_comment();\n              reportMatchFailures = savedReportMatchFailuresVar0;\n              if (result11 === null) {\n                var result9 = '';\n              } else {\n                var result9 = null;\n                pos = savedPos3;\n              }\n              if (result9 !== null) {\n                if (input.length > pos) {\n                  var result10 = input.charAt(pos);\n                  pos++;\n                } else {\n                  var result10 = null;\n                  if (reportMatchFailures) {\n                    matchFailed('any character');\n                  }\n                }\n                if (result10 !== null) {\n                  var result5 = [result7, result8, result9, result10];\n                } else {\n                  var result5 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result5 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result5 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result5 = null;\n            pos = savedPos2;\n          }\n          var result6 = result5 !== null\n            ? (function(c) {return c})(result5[3])\n            : null;\n          if (result6 !== null) {\n            var result4 = result6;\n          } else {\n            var result4 = null;\n            pos = savedPos1;\n          }\n          if (result4 !== null) {\n            var result2 = [];\n            while (result4 !== null) {\n              result2.push(result4);\n              var savedPos1 = pos;\n              var savedPos2 = pos;\n              var savedPos5 = pos;\n              var savedReportMatchFailuresVar2 = reportMatchFailures;\n              reportMatchFailures = false;\n              var result13 = parse_tag();\n              reportMatchFailures = savedReportMatchFailuresVar2;\n              if (result13 === null) {\n                var result7 = '';\n              } else {\n                var result7 = null;\n                pos = savedPos5;\n              }\n              if (result7 !== null) {\n                var savedPos4 = pos;\n                var savedReportMatchFailuresVar1 = reportMatchFailures;\n                reportMatchFailures = false;\n                var result12 = parse_eol();\n                reportMatchFailures = savedReportMatchFailuresVar1;\n                if (result12 === null) {\n                  var result8 = '';\n                } else {\n                  var result8 = null;\n                  pos = savedPos4;\n                }\n                if (result8 !== null) {\n                  var savedPos3 = pos;\n                  var savedReportMatchFailuresVar0 = reportMatchFailures;\n                  reportMatchFailures = false;\n                  var result11 = parse_comment();\n                  reportMatchFailures = savedReportMatchFailuresVar0;\n                  if (result11 === null) {\n                    var result9 = '';\n                  } else {\n                    var result9 = null;\n                    pos = savedPos3;\n                  }\n                  if (result9 !== null) {\n                    if (input.length > pos) {\n                      var result10 = input.charAt(pos);\n                      pos++;\n                    } else {\n                      var result10 = null;\n                      if (reportMatchFailures) {\n                        matchFailed('any character');\n                      }\n                    }\n                    if (result10 !== null) {\n                      var result5 = [result7, result8, result9, result10];\n                    } else {\n                      var result5 = null;\n                      pos = savedPos2;\n                    }\n                  } else {\n                    var result5 = null;\n                    pos = savedPos2;\n                  }\n                } else {\n                  var result5 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result5 = null;\n                pos = savedPos2;\n              }\n              var result6 = result5 !== null\n                ? (function(c) {return c})(result5[3])\n                : null;\n              if (result6 !== null) {\n                var result4 = result6;\n              } else {\n                var result4 = null;\n                pos = savedPos1;\n              }\n            }\n          } else {\n            var result2 = null;\n          }\n          var result3 = result2 !== null\n            ? (function(b) { return [\"buffer\", b.join('')] })(result2)\n            : null;\n          if (result3 !== null) {\n            var result1 = result3;\n          } else {\n            var result1 = null;\n            pos = savedPos0;\n          }\n          if (result1 !== null) {\n            var result0 = result1;\n          } else {\n            var result0 = null;;\n          };\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"buffer\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_literal() {\n        var cacheKey = 'literal@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        var savedPos2 = pos;\n        var savedPos4 = pos;\n        var savedReportMatchFailuresVar1 = reportMatchFailures;\n        reportMatchFailures = false;\n        var result12 = parse_tag();\n        reportMatchFailures = savedReportMatchFailuresVar1;\n        if (result12 === null) {\n          var result6 = '';\n        } else {\n          var result6 = null;\n          pos = savedPos4;\n        }\n        if (result6 !== null) {\n          var savedPos3 = pos;\n          var savedReportMatchFailuresVar0 = reportMatchFailures;\n          reportMatchFailures = false;\n          var result11 = parse_eol();\n          reportMatchFailures = savedReportMatchFailuresVar0;\n          if (result11 === null) {\n            var result7 = '';\n          } else {\n            var result7 = null;\n            pos = savedPos3;\n          }\n          if (result7 !== null) {\n            var result10 = parse_esc();\n            if (result10 !== null) {\n              var result8 = result10;\n            } else {\n              if (input.substr(pos).match(/^[^\"]/) !== null) {\n                var result9 = input.charAt(pos);\n                pos++;\n              } else {\n                var result9 = null;\n                if (reportMatchFailures) {\n                  matchFailed(\"[^\\\"]\");\n                }\n              }\n              if (result9 !== null) {\n                var result8 = result9;\n              } else {\n                var result8 = null;;\n              };\n            }\n            if (result8 !== null) {\n              var result4 = [result6, result7, result8];\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n          } else {\n            var result4 = null;\n            pos = savedPos2;\n          }\n        } else {\n          var result4 = null;\n          pos = savedPos2;\n        }\n        var result5 = result4 !== null\n          ? (function(c) {return c})(result4[2])\n          : null;\n        if (result5 !== null) {\n          var result3 = result5;\n        } else {\n          var result3 = null;\n          pos = savedPos1;\n        }\n        if (result3 !== null) {\n          var result1 = [];\n          while (result3 !== null) {\n            result1.push(result3);\n            var savedPos1 = pos;\n            var savedPos2 = pos;\n            var savedPos4 = pos;\n            var savedReportMatchFailuresVar1 = reportMatchFailures;\n            reportMatchFailures = false;\n            var result12 = parse_tag();\n            reportMatchFailures = savedReportMatchFailuresVar1;\n            if (result12 === null) {\n              var result6 = '';\n            } else {\n              var result6 = null;\n              pos = savedPos4;\n            }\n            if (result6 !== null) {\n              var savedPos3 = pos;\n              var savedReportMatchFailuresVar0 = reportMatchFailures;\n              reportMatchFailures = false;\n              var result11 = parse_eol();\n              reportMatchFailures = savedReportMatchFailuresVar0;\n              if (result11 === null) {\n                var result7 = '';\n              } else {\n                var result7 = null;\n                pos = savedPos3;\n              }\n              if (result7 !== null) {\n                var result10 = parse_esc();\n                if (result10 !== null) {\n                  var result8 = result10;\n                } else {\n                  if (input.substr(pos).match(/^[^\"]/) !== null) {\n                    var result9 = input.charAt(pos);\n                    pos++;\n                  } else {\n                    var result9 = null;\n                    if (reportMatchFailures) {\n                      matchFailed(\"[^\\\"]\");\n                    }\n                  }\n                  if (result9 !== null) {\n                    var result8 = result9;\n                  } else {\n                    var result8 = null;;\n                  };\n                }\n                if (result8 !== null) {\n                  var result4 = [result6, result7, result8];\n                } else {\n                  var result4 = null;\n                  pos = savedPos2;\n                }\n              } else {\n                var result4 = null;\n                pos = savedPos2;\n              }\n            } else {\n              var result4 = null;\n              pos = savedPos2;\n            }\n            var result5 = result4 !== null\n              ? (function(c) {return c})(result4[2])\n              : null;\n            if (result5 !== null) {\n              var result3 = result5;\n            } else {\n              var result3 = null;\n              pos = savedPos1;\n            }\n          }\n        } else {\n          var result1 = null;\n        }\n        var result2 = result1 !== null\n          ? (function(b) { return b.join('') })(result1)\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"literal\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_esc() {\n        var cacheKey = 'esc@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var savedPos0 = pos;\n        if (input.substr(pos, 2) === \"\\\\\\\"\") {\n          var result1 = \"\\\\\\\"\";\n          pos += 2;\n        } else {\n          var result1 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"\\\\\\\\\\\\\\\"\\\"\");\n          }\n        }\n        var result2 = result1 !== null\n          ? (function() { return '\"' })()\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_comment() {\n        var cacheKey = 'comment@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        var savedReportMatchFailures = reportMatchFailures;\n        reportMatchFailures = false;\n        var savedPos0 = pos;\n        var savedPos1 = pos;\n        if (input.substr(pos, 2) === \"{!\") {\n          var result3 = \"{!\";\n          pos += 2;\n        } else {\n          var result3 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"{!\\\"\");\n          }\n        }\n        if (result3 !== null) {\n          var result4 = [];\n          var savedPos2 = pos;\n          var savedPos3 = pos;\n          var savedPos4 = pos;\n          var savedReportMatchFailuresVar0 = reportMatchFailures;\n          reportMatchFailures = false;\n          if (input.substr(pos, 2) === \"!}\") {\n            var result11 = \"!}\";\n            pos += 2;\n          } else {\n            var result11 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"!}\\\"\");\n            }\n          }\n          reportMatchFailures = savedReportMatchFailuresVar0;\n          if (result11 === null) {\n            var result9 = '';\n          } else {\n            var result9 = null;\n            pos = savedPos4;\n          }\n          if (result9 !== null) {\n            if (input.length > pos) {\n              var result10 = input.charAt(pos);\n              pos++;\n            } else {\n              var result10 = null;\n              if (reportMatchFailures) {\n                matchFailed('any character');\n              }\n            }\n            if (result10 !== null) {\n              var result7 = [result9, result10];\n            } else {\n              var result7 = null;\n              pos = savedPos3;\n            }\n          } else {\n            var result7 = null;\n            pos = savedPos3;\n          }\n          var result8 = result7 !== null\n            ? (function(c) {return c})(result7[1])\n            : null;\n          if (result8 !== null) {\n            var result6 = result8;\n          } else {\n            var result6 = null;\n            pos = savedPos2;\n          }\n          while (result6 !== null) {\n            result4.push(result6);\n            var savedPos2 = pos;\n            var savedPos3 = pos;\n            var savedPos4 = pos;\n            var savedReportMatchFailuresVar0 = reportMatchFailures;\n            reportMatchFailures = false;\n            if (input.substr(pos, 2) === \"!}\") {\n              var result11 = \"!}\";\n              pos += 2;\n            } else {\n              var result11 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"!}\\\"\");\n              }\n            }\n            reportMatchFailures = savedReportMatchFailuresVar0;\n            if (result11 === null) {\n              var result9 = '';\n            } else {\n              var result9 = null;\n              pos = savedPos4;\n            }\n            if (result9 !== null) {\n              if (input.length > pos) {\n                var result10 = input.charAt(pos);\n                pos++;\n              } else {\n                var result10 = null;\n                if (reportMatchFailures) {\n                  matchFailed('any character');\n                }\n              }\n              if (result10 !== null) {\n                var result7 = [result9, result10];\n              } else {\n                var result7 = null;\n                pos = savedPos3;\n              }\n            } else {\n              var result7 = null;\n              pos = savedPos3;\n            }\n            var result8 = result7 !== null\n              ? (function(c) {return c})(result7[1])\n              : null;\n            if (result8 !== null) {\n              var result6 = result8;\n            } else {\n              var result6 = null;\n              pos = savedPos2;\n            }\n          }\n          if (result4 !== null) {\n            if (input.substr(pos, 2) === \"!}\") {\n              var result5 = \"!}\";\n              pos += 2;\n            } else {\n              var result5 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"!}\\\"\");\n              }\n            }\n            if (result5 !== null) {\n              var result1 = [result3, result4, result5];\n            } else {\n              var result1 = null;\n              pos = savedPos1;\n            }\n          } else {\n            var result1 = null;\n            pos = savedPos1;\n          }\n        } else {\n          var result1 = null;\n          pos = savedPos1;\n        }\n        var result2 = result1 !== null\n          ? (function(c) { return [\"comment\", c.join('')] })(result1[1])\n          : null;\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result0 = null;\n          pos = savedPos0;\n        }\n        reportMatchFailures = savedReportMatchFailures;\n        if (reportMatchFailures && result0 === null) {\n          matchFailed(\"comment\");\n        }\n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_tag() {\n        var cacheKey = 'tag@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        var savedPos0 = pos;\n        var result3 = parse_ld();\n        if (result3 !== null) {\n          if (input.substr(pos).match(/^[#?^><+%:@\\/~%]/) !== null) {\n            var result4 = input.charAt(pos);\n            pos++;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"[#?^><+%:@\\\\/~%]\");\n            }\n          }\n          if (result4 !== null) {\n            var savedPos1 = pos;\n            var savedPos3 = pos;\n            var savedReportMatchFailuresVar1 = reportMatchFailures;\n            reportMatchFailures = false;\n            var result12 = parse_rd();\n            reportMatchFailures = savedReportMatchFailuresVar1;\n            if (result12 === null) {\n              var result8 = '';\n            } else {\n              var result8 = null;\n              pos = savedPos3;\n            }\n            if (result8 !== null) {\n              var savedPos2 = pos;\n              var savedReportMatchFailuresVar0 = reportMatchFailures;\n              reportMatchFailures = false;\n              var result11 = parse_eol();\n              reportMatchFailures = savedReportMatchFailuresVar0;\n              if (result11 === null) {\n                var result9 = '';\n              } else {\n                var result9 = null;\n                pos = savedPos2;\n              }\n              if (result9 !== null) {\n                if (input.length > pos) {\n                  var result10 = input.charAt(pos);\n                  pos++;\n                } else {\n                  var result10 = null;\n                  if (reportMatchFailures) {\n                    matchFailed('any character');\n                  }\n                }\n                if (result10 !== null) {\n                  var result7 = [result8, result9, result10];\n                } else {\n                  var result7 = null;\n                  pos = savedPos1;\n                }\n              } else {\n                var result7 = null;\n                pos = savedPos1;\n              }\n            } else {\n              var result7 = null;\n              pos = savedPos1;\n            }\n            if (result7 !== null) {\n              var result5 = [];\n              while (result7 !== null) {\n                result5.push(result7);\n                var savedPos1 = pos;\n                var savedPos3 = pos;\n                var savedReportMatchFailuresVar1 = reportMatchFailures;\n                reportMatchFailures = false;\n                var result12 = parse_rd();\n                reportMatchFailures = savedReportMatchFailuresVar1;\n                if (result12 === null) {\n                  var result8 = '';\n                } else {\n                  var result8 = null;\n                  pos = savedPos3;\n                }\n                if (result8 !== null) {\n                  var savedPos2 = pos;\n                  var savedReportMatchFailuresVar0 = reportMatchFailures;\n                  reportMatchFailures = false;\n                  var result11 = parse_eol();\n                  reportMatchFailures = savedReportMatchFailuresVar0;\n                  if (result11 === null) {\n                    var result9 = '';\n                  } else {\n                    var result9 = null;\n                    pos = savedPos2;\n                  }\n                  if (result9 !== null) {\n                    if (input.length > pos) {\n                      var result10 = input.charAt(pos);\n                      pos++;\n                    } else {\n                      var result10 = null;\n                      if (reportMatchFailures) {\n                        matchFailed('any character');\n                      }\n                    }\n                    if (result10 !== null) {\n                      var result7 = [result8, result9, result10];\n                    } else {\n                      var result7 = null;\n                      pos = savedPos1;\n                    }\n                  } else {\n                    var result7 = null;\n                    pos = savedPos1;\n                  }\n                } else {\n                  var result7 = null;\n                  pos = savedPos1;\n                }\n              }\n            } else {\n              var result5 = null;\n            }\n            if (result5 !== null) {\n              var result6 = parse_rd();\n              if (result6 !== null) {\n                var result2 = [result3, result4, result5, result6];\n              } else {\n                var result2 = null;\n                pos = savedPos0;\n              }\n            } else {\n              var result2 = null;\n              pos = savedPos0;\n            }\n          } else {\n            var result2 = null;\n            pos = savedPos0;\n          }\n        } else {\n          var result2 = null;\n          pos = savedPos0;\n        }\n        if (result2 !== null) {\n          var result0 = result2;\n        } else {\n          var result1 = parse_reference();\n          if (result1 !== null) {\n            var result0 = result1;\n          } else {\n            var result0 = null;;\n          };\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_ld() {\n        var cacheKey = 'ld@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        if (input.substr(pos, 1) === \"{\") {\n          var result0 = \"{\";\n          pos += 1;\n        } else {\n          var result0 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"{\\\"\");\n          }\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_rd() {\n        var cacheKey = 'rd@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        if (input.substr(pos, 1) === \"}\") {\n          var result0 = \"}\";\n          pos += 1;\n        } else {\n          var result0 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"}\\\"\");\n          }\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_eol() {\n        var cacheKey = 'eol@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        if (input.substr(pos, 1) === \"\\n\") {\n          var result5 = \"\\n\";\n          pos += 1;\n        } else {\n          var result5 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"\\\"\\\\n\\\"\");\n          }\n        }\n        if (result5 !== null) {\n          var result0 = result5;\n        } else {\n          if (input.substr(pos, 2) === \"\\r\\n\") {\n            var result4 = \"\\r\\n\";\n            pos += 2;\n          } else {\n            var result4 = null;\n            if (reportMatchFailures) {\n              matchFailed(\"\\\"\\\\r\\\\n\\\"\");\n            }\n          }\n          if (result4 !== null) {\n            var result0 = result4;\n          } else {\n            if (input.substr(pos, 1) === \"\\r\") {\n              var result3 = \"\\r\";\n              pos += 1;\n            } else {\n              var result3 = null;\n              if (reportMatchFailures) {\n                matchFailed(\"\\\"\\\\r\\\"\");\n              }\n            }\n            if (result3 !== null) {\n              var result0 = result3;\n            } else {\n              if (input.substr(pos, 1) === \"\\u2028\") {\n                var result2 = \"\\u2028\";\n                pos += 1;\n              } else {\n                var result2 = null;\n                if (reportMatchFailures) {\n                  matchFailed(\"\\\"\\\\u2028\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                var result0 = result2;\n              } else {\n                if (input.substr(pos, 1) === \"\\u2029\") {\n                  var result1 = \"\\u2029\";\n                  pos += 1;\n                } else {\n                  var result1 = null;\n                  if (reportMatchFailures) {\n                    matchFailed(\"\\\"\\\\u2029\\\"\");\n                  }\n                }\n                if (result1 !== null) {\n                  var result0 = result1;\n                } else {\n                  var result0 = null;;\n                };\n              };\n            };\n          };\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function parse_ws() {\n        var cacheKey = 'ws@' + pos;\n        var cachedResult = cache[cacheKey];\n        if (cachedResult) {\n          pos = cachedResult.nextPos;\n          return cachedResult.result;\n        }\n        \n        \n        if (input.substr(pos).match(/^[\t\u000b\f \\xA0\\uFEFF]/) !== null) {\n          var result0 = input.charAt(pos);\n          pos++;\n        } else {\n          var result0 = null;\n          if (reportMatchFailures) {\n            matchFailed(\"[\t\u000b\f \\\\xA0\\\\uFEFF]\");\n          }\n        }\n        \n        \n        \n        cache[cacheKey] = {\n          nextPos: pos,\n          result:  result0\n        };\n        return result0;\n      }\n      \n      function buildErrorMessage() {\n        function buildExpected(failuresExpected) {\n          failuresExpected.sort();\n          \n          var lastFailure = null;\n          var failuresExpectedUnique = [];\n          for (var i = 0; i < failuresExpected.length; i++) {\n            if (failuresExpected[i] !== lastFailure) {\n              failuresExpectedUnique.push(failuresExpected[i]);\n              lastFailure = failuresExpected[i];\n            }\n          }\n          \n          switch (failuresExpectedUnique.length) {\n            case 0:\n              return 'end of input';\n            case 1:\n              return failuresExpectedUnique[0];\n            default:\n              return failuresExpectedUnique.slice(0, failuresExpectedUnique.length - 1).join(', ')\n                + ' or '\n                + failuresExpectedUnique[failuresExpectedUnique.length - 1];\n          }\n        }\n        \n        var expected = buildExpected(rightmostMatchFailuresExpected);\n        var actualPos = Math.max(pos, rightmostMatchFailuresPos);\n        var actual = actualPos < input.length\n          ? quote(input.charAt(actualPos))\n          : 'end of input';\n        \n        return 'Expected ' + expected + ' but ' + actual + ' found.';\n      }\n      \n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        \n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        \n        for (var i = 0; i <  rightmostMatchFailuresPos; i++) {\n          var ch = input.charAt(i);\n          if (ch === '\\n') {\n            if (!seenCR) { line++; }\n            column = 1;\n            seenCR = false;\n          } else if (ch === '\\r' | ch === '\\u2028' || ch === '\\u2029') {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        \n        return { line: line, column: column };\n      }\n      \n      \n      \n    function wrap(node, ck) {\n      \n      node['text'] = input.substring(ck.split('@')[1], pos);\n      \n      return node;\n      \n    }\n      \n  \n      \n      var result = parseFunctions[startRule]();\n      \n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostMatchFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostMatchFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostMatchFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var errorPosition = computeErrorPosition();\n        throw new parser.SyntaxError(\n          buildErrorMessage(),\n          errorPosition.line,\n          errorPosition.column\n        );\n      }\n      \n      return result;\n    },\n    \n    /* Returns the parser source code. */\n    toSource: function() { return this._source; }\n  };\n  \n  /* Thrown when a parser encounters a syntax error. */\n  \n  result.SyntaxError = function(message, line, column) {\n    this.name = 'SyntaxError';\n    this.message = message;\n    this.line = line;\n    this.column = column;\n  };\n  \n  result.SyntaxError.prototype = Error.prototype;\n  \n  return result;\n})();\n\ndust.parse = parser.parse;\n\n})(typeof exports !== 'undefined' ? exports : window.dust);\n//@ sourceURL=/node_modules/dustjs-linkedin/lib/parser.js"
));

require.define("/node_modules/dustjs-linkedin/lib/compiler.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function(dust) {\n\ndust.compile = function(source, name) {\n  try {\n    var ast = filterAST(dust.parse(source));\n    return compile(ast, name);\n  }\n  catch(err)\n  {\n    if(!err.line || !err.column) throw err;    \n    throw new SyntaxError(err.message + \" At line : \" + err.line + \", column : \" + err.column);\n  }\n};\n\nfunction filterAST(ast) {\n  var context = {};\n  return dust.filterNode(context, ast);\n}\n\ndust.filterNode = function(context, node) {\n  return dust.optimizers[node[0]](context, node);\n}\n\ndust.optimizers = {\n  body:      compactBuffers,\n  buffer:    noop,\n  special:   convertSpecial,\n  format:    nullify,        // TODO: convert format\n  reference: visit,\n  \"#\":       visit,\n  \"?\":       visit,\n  \"^\":       visit,\n  \"<\":       visit,\n  \"+\":       visit,\n  \"@\":       visit,\n  \"%\":       visit,\n  partial:   visit,\n  context:   visit,\n  params:    visit,\n  bodies:    visit,\n  param:     visit,\n  filters:   noop,\n  key:       noop,\n  path:      noop,\n  literal:   noop,\n  comment:   nullify\n}\n\ndust.pragmas = {\n  esc: function(compiler, context, bodies, params) {\n    var old = compiler.auto;\n    if (!context) context = 'h';\n    compiler.auto = (context === 's') ? '' : context;\n    var out = compileParts(compiler, bodies.block);\n    compiler.auto = old;\n    return out;\n  }\n}\n\nfunction visit(context, node) {\n  var out = [node[0]];\n  for (var i=1, len=node.length; i<len; i++) {\n    var res = dust.filterNode(context, node[i]);\n    if (res) out.push(res);\n  }\n  return out;\n}\n\n// Compacts consecutive buffer nodes into a single node\nfunction compactBuffers(context, node) {\n  var out = [node[0]], memo;\n  for (var i=1, len=node.length; i<len; i++) {\n    var res = dust.filterNode(context, node[i]);\n    if (res) {\n      if (res[0] === 'buffer') {\n        if (memo) {\n          memo[1] += res[1];\n        } else {\n          memo = res;\n          out.push(res);\n        }\n      } else {\n        memo = null;\n        out.push(res);\n      }\n    }\n  }\n  return out;\n}\n\nvar specialChars = {\n  \"s\": \" \",\n  \"n\": \"\\n\",\n  \"r\": \"\\r\",\n  \"lb\": \"{\",\n  \"rb\": \"}\"\n};\n\nfunction convertSpecial(context, node) { return ['buffer', specialChars[node[1]]] }\nfunction noop(context, node) { return node }\nfunction nullify(){}\n\nfunction compile(ast, name) {\n  var context = {\n    name: name,\n    bodies: [],\n    blocks: {},\n    index: 0,\n    auto: \"h\"\n  }\n\n  return \"(function(){dust.register(\"\n    + (name ? \"\\\"\" + name + \"\\\"\" : \"null\") + \",\"\n    + dust.compileNode(context, ast)\n    + \");\"\n    + compileBlocks(context)\n    + compileBodies(context)\n    + \"return body_0;\"\n    + \"})();\";\n}\n\nfunction compileBlocks(context) {\n  var out = [],\n      blocks = context.blocks;\n\n  for (var name in blocks) {\n    out.push(name + \":\" + blocks[name]);\n  }\n  if (out.length) {\n    context.blocks = \"ctx=ctx.shiftBlocks(blocks);\";\n    return \"var blocks={\" + out.join(',') + \"};\";\n  }\n  return context.blocks = \"\";\n}\n\nfunction compileBodies(context) {\n  var out = [],\n      bodies = context.bodies,\n      blx = context.blocks;\n\n  for (var i=0, len=bodies.length; i<len; i++) {\n    out[i] = \"function body_\" + i + \"(chk,ctx){\"\n      + blx + \"return chk\" + bodies[i] + \";}\";\n  }\n  return out.join('');\n}\n\nfunction compileParts(context, body) {\n  var parts = '';\n  for (var i=1, len=body.length; i<len; i++) {\n    parts += dust.compileNode(context, body[i]);\n  }\n  return parts;\n}\n\ndust.compileNode = function(context, node) {\n  return dust.nodes[node[0]](context, node);\n}\n\ndust.nodes = {\n  body: function(context, node) {\n    var id = context.index++, name = \"body_\" + id;\n    context.bodies[id] = compileParts(context, node);\n    return name;\n  },\n\n  buffer: function(context, node) {\n    return \".write(\" + escape(node[1]) + \")\";\n  },\n\n  format: function(context, node) {\n    return \".write(\" + escape(node[1] + node[2]) + \")\";\n  },\n\n  reference: function(context, node) {\n    return \".reference(\" + dust.compileNode(context, node[1])\n      + \",ctx,\" + dust.compileNode(context, node[2]) + \")\";\n  },\n\n  \"#\": function(context, node) {\n    return compileSection(context, node, \"section\");\n  },\n\n  \"?\": function(context, node) {\n    return compileSection(context, node, \"exists\");\n  },\n\n  \"^\": function(context, node) {\n    return compileSection(context, node, \"notexists\");\n  },\n\n  \"<\": function(context, node) {\n    var bodies = node[4];\n    for (var i=1, len=bodies.length; i<len; i++) {\n      var param = bodies[i],\n          type = param[1][1];\n      if (type === \"block\") {\n        context.blocks[node[1].text] = dust.compileNode(context, param[2]);\n        return '';\n      }\n    }\n    return '';\n  },\n\n  \"+\": function(context, node) {\n    return \".block(ctx.getBlock(\"\n      + escape(node[1].text)\n      + \"),\" + dust.compileNode(context, node[2]) + \",\"\n      + dust.compileNode(context, node[4]) + \",\"\n      + dust.compileNode(context, node[3])\n      + \")\";\n  },\n\n  \"@\": function(context, node) {\n    return \".helper(\"\n      + escape(node[1].text)\n      + \",\" + dust.compileNode(context, node[2]) + \",\"\n      + dust.compileNode(context, node[4]) + \",\"\n      + dust.compileNode(context, node[3])\n      + \")\";\n  },\n\n  \"%\": function(context, node) {\n    // TODO: Move these hacks into pragma precompiler\n    var name = node[1][1];\n    if (!dust.pragmas[name]) return '';\n\n    var rawBodies = node[4];\n    var bodies = {};\n    for (var i=1, len=rawBodies.length; i<len; i++) {\n      var b = rawBodies[i];\n      bodies[b[1][1]] = b[2];\n    }\n\n    var rawParams = node[3];\n    var params = {};\n    for (var i=1, len=rawParams.length; i<len; i++) {\n      var p = rawParams[i];\n      params[p[1][1]] = p[2][1];\n    }\n\n    var ctx = node[2][1] ? node[2][1].text : null;\n\n    return dust.pragmas[name](context, ctx, bodies, params);\n  },\n\n  partial: function(context, node) {\n    return \".partial(\"\n      + dust.compileNode(context, node[1])\n      + \",\" + dust.compileNode(context, node[2]) + \")\";\n  },\n\n  context: function(context, node) {\n    if (node[1]) {\n      return \"ctx.rebase(\" + dust.compileNode(context, node[1]) + \")\";\n    }\n    return \"ctx\";\n  },\n\n  params: function(context, node) {\n    var out = [];\n    for (var i=1, len=node.length; i<len; i++) {\n      out.push(dust.compileNode(context, node[i]));\n    }\n    if (out.length) {\n      return \"{\" + out.join(',') + \"}\";\n    }\n    return \"null\";\n  },\n\n  bodies: function(context, node) {\n    var out = [];\n    for (var i=1, len=node.length; i<len; i++) {\n      out.push(dust.compileNode(context, node[i]));\n    }\n    return \"{\" + out.join(',') + \"}\";\n  },\n\n  param: function(context, node) {\n    return dust.compileNode(context, node[1]) + \":\" + dust.compileNode(context, node[2]);\n  },\n\n  filters: function(context, node) {\n    var list = [];\n    for (var i=1, len=node.length; i<len; i++) {\n      var filter = node[i];\n      list.push(\"\\\"\" + filter + \"\\\"\");\n    }\n    return \"\\\"\" + context.auto + \"\\\"\"\n      + (list.length ? \",[\" + list.join(',') + \"]\" : '');\n  },\n\n  key: function(context, node) {\n    return \"ctx.get(\\\"\" + node[1] + \"\\\")\";\n  },\n\n  path: function(context, node) {\n    var current = node[1],\n        keys = node[2],\n        list = [];\n\n    for (var i=0,len=keys.length; i<len; i++) {\n      list.push(\"\\\"\" + keys[i] + \"\\\"\");\n    }\n    return \"ctx.getPath(\" + current + \",[\" + list.join(',') + \"])\";\n  },\n\n  literal: function(context, node) {\n    return escape(node[1]);\n  }\n}\n\nfunction compileSection(context, node, cmd) {\n  return \".\" + cmd + \"(\"\n    + dust.compileNode(context, node[1])\n    + \",\" + dust.compileNode(context, node[2]) + \",\"\n    + dust.compileNode(context, node[4]) + \",\"\n    + dust.compileNode(context, node[3])\n    + \")\";\n}\n\nvar escape = (typeof JSON === \"undefined\")\n  ? function(str) { return \"\\\"\" + dust.escapeJs(str) + \"\\\"\" }\n  : JSON.stringify;\n\n})(typeof exports !== 'undefined' ? exports : window.dust);\n\n//@ sourceURL=/node_modules/dustjs-linkedin/lib/compiler.js"
));

require.define("vm", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = require(\"vm-browserify\")\n//@ sourceURL=vm"
));

require.define("/node_modules/vm-browserify/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/vm-browserify/package.json"
));

require.define("/node_modules/vm-browserify/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInNewContext = function (context) {\n    if (!context) context = {};\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n     \n    if (!win.eval && win.execScript) {\n        // win.eval() magically appears when this is called in IE:\n        win.execScript('null');\n    }\n    \n    var res = win.eval(this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        context[key] = win[key];\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInContext = function (context) {\n    // seems to be just runInNewContext on magical context objects which are\n    // otherwise indistinguishable from objects except plain old objects\n    // for the parameter segfaults node\n    return this.runInNewContext(context);\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    // not really sure what this one does\n    // seems to just make a shallow copy\n    var copy = {};\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n//@ sourceURL=/node_modules/vm-browserify/index.js"
));

require.define("/node_modules/fragment/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {}\n//@ sourceURL=/node_modules/fragment/package.json"
));

require.define("/node_modules/fragment/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = Fragment\n\nfunction Fragment(html) {\n    var div = document.createElement(\"div\"),\n        args = arguments,\n        i = 1,\n        fragment = document.createDocumentFragment()\n\n    div.innerHTML = html.replace(/%s/g, function(){\n        return String(args[i++])\n    })\n\n    while (div.hasChildNodes()) {\n        fragment.appendChild(div.firstChild)\n    }\n\n    return fragment\n}\n//@ sourceURL=/node_modules/fragment/index.js"
));

require.define("/shared/util/scraper.client.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var dnode = require(\"dnode\"),\n    pd = require(\"pd\"),\n    cached,\n    callbackList = []\n\nvar getRemote = pd.memoize(dnode.connect, dnode)\ngetRemote()\n\nmodule.exports = function (uri, callback) {\n    getRemote(function (remote) {\n        remote.proxyGetLinks(uri, callback)\n    })\n}\n\n\n//@ sourceURL=/shared/util/scraper.client.js"
));

require.define("/node_modules/dnode/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index.js\",\"browserify\":\"browser/index.js\"}\n//@ sourceURL=/node_modules/dnode/package.json"
));

require.define("/node_modules/dnode/browser/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var protocol = require('dnode-protocol');\nvar EventEmitter = require('events').EventEmitter;\nvar io = require('socket.io-client');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\nvar cached;\nvar callbackList;\n\nvar exports = module.exports = dnode;\n\nfunction dnode (wrapper) {\n    if (!(this instanceof dnode)) return new dnode(wrapper);\n    this.proto = protocol(wrapper);\n    this.stack = [];\n    return this;\n}\n\ndnode.prototype = new EventEmitter;\n\ndnode.prototype.use = function (middleware) {\n    this.stack.push(middleware);\n    return this;\n};\n\ndnode.prototype.connect = function () {\n    var self = this;\n    var params = protocol.parseArgs(arguments);\n    \n    if (cached) {\n        return params.block && \n            params.block.call(cached.instance, cached.client, cached);\n    } else if (callbackList) {\n        return callbackList.push(params.block)\n    }\n\n    callbackList = [params.block];\n    \n    var client = self.proto.create();\n\n    var proto = (params.proto || window.location.protocol)\n        .replace(/:.*/, '') + '://';\n    \n    var sock = client.socketio = io.connect(\n        proto + (params.host || window.location.host),\n        params\n    );\n    \n    client.end = function () {\n        sock.disconnect();\n    };\n    \n    sock.on('connect', function () {\n        client.start();\n        self.emit('connect');\n    });\n    \n    sock.on('disconnect', function () {\n        client.emit('end');\n        self.emit('end');\n    });\n    \n    sock.on('message', client.parse);\n    \n    client.on('request', function (req) {\n        sock.send(json.stringify(req) + '\\n');\n    });\n    \n    client.on('remote', function () {\n        cached = client;\n        var queue = callbackList;\n        callbackList = null;\n        for (var key in queue) {\n            var block = queue[key];\n            block.call(client.instance, client.remote, client);\n        }\n    });\n    \n    this.stack.forEach(function (middleware) {\n        middleware.call(client.instance, client.remote, client);\n    });\n};\n\nexports.connect = function () {\n    var d = exports();\n    return d.connect.apply(d, arguments);\n};\n\n//@ sourceURL=/node_modules/dnode/browser/index.js"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/package.json"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var traverse = require('traverse');\nvar EventEmitter = require('events').EventEmitter;\nvar stream = require('stream');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\n\nvar exports = module.exports = function (wrapper) {\n    var self = {};\n    \n    self.sessions = {};\n    \n    self.create = function () {\n        var id = null;\n        do {\n            id = Math.floor(\n                Math.random() * Math.pow(2,32)\n            ).toString(16);\n        } while (self.sessions[id]);\n        \n        var s = Session(id, wrapper);\n        self.sessions[id] = s;\n        return s;\n    };\n    \n    self.destroy = function (id) {\n        delete self.sessions[id];\n    };\n    \n    return self;\n};\n\nvar Session = exports.Session = function (id, wrapper) {\n    var self = new EventEmitter;\n    \n    self.id = id;\n    self.remote = {};\n    \n    var instance = self.instance =\n        typeof(wrapper) == 'function'\n            ? new wrapper(self.remote, self)\n            : wrapper || {}\n    ;\n    \n    self.localStore = new Store;\n    self.remoteStore = new Store;\n    \n    self.localStore.on('cull', function (id) {\n        self.emit('request', {\n            method : 'cull',\n            arguments : [id],\n            callbacks : {}\n        });\n    });\n    \n    var scrubber = new Scrubber(self.localStore);\n    \n    self.start = function () {\n        self.request('methods', [ instance ]);\n    };\n    \n    self.request = function (method, args) {\n        var scrub = scrubber.scrub(args);\n        \n        self.emit('request', {\n            method : method,\n            arguments : scrub.arguments,\n            callbacks : scrub.callbacks,\n            links : scrub.links\n        });\n    };\n    \n    self.parse = function (line) {\n        var msg = null;\n        try { msg = json.parse(line) }\n        catch (err) {\n            self.emit('error', new SyntaxError(\n                'Error parsing JSON message: ' + json.stringify(line))\n            );\n            return;\n        }\n        \n        try { self.handle(msg) }\n        catch (err) { self.emit('error', err) }\n    };\n    \n    self.handle = function (req) {\n        var args = scrubber.unscrub(req, function (id) {\n            if (!self.remoteStore.has(id)) {\n                // create a new function only if one hasn't already been created\n                // for a particular id\n                self.remoteStore.add(function () {\n                    self.request(id, [].slice.apply(arguments));\n                }, id);\n            }\n            return self.remoteStore.get(id);\n        });\n        \n        if (req.method === 'methods') {\n            handleMethods(args[0]);\n        }\n        else if (req.method === 'error') {\n            var methods = args[0];\n            self.emit('remoteError', methods);\n        }\n        else if (req.method === 'cull') {\n            args.forEach(function (id) {\n                self.remoteStore.cull(args);\n            });\n        }\n        else if (typeof req.method === 'string') {\n            if (self.instance.propertyIsEnumerable(req.method)) {\n                apply(self.instance[req.method], self.instance, args);\n            }\n            else {\n                self.emit('error', new Error(\n                    'Request for non-enumerable method: ' + req.method\n                ));\n            }\n        }\n        else if (typeof req.method == 'number') {\n            apply(self.localStore.get(req.method), self.instance, args);\n        }\n    }\n    \n    function handleMethods (methods) {\n        if (typeof methods != 'object') {\n            methods = {};\n        }\n        \n        // copy since assignment discards the previous refs\n        Object.keys(self.remote).forEach(function (key) {\n            delete self.remote[key];\n        });\n        \n        Object.keys(methods).forEach(function (key) {\n            self.remote[key] = methods[key];\n        });\n        \n        self.emit('remote', self.remote);\n        self.emit('ready');\n    }\n    \n    function apply(f, obj, args) {\n        try { f.apply(obj, args) }\n        catch (err) { self.emit('error', err) }\n    }\n    \n    return self;\n};\n\n// scrub callbacks out of requests in order to call them again later\nvar Scrubber = exports.Scrubber = function (store) {\n    var self = {};\n    store = store || new Store;\n    self.callbacks = store.items;\n    \n    // Take the functions out and note them for future use\n    self.scrub = function (obj) {\n        var paths = {};\n        var links = [];\n        \n        var args = traverse(obj).map(function (node) {\n            if (typeof(node) == 'function') {\n                var i = store.indexOf(node);\n                if (i >= 0 && !(i in paths)) {\n                    // Keep previous function IDs only for the first function\n                    // found. This is somewhat suboptimal but the alternatives\n                    // are worse.\n                    paths[i] = this.path;\n                }\n                else {\n                    var id = store.add(node);\n                    paths[id] = this.path;\n                }\n                \n                this.update('[Function]');\n            }\n            else if (this.circular) {\n                links.push({ from : this.circular.path, to : this.path });\n                this.update('[Circular]');\n            }\n        });\n        \n        return {\n            arguments : args,\n            callbacks : paths,\n            links : links\n        };\n    };\n    \n    // Replace callbacks. The supplied function should take a callback id and\n    // return a callback of its own.\n    self.unscrub = function (msg, f) {\n        var args = msg.arguments || [];\n        Object.keys(msg.callbacks || {}).forEach(function (strId) {\n            var id = parseInt(strId,10);\n            var path = msg.callbacks[id];\n            args = setAt(args, path, f(id));\n        });\n        \n        (msg.links || []).forEach(function (link) {\n            var value = getAt(args, link.from);\n            args = setAt(args, link.to, value);\n        });\n        \n        return args;\n    };\n    \n    function setAt (ref, path, value) {\n        var node = ref;\n        for (var i = 0; i < path.length - 1; i++) {\n            var key = path[i];\n            if (Object.propertyIsEnumerable.call(node, key)) {\n                node = node[key];\n            }\n            else return undefined;\n        };\n        var last = path.slice(-1)[0];\n        if (last === undefined) {\n            return value;\n        }\n        else {\n            node[last] = value;\n            return ref;\n        }\n    }\n    \n    function getAt (node, path) {\n        for (var i = 0; i < path.length; i++) {\n            var key = path[i];\n            if (Object.propertyIsEnumerable.call(node, key)) {\n                node = node[key];\n            }\n            else return undefined;\n        }\n        return node;\n    }\n    \n    return self;\n}\n\nvar Store = exports.Store = function() {\n    var self = new EventEmitter;\n    var items = self.items = [];\n    \n    self.has = function (id) {\n        return items[id] != undefined;\n    };\n    \n    self.get = function (id) {\n        if (!self.has(id)) return null;\n        return wrap(items[id]);\n    };\n    \n    self.add = function (fn, id) {\n        if (id == undefined) id = items.length;\n        items[id] = fn;\n        return id;\n    };\n    \n    self.cull = function (arg) {\n        if (typeof arg == 'function') {\n            arg = items.indexOf(arg);\n        }\n        delete items[arg];\n        return arg;\n    };\n    \n    self.indexOf = function (fn) {\n        return items.indexOf(fn);\n    };\n    \n    function wrap (fn) {\n        return function() {\n            fn.apply(this, arguments);\n            autoCull(fn);\n        };\n    }\n    \n    function autoCull (fn) {\n        if (typeof fn.times == 'number') {\n            fn.times--;\n            if (fn.times == 0) {\n                var id = self.cull(fn);\n                self.emit('cull', id);\n            }\n        }\n    }\n    \n    return self;\n};\n\nvar parseArgs = exports.parseArgs = function (argv) {\n    var params = {};\n    \n    [].slice.call(argv).forEach(function (arg) {\n        if (typeof arg === 'string') {\n            if (arg.match(/^\\d+$/)) {\n                params.port = parseInt(arg, 10);\n            }\n            else if (arg.match('^/')) {\n                params.path = arg;\n            }\n            else {\n                params.host = arg;\n            }\n        }\n        else if (typeof arg === 'number') {\n            params.port = arg;\n        }\n        else if (typeof arg === 'function') {\n            params.block = arg;\n        }\n        else if (typeof arg === 'object') {\n            if (arg.__proto__ === Object.prototype) {\n                // merge vanilla objects into params\n                Object.keys(arg).forEach(function (key) {\n                    params[key] = key === 'port'\n                        ? parseInt(arg[key], 10)\n                        : arg[key]\n                    ;\n                });\n            }\n            else if (stream.Stream && arg instanceof stream.Stream) {\n                params.stream = arg;\n            }\n            else {\n                // and non-Stream, non-vanilla objects are probably servers\n                params.server = arg;\n            }\n        }\n        else if (typeof arg === 'undefined') {\n            // ignore\n        }\n        else {\n            throw new Error('Not sure what to do about '\n                + typeof arg + ' objects');\n        }\n    });\n    \n    return params;\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/index.js"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index\"}\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/package.json"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(Object_keys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (Array_isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        if (typeof node === 'object' && node !== null) {\n            state.keys = Object_keys(node);\n            \n            state.isLeaf = state.keys.length == 0;\n            \n            for (var i = 0; i < parents.length; i++) {\n                if (parents[i].node_ === node_) {\n                    state.circular = parents[i];\n                    break;\n                }\n            }\n        }\n        else {\n            state.isLeaf = true;\n        }\n        \n        state.notLeaf = !state.isLeaf;\n        state.notRoot = !state.isRoot;\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && Object.hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (Array_isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.__proto__ || src.constructor.prototype) {\n            var proto = src.__proto__ || src.constructor.prototype || {};\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n            if (!dst.__proto__) dst.__proto__ = proto;\n        }\n        \n        forEach(Object_keys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar Object_keys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar Array_isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(Object_keys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/index.js"
));

require.define("events", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("stream", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("util", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/dnode/node_modules/jsonify/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/package.json"
));

require.define("/node_modules/dnode/node_modules/jsonify/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/index.js"
));

require.define("/node_modules/dnode/node_modules/jsonify/lib/parse.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/lib/parse.js"
));

require.define("/node_modules/dnode/node_modules/jsonify/lib/stringify.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/lib/stringify.js"
));

require.define("/node_modules/dnode/node_modules/socket.io-client/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/io.js\",\"browserify\":\"./dist/browserify.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/socket.io-client/package.json"
));

require.define("/node_modules/dnode/node_modules/socket.io-client/dist/browserify.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function () {var io = module.exports;/*! Socket.IO.js build:0.8.6, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * IO namespace.\n   *\n   * @namespace\n   */\n\n  var io = exports;\n\n  /**\n   * Socket.IO version\n   *\n   * @api public\n   */\n\n  io.version = '0.8.6';\n\n  /**\n   * Protocol implemented.\n   *\n   * @api public\n   */\n\n  io.protocol = 1;\n\n  /**\n   * Available transports, these will be populated with the available transports\n   *\n   * @api public\n   */\n\n  io.transports = [];\n\n  /**\n   * Keep track of jsonp callbacks.\n   *\n   * @api private\n   */\n\n  io.j = [];\n\n  /**\n   * Keep track of our io.Sockets\n   *\n   * @api private\n   */\n  io.sockets = {};\n\n\n  /**\n   * Manages connections to hosts.\n   *\n   * @param {String} uri\n   * @Param {Boolean} force creation of new socket (defaults to false)\n   * @api public\n   */\n\n  io.connect = function (host, details) {\n    var uri = io.util.parseUri(host)\n      , uuri\n      , socket;\n\n    if (global && global.location) {\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n      uri.host = uri.host || (global.document\n        ? global.document.domain : global.location.hostname);\n      uri.port = uri.port || global.location.port;\n    }\n\n    uuri = io.util.uniqueUri(uri);\n\n    var options = {\n        host: uri.host\n      , secure: 'https' == uri.protocol\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n      , query: uri.query || ''\n    };\n\n    io.util.merge(options, details);\n\n    if (options['force new connection'] || !io.sockets[uuri]) {\n      socket = new io.Socket(options);\n    }\n\n    if (!options['force new connection'] && socket) {\n      io.sockets[uuri] = socket;\n    }\n\n    socket = socket || io.sockets[uuri];\n\n    // if path is different from '' or /\n    return socket.of(uri.path.length > 1 ? uri.path : '');\n  };\n\n})('object' === typeof module ? module.exports : (this.io = {}), this);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * Utilities namespace.\n   *\n   * @namespace\n   */\n\n  var util = exports.util = {};\n\n  /**\n   * Parses an URI\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api public\n   */\n\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n               'anchor'];\n\n  util.parseUri = function (str) {\n    var m = re.exec(str || '')\n      , uri = {}\n      , i = 14;\n\n    while (i--) {\n      uri[parts[i]] = m[i] || '';\n    }\n\n    return uri;\n  };\n\n  /**\n   * Produces a unique url that identifies a Socket.IO connection.\n   *\n   * @param {Object} uri\n   * @api public\n   */\n\n  util.uniqueUri = function (uri) {\n    var protocol = uri.protocol\n      , host = uri.host\n      , port = uri.port;\n\n    if ('document' in global) {\n      host = host || document.domain;\n      port = port || (protocol == 'https'\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n    } else {\n      host = host || 'localhost';\n\n      if (!port && protocol == 'https') {\n        port = 443;\n      }\n    }\n\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n  };\n\n  /**\n   * Mergest 2 query strings in to once unique query string\n   *\n   * @param {String} base\n   * @param {String} addition\n   * @api public\n   */\n\n  util.query = function (base, addition) {\n    var query = util.chunkQuery(base || '')\n      , components = [];\n\n    util.merge(query, util.chunkQuery(addition || ''));\n    for (var part in query) {\n      if (query.hasOwnProperty(part)) {\n        components.push(part + '=' + query[part]);\n      }\n    }\n\n    return components.length ? '?' + components.join('&') : '';\n  };\n\n  /**\n   * Transforms a querystring in to an object\n   *\n   * @param {String} qs\n   * @api public\n   */\n\n  util.chunkQuery = function (qs) {\n    var query = {}\n      , params = qs.split('&')\n      , i = 0\n      , l = params.length\n      , kv;\n\n    for (; i < l; ++i) {\n      kv = params[i].split('=');\n      if (kv[0]) {\n        query[kv[0]] = decodeURIComponent(kv[1]);\n      }\n    }\n\n    return query;\n  };\n\n  /**\n   * Executes the given function when the page is loaded.\n   *\n   *     io.util.load(function () { console.log('page loaded'); });\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  var pageLoaded = false;\n\n  util.load = function (fn) {\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n      return fn();\n    }\n\n    util.on(global, 'load', fn, false);\n  };\n\n  /**\n   * Adds an event.\n   *\n   * @api private\n   */\n\n  util.on = function (element, event, fn, capture) {\n    if (element.attachEvent) {\n      element.attachEvent('on' + event, fn);\n    } else if (element.addEventListener) {\n      element.addEventListener(event, fn, capture);\n    }\n  };\n\n  /**\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n   *\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n   * @api private\n   */\n\n  util.request = function (xdomain) {\n\n    if (xdomain && 'undefined' != typeof XDomainRequest) {\n      return new XDomainRequest();\n    }\n\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n      return new XMLHttpRequest();\n    }\n\n    if (!xdomain) {\n      try {\n        return new ActiveXObject('Microsoft.XMLHTTP');\n      } catch(e) { }\n    }\n\n    return null;\n  };\n\n  /**\n   * XHR based transport constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  /**\n   * Change the internal pageLoaded value.\n   */\n\n  if ('undefined' != typeof window) {\n    util.load(function () {\n      pageLoaded = true;\n    });\n  }\n\n  /**\n   * Defers a function to ensure a spinner is not displayed by the browser\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  util.defer = function (fn) {\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n      return fn();\n    }\n\n    util.load(function () {\n      setTimeout(fn, 100);\n    });\n  };\n\n  /**\n   * Merges two objects.\n   *\n   * @api public\n   */\n  \n  util.merge = function merge (target, additional, deep, lastseen) {\n    var seen = lastseen || []\n      , depth = typeof deep == 'undefined' ? 2 : deep\n      , prop;\n\n    for (prop in additional) {\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n        if (typeof target[prop] !== 'object' || !depth) {\n          target[prop] = additional[prop];\n          seen.push(additional[prop]);\n        } else {\n          util.merge(target[prop], additional[prop], depth - 1, seen);\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Merges prototypes from objects\n   *\n   * @api public\n   */\n  \n  util.mixin = function (ctor, ctor2) {\n    util.merge(ctor.prototype, ctor2.prototype);\n  };\n\n  /**\n   * Shortcut for prototypical and static inheritance.\n   *\n   * @api private\n   */\n\n  util.inherit = function (ctor, ctor2) {\n    function f() {};\n    f.prototype = ctor2.prototype;\n    ctor.prototype = new f;\n  };\n\n  /**\n   * Checks if the given object is an Array.\n   *\n   *     io.util.isArray([]); // true\n   *     io.util.isArray({}); // false\n   *\n   * @param Object obj\n   * @api public\n   */\n\n  util.isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  /**\n   * Intersects values of two arrays into a third\n   *\n   * @api public\n   */\n\n  util.intersect = function (arr, arr2) {\n    var ret = []\n      , longest = arr.length > arr2.length ? arr : arr2\n      , shortest = arr.length > arr2.length ? arr2 : arr;\n\n    for (var i = 0, l = shortest.length; i < l; i++) {\n      if (~util.indexOf(longest, shortest[i]))\n        ret.push(shortest[i]);\n    }\n\n    return ret;\n  }\n\n  /**\n   * Array indexOf compatibility.\n   *\n   * @see bit.ly/a5Dxa2\n   * @api public\n   */\n\n  util.indexOf = function (arr, o, i) {\n    if (Array.prototype.indexOf) {\n      return Array.prototype.indexOf.call(arr, o, i);\n    }\n\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; \n         i < j && arr[i] !== o; i++) {}\n\n    return j <= i ? -1 : i;\n  };\n\n  /**\n   * Converts enumerables to array.\n   *\n   * @api public\n   */\n\n  util.toArray = function (enu) {\n    var arr = [];\n\n    for (var i = 0, l = enu.length; i < l; i++)\n      arr.push(enu[i]);\n\n    return arr;\n  };\n\n  /**\n   * UA / engines detection namespace.\n   *\n   * @namespace\n   */\n\n  util.ua = {};\n\n  /**\n   * Whether the UA supports CORS for XHR.\n   *\n   * @api public\n   */\n\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n    try {\n      var a = new XMLHttpRequest();\n    } catch (e) {\n      return false;\n    }\n\n    return a.withCredentials != undefined;\n  })();\n\n  /**\n   * Detect webkit.\n   *\n   * @api public\n   */\n\n  util.ua.webkit = 'undefined' != typeof navigator\n    && /webkit/i.test(navigator.userAgent);\n\n})('undefined' != typeof io ? io : module.exports, this);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.EventEmitter = EventEmitter;\n\n  /**\n   * Event emitter constructor.\n   *\n   * @api public.\n   */\n\n  function EventEmitter () {};\n\n  /**\n   * Adds a listener\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.on = function (name, fn) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = fn;\n    } else if (io.util.isArray(this.$events[name])) {\n      this.$events[name].push(fn);\n    } else {\n      this.$events[name] = [this.$events[name], fn];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  /**\n   * Adds a volatile listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.once = function (name, fn) {\n    var self = this;\n\n    function on () {\n      self.removeListener(name, on);\n      fn.apply(this, arguments);\n    };\n\n    on.listener = fn;\n    this.on(name, on);\n\n    return this;\n  };\n\n  /**\n   * Removes a listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeListener = function (name, fn) {\n    if (this.$events && this.$events[name]) {\n      var list = this.$events[name];\n\n      if (io.util.isArray(list)) {\n        var pos = -1;\n\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n            pos = i;\n            break;\n          }\n        }\n\n        if (pos < 0) {\n          return this;\n        }\n\n        list.splice(pos, 1);\n\n        if (!list.length) {\n          delete this.$events[name];\n        }\n      } else if (list === fn || (list.listener && list.listener === fn)) {\n        delete this.$events[name];\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Removes all listeners for an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeAllListeners = function (name) {\n    // TODO: enable this when node 0.5 is stable\n    //if (name === undefined) {\n      //this.$events = {};\n      //return this;\n    //}\n\n    if (this.$events && this.$events[name]) {\n      this.$events[name] = null;\n    }\n\n    return this;\n  };\n\n  /**\n   * Gets all listeners for a certain event.\n   *\n   * @api publci\n   */\n\n  EventEmitter.prototype.listeners = function (name) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = [];\n    }\n\n    if (!io.util.isArray(this.$events[name])) {\n      this.$events[name] = [this.$events[name]];\n    }\n\n    return this.$events[name];\n  };\n\n  /**\n   * Emits an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.emit = function (name) {\n    if (!this.$events) {\n      return false;\n    }\n\n    var handler = this.$events[name];\n\n    if (!handler) {\n      return false;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if ('function' == typeof handler) {\n      handler.apply(this, args);\n    } else if (io.util.isArray(handler)) {\n      var listeners = handler.slice();\n\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].apply(this, args);\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n\n(function (exports, nativeJSON) {\n  \"use strict\";\n\n  // use native JSON if it's available\n  if (nativeJSON && nativeJSON.parse){\n    return exports.JSON = {\n      parse: nativeJSON.parse\n    , stringify: nativeJSON.stringify\n    }\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n      // Format integers to have at least two digits.\n      return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ?\n        d.getUTCFullYear()     + '-' +\n        f(d.getUTCMonth() + 1) + '-' +\n        f(d.getUTCDate())      + 'T' +\n        f(d.getUTCHours())     + ':' +\n        f(d.getUTCMinutes())   + ':' +\n        f(d.getUTCSeconds())   + 'Z' : null;\n  };\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {    // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"' : '\\\\\"',\n          '\\\\': '\\\\\\\\'\n      },\n      rep;\n\n\n  function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n      escapable.lastIndex = 0;\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n          var c = meta[a];\n          return typeof c === 'string' ? c :\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + string + '\"';\n  }\n\n\n  function str(key, holder) {\n\n// Produce a string from holder[key].\n\n      var i,          // The loop counter.\n          k,          // The member key.\n          v,          // The member value.\n          length,\n          mind = gap,\n          partial,\n          value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n      if (value instanceof Date) {\n          value = date(key);\n      }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n      if (typeof rep === 'function') {\n          value = rep.call(holder, key, value);\n      }\n\n// What happens next depends on the value's type.\n\n      switch (typeof value) {\n      case 'string':\n          return quote(value);\n\n      case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n          return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n          return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n      case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n          if (!value) {\n              return 'null';\n          }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n          gap += indent;\n          partial = [];\n\n// Is the value an array?\n\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n              length = value.length;\n              for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n              }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n              v = partial.length === 0 ? '[]' : gap ?\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                  '[' + partial.join(',') + ']';\n              gap = mind;\n              return v;\n          }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n          if (rep && typeof rep === 'object') {\n              length = rep.length;\n              for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                      k = rep[i];\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n          v = partial.length === 0 ? '{}' : gap ?\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n              '{' + partial.join(',') + '}';\n          gap = mind;\n          return v;\n      }\n  }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n  JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n      var i;\n      gap = '';\n      indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n      if (typeof space === 'number') {\n          for (i = 0; i < space; i += 1) {\n              indent += ' ';\n          }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n      } else if (typeof space === 'string') {\n          indent = space;\n      }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n      rep = replacer;\n      if (replacer && typeof replacer !== 'function' &&\n              (typeof replacer !== 'object' ||\n              typeof replacer.length !== 'number')) {\n          throw new Error('JSON.stringify');\n      }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n      return str('', {'': value});\n  };\n\n// If the JSON object does not yet have a parse method, give it one.\n\n  JSON.parse = function (text, reviver) {\n  // The parse method takes a text and an optional reviver function, and returns\n  // a JavaScript value if the text is a valid JSON text.\n\n      var j;\n\n      function walk(holder, key) {\n\n  // The walk method is used to recursively walk the resulting structure so\n  // that modifications can be made.\n\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n  // In the third stage we use the eval function to compile the text into a\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\n  // in parens to eliminate the ambiguity.\n\n          j = eval('(' + text + ')');\n\n  // In the optional fourth stage, we recursively walk the new structure, passing\n  // each name/value pair to a reviver function for possible transformation.\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n      throw new SyntaxError('JSON.parse');\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , typeof JSON !== 'undefined' ? JSON : undefined\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Parser namespace.\n   *\n   * @namespace\n   */\n\n  var parser = exports.parser = {};\n\n  /**\n   * Packet types.\n   */\n\n  var packets = parser.packets = [\n      'disconnect'\n    , 'connect'\n    , 'heartbeat'\n    , 'message'\n    , 'json'\n    , 'event'\n    , 'ack'\n    , 'error'\n    , 'noop'\n  ];\n\n  /**\n   * Errors reasons.\n   */\n\n  var reasons = parser.reasons = [\n      'transport not supported'\n    , 'client not handshaken'\n    , 'unauthorized'\n  ];\n\n  /**\n   * Errors advice.\n   */\n\n  var advice = parser.advice = [\n      'reconnect'\n  ];\n\n  /**\n   * Shortcuts.\n   */\n\n  var JSON = io.JSON\n    , indexOf = io.util.indexOf;\n\n  /**\n   * Encodes a packet.\n   *\n   * @api private\n   */\n\n  parser.encodePacket = function (packet) {\n    var type = indexOf(packets, packet.type)\n      , id = packet.id || ''\n      , endpoint = packet.endpoint || ''\n      , ack = packet.ack\n      , data = null;\n\n    switch (packet.type) {\n      case 'error':\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\n        if (reason !== '' || adv !== '')\n          data = reason + (adv !== '' ? ('+' + adv) : '');\n\n        break;\n\n      case 'message':\n        if (packet.data !== '')\n          data = packet.data;\n        break;\n\n      case 'event':\n        var ev = { name: packet.name };\n\n        if (packet.args && packet.args.length) {\n          ev.args = packet.args;\n        }\n\n        data = JSON.stringify(ev);\n        break;\n\n      case 'json':\n        data = JSON.stringify(packet.data);\n        break;\n\n      case 'connect':\n        if (packet.qs)\n          data = packet.qs;\n        break;\n\n      case 'ack':\n        data = packet.ackId\n          + (packet.args && packet.args.length\n              ? '+' + JSON.stringify(packet.args) : '');\n        break;\n    }\n\n    // construct packet with required fragments\n    var encoded = [\n        type\n      , id + (ack == 'data' ? '+' : '')\n      , endpoint\n    ];\n\n    // data fragment is optional\n    if (data !== null && data !== undefined)\n      encoded.push(data);\n\n    return encoded.join(':');\n  };\n\n  /**\n   * Encodes multiple messages (payload).\n   *\n   * @param {Array} messages\n   * @api private\n   */\n\n  parser.encodePayload = function (packets) {\n    var decoded = '';\n\n    if (packets.length == 1)\n      return packets[0];\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      var packet = packets[i];\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n    }\n\n    return decoded;\n  };\n\n  /**\n   * Decodes a packet\n   *\n   * @api private\n   */\n\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\n  parser.decodePacket = function (data) {\n    var pieces = data.match(regexp);\n\n    if (!pieces) return {};\n\n    var id = pieces[2] || ''\n      , data = pieces[5] || ''\n      , packet = {\n            type: packets[pieces[1]]\n          , endpoint: pieces[4] || ''\n        };\n\n    // whether we need to acknowledge the packet\n    if (id) {\n      packet.id = id;\n      if (pieces[3])\n        packet.ack = 'data';\n      else\n        packet.ack = true;\n    }\n\n    // handle different packet types\n    switch (packet.type) {\n      case 'error':\n        var pieces = data.split('+');\n        packet.reason = reasons[pieces[0]] || '';\n        packet.advice = advice[pieces[1]] || '';\n        break;\n\n      case 'message':\n        packet.data = data || '';\n        break;\n\n      case 'event':\n        try {\n          var opts = JSON.parse(data);\n          packet.name = opts.name;\n          packet.args = opts.args;\n        } catch (e) { }\n\n        packet.args = packet.args || [];\n        break;\n\n      case 'json':\n        try {\n          packet.data = JSON.parse(data);\n        } catch (e) { }\n        break;\n\n      case 'connect':\n        packet.qs = data || '';\n        break;\n\n      case 'ack':\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n        if (pieces) {\n          packet.ackId = pieces[1];\n          packet.args = [];\n\n          if (pieces[3]) {\n            try {\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n            } catch (e) { }\n          }\n        }\n        break;\n\n      case 'disconnect':\n      case 'heartbeat':\n        break;\n    };\n\n    return packet;\n  };\n\n  /**\n   * Decodes data payload. Detects multiple messages\n   *\n   * @return {Array} messages\n   * @api public\n   */\n\n  parser.decodePayload = function (data) {\n    // IE doesn't like data[i] for unicode chars, charAt works fine\n    if (data.charAt(0) == '\\ufffd') {\n      var ret = [];\n\n      for (var i = 1, length = ''; i < data.length; i++) {\n        if (data.charAt(i) == '\\ufffd') {\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n          i += Number(length) + 1;\n          length = '';\n        } else {\n          length += data.charAt(i);\n        }\n      }\n\n      return ret;\n    } else {\n      return [parser.decodePacket(data)];\n    }\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Transport = Transport;\n\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport (socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout();\n    \n    // If the connection in currently open (or in a reopening state) reset the close \n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n    if (this.connected || this.connecting || this.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onPacket = function (packet) {\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    this.socket.onPacket(packet);\n\n    return this;\n  };\n\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n  \n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.close && this.open) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  }\n\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({ type: 'heartbeat' });\n  };\n \n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onOpen = function () {\n    this.open = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.open = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n\n    return this.scheme() + '://'\n      + options.host + ':' + options.port + '/'\n      + options.resource + '/' + io.protocol\n      + '/' + this.name + '/' + this.sessid;\n  };\n\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Socket = Socket;\n\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket (options) {\n    this.options = {\n        port: 80\n      , secure: false\n      , document: 'document' in global ? document : false\n      , resource: 'socket.io'\n      , transports: io.transports\n      , 'connect timeout': 10000\n      , 'try multiple transports': true\n      , 'reconnect': true\n      , 'reconnection delay': 500\n      , 'reconnection limit': Infinity\n      , 'reopen delay': 3000\n      , 'max reconnection attempts': 10\n      , 'sync disconnect on unload': true\n      , 'auto connect': true\n      , 'flash policy port': 10843\n    };\n\n    io.util.merge(this.options, options);\n\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] &&\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n};\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({ type: 'connect' });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n  function empty () { };\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this\n      , options = this.options;\n\n    function complete (data) {\n      if (data instanceof Error) {\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    };\n\n    var url = [\n          'http' + (options.secure ? 's' : '') + ':/'\n        , options.host + ':' + options.port\n        , options.resource\n        , io.protocol\n        , io.util.query(this.options.query, 't=' + +new Date)\n      ].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0]\n        , script = document.createElement('script');\n\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n\n      xhr.open('GET', url, true);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else {\n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n      xhr.send(null);\n    }\n  };\n\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports, match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport]\n        && io.Transport[transport].check(this)\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck())) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n\n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      self.transports = io.util.intersect(\n          transports.split(',')\n        , self.options.transports\n      );\n\n      function connect (transports){\n        if (self.transport) self.transport.clearTimeouts();\n\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed');\n\n        // once the transport is ready\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  if (!self.remainingTransports) {\n                    self.remainingTransports = self.transports.slice(0);\n                  }\n\n                  var remaining = self.remainingTransports;\n\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n                         self.transport.name) {}\n\n                    if (remaining.length){\n                      connect(remaining);\n                    } else {\n                      self.publish('connect_failed');\n                    }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect();\n\n      self.once('connect', function (){\n        clearTimeout(self.connectTimeoutTimer);\n\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n\n    return this;\n  };\n\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      this.transport.payload(this.buffer);\n      this.buffer = [];\n    }\n  };\n\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected) {\n      if (this.open) {\n        this.of('').packet({ type: 'disconnect' });\n      }\n\n      // handle disconnection immediately\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request()\n      , uri = this.resource + '/' + io.protocol + '/' + this.sessionid;\n\n    xhr.open('GET', uri, true);\n\n    // handle disconnection immediately\n    this.onDisconnect('booted');\n  };\n\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n  Socket.prototype.isXDomain = function () {\n\n    var port = global.location.port ||\n      ('https:' == global.location.protocol ? 443 : 80);\n\n    return this.options.host !== global.location.hostname \n      || this.options.port != port;\n  };\n\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n      this.emit('connect');\n    }\n  };\n\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n  };\n\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && this.connected) {\n        this.disconnect();\n        this.reconnect();\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected;\n\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n      this.publish('disconnect', reason);\n\n      if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n        this.reconnect();\n      }\n    }\n  };\n\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n\n    var self = this\n      , maxAttempts = this.options['max reconnection attempts']\n      , tryMultiple = this.options['try multiple transports']\n      , limit = this.options['reconnection limit'];\n\n    function reset () {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n              self.namespaces[i].packet({ type: 'connect' });\n          }\n        }\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n\n      self.reconnecting = false;\n\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n\n      self.options['try multiple transports'] = tryMultiple;\n    };\n\n    function maybeReconnect () {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      };\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    };\n\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\n    this.on('connect', maybeReconnect);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.SocketNamespace = SocketNamespace;\n\n  /**\n   * Socket namespace constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function SocketNamespace (socket, name) {\n    this.socket = socket;\n    this.name = name || '';\n    this.flags = {};\n    this.json = new Flag(this, 'json');\n    this.ackPackets = 0;\n    this.acks = {};\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(SocketNamespace, io.EventEmitter);\n\n  /**\n   * Copies emit since we override it\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\n  /**\n   * Creates a new namespace, by proxying the request to the socket. This\n   * allows us to use the synax as we do on the server.\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.of = function () {\n    return this.socket.of.apply(this.socket, arguments);\n  };\n\n  /**\n   * Sends a packet.\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.packet = function (packet) {\n    packet.endpoint = this.name;\n    this.socket.packet(packet);\n    this.flags = {};\n    return this;\n  };\n\n  /**\n   * Sends a message\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.send = function (data, fn) {\n    var packet = {\n        type: this.flags.json ? 'json' : 'message'\n      , data: data\n    };\n\n    if ('function' == typeof fn) {\n      packet.id = ++this.ackPackets;\n      packet.ack = true;\n      this.acks[packet.id] = fn;\n    }\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Emits an event\n   *\n   * @api public\n   */\n  \n  SocketNamespace.prototype.emit = function (name) {\n    var args = Array.prototype.slice.call(arguments, 1)\n      , lastArg = args[args.length - 1]\n      , packet = {\n            type: 'event'\n          , name: name\n        };\n\n    if ('function' == typeof lastArg) {\n      packet.id = ++this.ackPackets;\n      packet.ack = 'data';\n      this.acks[packet.id] = lastArg;\n      args = args.slice(0, args.length - 1);\n    }\n\n    packet.args = args;\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Disconnects the namespace\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.disconnect = function () {\n    if (this.name === '') {\n      this.socket.disconnect();\n    } else {\n      this.packet({ type: 'disconnect' });\n      this.$emit('disconnect');\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles a packet\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.onPacket = function (packet) {\n    var self = this;\n\n    function ack () {\n      self.packet({\n          type: 'ack'\n        , args: io.util.toArray(arguments)\n        , ackId: packet.id\n      });\n    };\n\n    switch (packet.type) {\n      case 'connect':\n        this.$emit('connect');\n        break;\n\n      case 'disconnect':\n        if (this.name === '') {\n          this.socket.onDisconnect(packet.reason || 'booted');\n        } else {\n          this.$emit('disconnect', packet.reason);\n        }\n        break;\n\n      case 'message':\n      case 'json':\n        var params = ['message', packet.data];\n\n        if (packet.ack == 'data') {\n          params.push(ack);\n        } else if (packet.ack) {\n          this.packet({ type: 'ack', ackId: packet.id });\n        }\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'event':\n        var params = [packet.name].concat(packet.args);\n\n        if (packet.ack == 'data')\n          params.push(ack);\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'ack':\n        if (this.acks[packet.ackId]) {\n          this.acks[packet.ackId].apply(this, packet.args);\n          delete this.acks[packet.ackId];\n        }\n        break;\n\n      case 'error':\n        if (packet.advice){\n          this.socket.onError(packet);\n        } else {\n          if (packet.reason == 'unauthorized') {\n            this.$emit('connect_failed', packet.reason);\n          } else {\n            this.$emit('error', packet.reason);\n          }\n        }\n        break;\n    }\n  };\n\n  /**\n   * Flag interface.\n   *\n   * @api private\n   */\n\n  function Flag (nsp, name) {\n    this.namespace = nsp;\n    this.name = name;\n  };\n\n  /**\n   * Send a message\n   *\n   * @api public\n   */\n\n  Flag.prototype.send = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.send.apply(this.namespace, arguments);\n  };\n\n  /**\n   * Emit an event\n   *\n   * @api public\n   */\n\n  Flag.prototype.emit = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.emit.apply(this.namespace, arguments);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.websocket = WS;\n\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS (socket) {\n    io.Transport.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query)\n      , self = this\n      , Socket\n\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.send = function (data) {\n    this.websocket.send(data);\n    return this;\n  };\n\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n    return this;\n  };\n\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  WS.check = function () {\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\n          || 'MozWebSocket' in global;\n  };\n\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('websocket');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.flashsocket = Flashsocket;\n\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket () {\n    io.Transport.websocket.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this\n      , args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n    return this;\n  };\n  \n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.send = function () {\n    var self = this, args = arguments;\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n    return this;\n  };\n\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init () {\n      var options = socket.options\n        , port = options['flash policy port']\n        , path = [\n              'http' + (options.secure ? 's' : '') + ':/'\n            , options.host + ':' + options.port\n            , options.resource\n            , 'static/flashsocket'\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n          ];\n\n      // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n\n    io.util.load(init);\n  };\n\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.check = function () {\n    if (\n        typeof WebSocket == 'undefined'\n      || !('__initialize' in WebSocket) || !swfobject\n    ) return false;\n\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('flashsocket');\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n*/\nif ('undefined' != typeof window) {\nvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?\"ActiveX\":\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n}\n// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n// License: New BSD License\n// Reference: http://dev.w3.org/html5/websockets/\n// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\n(function() {\n  \n  if ('undefined' == typeof window || window.WebSocket) return;\n\n  var console = window.console;\n  if (!console || !console.log || !console.error) {\n    console = {log: function(){ }, error: function(){ }};\n  }\n  \n  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n    console.error(\"Flash Player >= 10.0.0 is required.\");\n    return;\n  }\n  if (location.protocol == \"file:\") {\n    console.error(\n      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n      \"unless you set Flash Security Settings properly. \" +\n      \"Open the page via Web server i.e. http://...\");\n  }\n\n  /**\n   * This class represents a faux web socket.\n   * @param {string} url\n   * @param {array or string} protocols\n   * @param {string} proxyHost\n   * @param {int} proxyPort\n   * @param {string} headers\n   */\n  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n    var self = this;\n    self.__id = WebSocket.__nextId++;\n    WebSocket.__instances[self.__id] = self;\n    self.readyState = WebSocket.CONNECTING;\n    self.bufferedAmount = 0;\n    self.__events = {};\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols == \"string\") {\n      protocols = [protocols];\n    }\n    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n    setTimeout(function() {\n      WebSocket.__addTask(function() {\n        WebSocket.__flash.create(\n            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n      });\n    }, 0);\n  };\n\n  /**\n   * Send data to the web socket.\n   * @param {string} data  The data to send to the socket.\n   * @return {boolean}  True for success, false for failure.\n   */\n  WebSocket.prototype.send = function(data) {\n    if (this.readyState == WebSocket.CONNECTING) {\n      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n    }\n    // We use encodeURIComponent() here, because FABridge doesn't work if\n    // the argument includes some characters. We don't use escape() here\n    // because of this:\n    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n    // additional testing.\n    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n    if (result < 0) { // success\n      return true;\n    } else {\n      this.bufferedAmount += result;\n      return false;\n    }\n  };\n\n  /**\n   * Close this web socket gracefully.\n   */\n  WebSocket.prototype.close = function() {\n    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n      return;\n    }\n    this.readyState = WebSocket.CLOSING;\n    WebSocket.__flash.close(this.__id);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) {\n      this.__events[type] = [];\n    }\n    this.__events[type].push(listener);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) return;\n    var events = this.__events[type];\n    for (var i = events.length - 1; i >= 0; --i) {\n      if (events[i] === listener) {\n        events.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {Event} event\n   * @return void\n   */\n  WebSocket.prototype.dispatchEvent = function(event) {\n    var events = this.__events[event.type] || [];\n    for (var i = 0; i < events.length; ++i) {\n      events[i](event);\n    }\n    var handler = this[\"on\" + event.type];\n    if (handler) handler(event);\n  };\n\n  /**\n   * Handles an event from Flash.\n   * @param {Object} flashEvent\n   */\n  WebSocket.prototype.__handleEvent = function(flashEvent) {\n    if (\"readyState\" in flashEvent) {\n      this.readyState = flashEvent.readyState;\n    }\n    if (\"protocol\" in flashEvent) {\n      this.protocol = flashEvent.protocol;\n    }\n    \n    var jsEvent;\n    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n      jsEvent = this.__createSimpleEvent(flashEvent.type);\n    } else if (flashEvent.type == \"close\") {\n      // TODO implement jsEvent.wasClean\n      jsEvent = this.__createSimpleEvent(\"close\");\n    } else if (flashEvent.type == \"message\") {\n      var data = decodeURIComponent(flashEvent.message);\n      jsEvent = this.__createMessageEvent(\"message\", data);\n    } else {\n      throw \"unknown event type: \" + flashEvent.type;\n    }\n    \n    this.dispatchEvent(jsEvent);\n  };\n  \n  WebSocket.prototype.__createSimpleEvent = function(type) {\n    if (document.createEvent && window.Event) {\n      var event = document.createEvent(\"Event\");\n      event.initEvent(type, false, false);\n      return event;\n    } else {\n      return {type: type, bubbles: false, cancelable: false};\n    }\n  };\n  \n  WebSocket.prototype.__createMessageEvent = function(type, data) {\n    if (document.createEvent && window.MessageEvent && !window.opera) {\n      var event = document.createEvent(\"MessageEvent\");\n      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n      return event;\n    } else {\n      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n      return {type: type, data: data, bubbles: false, cancelable: false};\n    }\n  };\n  \n  /**\n   * Define the WebSocket readyState enumeration.\n   */\n  WebSocket.CONNECTING = 0;\n  WebSocket.OPEN = 1;\n  WebSocket.CLOSING = 2;\n  WebSocket.CLOSED = 3;\n\n  WebSocket.__flash = null;\n  WebSocket.__instances = {};\n  WebSocket.__tasks = [];\n  WebSocket.__nextId = 0;\n  \n  /**\n   * Load a new flash security policy file.\n   * @param {string} url\n   */\n  WebSocket.loadFlashPolicyFile = function(url){\n    WebSocket.__addTask(function() {\n      WebSocket.__flash.loadManualPolicyFile(url);\n    });\n  };\n\n  /**\n   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n   */\n  WebSocket.__initialize = function() {\n    if (WebSocket.__flash) return;\n    \n    if (WebSocket.__swfLocation) {\n      // For backword compatibility.\n      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n    }\n    if (!window.WEB_SOCKET_SWF_LOCATION) {\n      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n      return;\n    }\n    var container = document.createElement(\"div\");\n    container.id = \"webSocketContainer\";\n    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n    // the best we can do as far as we know now.\n    container.style.position = \"absolute\";\n    if (WebSocket.__isFlashLite()) {\n      container.style.left = \"0px\";\n      container.style.top = \"0px\";\n    } else {\n      container.style.left = \"-100px\";\n      container.style.top = \"-100px\";\n    }\n    var holder = document.createElement(\"div\");\n    holder.id = \"webSocketFlash\";\n    container.appendChild(holder);\n    document.body.appendChild(container);\n    // See this article for hasPriority:\n    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n    swfobject.embedSWF(\n      WEB_SOCKET_SWF_LOCATION,\n      \"webSocketFlash\",\n      \"1\" /* width */,\n      \"1\" /* height */,\n      \"10.0.0\" /* SWF version */,\n      null,\n      null,\n      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n      null,\n      function(e) {\n        if (!e.success) {\n          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n        }\n      });\n  };\n  \n  /**\n   * Called by Flash to notify JS that it's fully loaded and ready\n   * for communication.\n   */\n  WebSocket.__onFlashInitialized = function() {\n    // We need to set a timeout here to avoid round-trip calls\n    // to flash during the initialization process.\n    setTimeout(function() {\n      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n      WebSocket.__flash.setCallerUrl(location.href);\n      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n        WebSocket.__tasks[i]();\n      }\n      WebSocket.__tasks = [];\n    }, 0);\n  };\n  \n  /**\n   * Called by Flash to notify WebSockets events are fired.\n   */\n  WebSocket.__onFlashEvent = function() {\n    setTimeout(function() {\n      try {\n        // Gets events using receiveEvents() instead of getting it from event object\n        // of Flash event. This is to make sure to keep message order.\n        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n        var events = WebSocket.__flash.receiveEvents();\n        for (var i = 0; i < events.length; ++i) {\n          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 0);\n    return true;\n  };\n  \n  // Called by Flash.\n  WebSocket.__log = function(message) {\n    console.log(decodeURIComponent(message));\n  };\n  \n  // Called by Flash.\n  WebSocket.__error = function(message) {\n    console.error(decodeURIComponent(message));\n  };\n  \n  WebSocket.__addTask = function(task) {\n    if (WebSocket.__flash) {\n      task();\n    } else {\n      WebSocket.__tasks.push(task);\n    }\n  };\n  \n  /**\n   * Test if the browser is running flash lite.\n   * @return {boolean} True if flash lite is running, false otherwise.\n   */\n  WebSocket.__isFlashLite = function() {\n    if (!window.navigator || !window.navigator.mimeTypes) {\n      return false;\n    }\n    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n      return false;\n    }\n    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n  };\n  \n  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", function(){\n        WebSocket.__initialize();\n      }, false);\n    } else {\n      window.attachEvent(\"onload\", function(){\n        WebSocket.__initialize();\n      });\n    }\n  }\n  \n})();\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   *\n   * @api public\n   */\n  \n  exports.XHR = XHR;\n\n  /**\n   * XHR constructor\n   *\n   * @costructor\n   * @api public\n   */\n\n  function XHR (socket) {\n    if (!socket) return;\n\n    io.Transport.apply(this, arguments);\n    this.sendBuffer = [];\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(XHR, io.Transport);\n\n  /**\n   * Establish a connection\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.open = function () {\n    this.socket.setBuffer(false);\n    this.onOpen();\n    this.get();\n\n    // we need to make sure the request succeeds since we have no indication\n    // whether the request opened or not until it succeeded.\n    this.setCloseTimeout();\n\n    return this;\n  };\n\n  /**\n   * Check if we need to send data to the Socket.IO server, if we have data in our\n   * buffer we encode it and forward it to the `post` method.\n   *\n   * @api private\n   */\n\n  XHR.prototype.payload = function (payload) {\n    var msgs = [];\n\n    for (var i = 0, l = payload.length; i < l; i++) {\n      msgs.push(io.parser.encodePacket(payload[i]));\n    }\n\n    this.send(io.parser.encodePayload(msgs));\n  };\n\n  /**\n   * Send data to the Socket.IO server.\n   *\n   * @param data The message\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.send = function (data) {\n    this.post(data);\n    return this;\n  };\n\n  /**\n   * Posts a encoded message to the Socket.IO server.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  function empty () { };\n\n  XHR.prototype.post = function (data) {\n    var self = this;\n    this.socket.setBuffer(true);\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n        self.posting = false;\n\n        if (this.status == 200){\n          self.socket.setBuffer(false);\n        } else {\n          self.onClose();\n        }\n      }\n    }\n\n    function onload () {\n      this.onload = empty;\n      self.socket.setBuffer(false);\n    };\n\n    this.sendXHR = this.request('POST');\n\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\n    } else {\n      this.sendXHR.onreadystatechange = stateChange;\n    }\n\n    this.sendXHR.send(data);\n  };\n\n  /**\n   * Disconnects the established `XHR` connection.\n   *\n   * @returns {Transport} \n   * @api public\n   */\n\n  XHR.prototype.close = function () {\n    this.onClose();\n    return this;\n  };\n\n  /**\n   * Generates a configured XHR request\n   *\n   * @param {String} url The url that needs to be requested.\n   * @param {String} method The method the request should use.\n   * @returns {XMLHttpRequest}\n   * @api private\n   */\n\n  XHR.prototype.request = function (method) {\n    var req = io.util.request(this.socket.isXDomain())\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\n    req.open(method || 'GET', this.prepareUrl() + query, true);\n\n    if (method == 'POST') {\n      try {\n        if (req.setRequestHeader) {\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        } else {\n          // XDomainRequest\n          req.contentType = 'text/plain';\n        }\n      } catch (e) {}\n    }\n\n    return req;\n  };\n\n  /**\n   * Returns the scheme to use for the transport URLs.\n   *\n   * @api private\n   */\n\n  XHR.prototype.scheme = function () {\n    return this.socket.options.secure ? 'https' : 'http';\n  };\n\n  /**\n   * Check if the XHR transports are supported\n   *\n   * @param {Boolean} xdomain Check if we support cross domain requests.\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.check = function (socket, xdomain) {\n    try {\n      if (io.util.request(xdomain)) {\n        return true;\n      }\n    } catch(e) {}\n\n    return false;\n  };\n\n  /**\n   * Check if the XHR transport supports corss domain requests.\n   * \n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.xdomainCheck = function () {\n    return XHR.check(null, true);\n  };\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.htmlfile = HTMLFile;\n\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile (socket) {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n\n  /**\n   * Creates a new ActiveX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new ActiveXObject('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n\n    iframeC.appendChild(this.iframe);\n\n    var self = this\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\n    this.iframe.src = this.prepareUrl() + query;\n\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n  HTMLFile.prototype._ = function (data, doc) {\n    this.onData(data);\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) { }\n  };\n\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe){\n      try {\n        this.iframe.src = 'about:blank';\n      } catch(e){}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n\n      CollectGarbage();\n    }\n  };\n\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `ActiveXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  HTMLFile.check = function () {\n    if ('ActiveXObject' in window){\n      try {\n        var a = new ActiveXObject('htmlfile');\n        return a && io.Transport.XHR.check();\n      } catch(e){}\n    }\n    return false;\n  };\n\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('htmlfile');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['xhr-polling'] = XHRPolling;\n\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling () {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n  function empty () {};\n\n  XHRPolling.prototype.get = function () {\n    if (!this.open) return;\n\n    var self = this;\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    };\n\n    function onload () {\n      this.onload = empty;\n      self.onData(this.responseText);\n      self.get();\n    };\n\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = this.xhr.onerror = onload;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = empty;\n      try {\n        this.xhr.abort();\n      } catch(e){}\n      this.xhr = null;\n    }\n  };\n\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('xhr-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n  /**\n   * There is a way to hide the loading indicator in Firefox. If you create and\n   * remove a iframe it will stop showing the current loading indicator.\n   * Unfortunately we can't feature detect that and UA sniffing is evil.\n   *\n   * @api private\n   */\n\n  var indicator = global.document && \"MozAppearance\" in\n    global.document.documentElement.style;\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['jsonp-polling'] = JSONPPolling;\n\n  /**\n   * The JSONP transport creates an persistent connection by dynamically\n   * inserting a script tag in the page. This script tag will receive the\n   * information of the Socket.IO server. When new information is received\n   * it creates a new script tag for the new data stream.\n   *\n   * @constructor\n   * @extends {io.Transport.xhr-polling}\n   * @api public\n   */\n\n  function JSONPPolling (socket) {\n    io.Transport['xhr-polling'].apply(this, arguments);\n\n    this.index = io.j.length;\n\n    var self = this;\n\n    io.j.push(function (msg) {\n      self._(msg);\n    });\n  };\n\n  /**\n   * Inherits from XHR polling transport.\n   */\n\n  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  JSONPPolling.prototype.name = 'jsonp-polling';\n\n  /**\n   * Posts a encoded message to the Socket.IO server using an iframe.\n   * The iframe is used because script tags can create POST based requests.\n   * The iframe is positioned outside of the view so the user does not\n   * notice it's existence.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  JSONPPolling.prototype.post = function (data) {\n    var self = this\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (!this.form) {\n      var form = document.createElement('form')\n        , area = document.createElement('textarea')\n        , id = this.iframeId = 'socketio_iframe_' + this.index\n        , iframe;\n\n      form.className = 'socketio';\n      form.style.position = 'absolute';\n      form.style.top = '-1000px';\n      form.style.left = '-1000px';\n      form.target = id;\n      form.method = 'POST';\n      form.setAttribute('accept-charset', 'utf-8');\n      area.name = 'd';\n      form.appendChild(area);\n      document.body.appendChild(form);\n\n      this.form = form;\n      this.area = area;\n    }\n\n    this.form.action = this.prepareUrl() + query;\n\n    function complete () {\n      initIframe();\n      self.socket.setBuffer(false);\n    };\n\n    function initIframe () {\n      if (self.iframe) {\n        self.form.removeChild(self.iframe);\n      }\n\n      try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n      } catch (e) {\n        iframe = document.createElement('iframe');\n        iframe.name = self.iframeId;\n      }\n\n      iframe.id = self.iframeId;\n\n      self.form.appendChild(iframe);\n      self.iframe = iframe;\n    };\n\n    initIframe();\n\n    // we temporarily stringify until we figure out how to prevent\n    // browsers from turning `\\n` into `\\r\\n` in form inputs\n    this.area.value = io.JSON.stringify(data);\n\n    try {\n      this.form.submit();\n    } catch(e) {}\n\n    if (this.iframe.attachEvent) {\n      iframe.onreadystatechange = function () {\n        if (self.iframe.readyState == 'complete') {\n          complete();\n        }\n      };\n    } else {\n      this.iframe.onload = complete;\n    }\n\n    this.socket.setBuffer(true);\n  };\n  \n  /**\n   * Creates a new JSONP poll that can be used to listen\n   * for messages from the Socket.IO server.\n   *\n   * @api private\n   */\n\n  JSONPPolling.prototype.get = function () {\n    var self = this\n      , script = document.createElement('script')\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (this.script) {\n      this.script.parentNode.removeChild(this.script);\n      this.script = null;\n    }\n\n    script.async = true;\n    script.src = this.prepareUrl() + query;\n    script.onerror = function () {\n      self.onClose();\n    };\n\n    var insertAt = document.getElementsByTagName('script')[0]\n    insertAt.parentNode.insertBefore(script, insertAt);\n    this.script = script;\n\n    if (indicator) {\n      setTimeout(function () {\n        var iframe = document.createElement('iframe');\n        document.body.appendChild(iframe);\n        document.body.removeChild(iframe);\n      }, 100);\n    }\n  };\n\n  /**\n   * Callback function for the incoming message stream from the Socket.IO server.\n   *\n   * @param {String} data The message\n   * @api private\n   */\n\n  JSONPPolling.prototype._ = function (msg) {\n    this.onData(msg);\n    if (this.open) {\n      this.get();\n    }\n    return this;\n  };\n\n  /**\n   * The indicator hack only works after onload\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  JSONPPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n    if (!indicator) return fn.call(this);\n\n    io.util.load(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Checks if browser supports this transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.check = function () {\n    return 'document' in global;\n  };\n\n  /**\n   * Check if cross domain requests are supported\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('jsonp-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n}).call(window)\n//@ sourceURL=/node_modules/dnode/node_modules/socket.io-client/dist/browserify.js"
));

require.define("/shared/util/gReader.client.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var dnode = require(\"dnode\"),\n    uuid = require(\"node-uuid\"),\n    extend = require(\"pd\").extend,\n    ee = require(\"eventemitter-light\"),\n    cached,\n    callbackList = []\n\ndnode.connect(function (remote) {\n    cached = remote\n    callbackList.forEach(function (cb) {\n        cb(remote)\n    })\n})\n\nvar Reader = {\n    login: function () {\n        var args = arguments\n        this._getReader(function (reader) {\n            console.log(\"logging in \", args)\n            reader.login.apply(reader, args)\n        })\n    },\n    getItems: function () {\n        var args = arguments\n        this._getReader(function (reader) {\n            reader.getItems.apply(reader, args)\n        })\n    },\n    _getReader: function (callback) {\n        var self = this\n        if (self._reader) {\n            callback(self._reader)\n        }\n        getRemote(function (remote) {\n            remote.makeReader(function (reader) {\n                self._reader = reader\n                callback(reader)\n            })\n        })\n    }\n}\n\nmodule.exports = makeReader\n\nfunction makeReader() {\n    return Object.create(Reader)\n}\n\nfunction getRemote(cb) {\n    if (cached) {\n        cb(cached)\n    } else {\n        callbackList.push(cb)\n    }\n}\n//@ sourceURL=/shared/util/gReader.client.js"
));

require.define("/shared/util/gReader.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (typeof process !== \"undefined\" && process.title === \"node\") {\n    module.exports = (require)(\"./gReader.server.js\")\n} else if (typeof window !== \"undefined\" && window.window) {\n    module.exports = require(\"./gReader.client.js\")\n}\n//@ sourceURL=/shared/util/gReader.js"
));

require.define("/shared/util/scraper.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (typeof process !== \"undefined\" && process.title === \"node\") {\n    module.exports = (require)(\"./scraper.server.js\")\n} else if (typeof window !== \"undefined\" && window.window) {\n    module.exports = require(\"./scraper.client.js\")\n}\n//@ sourceURL=/shared/util/scraper.js"
));

require.define("/shared/dataSources/gReader.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var gReader = require(\"../util/gReader\")\n\nmodule.exports = {\n    reader: gReader()\n}\n//@ sourceURL=/shared/dataSources/gReader.js"
));

require.define("/shared/dataSources/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var clientmongo = require(\"clientmongo\")\n\nmodule.exports = {\n    mongo: clientmongo(\"Users\", \"fyp-db\")\n}\n//@ sourceURL=/shared/dataSources/user.js"
));

require.define("/node_modules/clientmongo/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {}\n//@ sourceURL=/node_modules/clientmongo/package.json"
));

require.define("/node_modules/clientmongo/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (typeof process !== \"undefined\" && process.title === \"node\") {\n    module.exports = require(\"./lib/\" + \"server\")\n} else if (typeof window !== \"undefined\") {\n    module.exports = require(\"./lib/client\")\n}\n//@ sourceURL=/node_modules/clientmongo/index.js"
));

require.define("/node_modules/clientmongo/lib/client.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var dnode = require(\"dnode\"),\n    uuid = require(\"node-uuid\"),\n    pd = require(\"pd\")\n\nvar getRemote = pd.memoize(dnode.connect, dnode)\n\nvar Cursor = {\n    constructor: function (options) {\n        this.name = options.name\n        this.db = options.db\n        var args = this.args = (options.args || []).slice()\n        this.cursor = options.cursor || uuid()\n        this.method = options.method\n        this.commands = []\n\n        if (typeof args[args.length - 1] === \"function\") {\n            args[args.length - 1] = function () {}\n        }\n\n        return this\n    },\n    toArray: tunnelCursorRemote(\"toArray\"),\n    nextObject: tunnelCursorRemote(\"nextObject\"),\n    each: tunnelCursorRemote(\"each\"),\n    count: tunnelCursorRemote(\"count\"),\n    sort: storeOrTunnelCommand(\"sort\"),\n    limit: storeOrTunnelCommand(\"limit\"),\n    skip: storeOrTunnelCommand(\"skip\"),\n    batchSize: storeOrTunnelCommand(\"batchSize\"),\n    explain: tunnelCursorRemote(\"explain\"),\n    close: function (callback) {\n        var self = this,\n            commands = self.commands.slice()\n\n        commands.push({\n            method: \"close\",\n            args: [function () {\n                self._closed = true\n                callback.apply(this, arguments)\n            }]\n        })\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                db: self.db,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n    },\n    isClosed: function () {\n        return this._closed\n    },\n    rewind: storeCommand(\"rewind\")\n}\n\nfunction tunnelCursorRemote(method) {\n    return function () {\n        var self = this,\n            commands = self.commands.slice()\n\n        commands.push({\n            method: method,\n            args: [].slice.call(arguments)\n        })\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                db: self.db,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n\n        return self\n    }\n}\n\nfunction storeOrTunnelCommand(method) {\n    return function () {\n        var self = this,\n            args = [].slice.call(arguments),\n            auth = this.auth,\n            cb = args[args.length - 1]\n\n        self.commands.push({\n            method: method,\n            args: args\n        })\n\n        if (typeof cb !== \"function\") {\n            return self\n        }\n        \n        var commands = self.commands.slice()\n\n        args[args.length - 1] = function (err) {\n            cb(err, self)\n        }\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                db: self.db,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n\n        return self\n    }\n}\n\nfunction storeCommand(method) {\n    return function () {\n        var self = this\n\n        self.commands.push({\n            method: method,\n            args: [].slice.call(arguments)\n        })\n\n        return self\n    }\n}\n\nvar Collection = {\n    constructor: function (collectionName, databaseName, auth) {\n        if (typeof databaseName === \"function\") {\n            auth = databaseName\n            databaseName = null\n        }\n        this._name = collectionName\n        this.collectionName = collectionName\n        this.databaseName = databaseName\n        this.auth = auth\n        return this\n    },\n    findOne: tunnelToRemote(\"findOne\"),\n    insert: tunnelToRemote(\"insert\"),\n    remove: tunnelToRemote(\"remove\"),\n    rename: tunnelToRemoteWithCollection(\"rename\"),\n    save: tunnelToRemote(\"save\"),\n    update: tunnelToRemote(\"update\"),\n    distinct: tunnelToRemote(\"distinct\"),\n    count: tunnelToRemote(\"count\"),\n    drop: tunnelToRemote(\"drop\"),\n    findAndModify: tunnelToRemote(\"findAndModify\"),\n    findAndRemove: tunnelToRemote(\"findAndRemove\"),\n    findOne: function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            db = this.databaseName,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            getRemote(function (remote) {\n                remote.sendCollectionCommand({\n                    method: \"findOne\", \n                    name: name,\n                    db: db,\n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            db: db,\n            method: \"findOne\"\n        }, auth)\n    },\n    find: function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            db = this.databaseName,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            args[args.length - 1] = function (err, cursorName) {\n                callback.call(this, err, cursor({\n                    cursor: cursorName,\n                    name: name,\n                    args: args,\n                    db: db,\n                    method: \"find\"\n                }, auth))\n            }\n\n            return getRemote(function (remote) {\n                remote.sendCommandWithCursor({\n                    method: \"find\", \n                    name: name,\n                    db: db,\n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            db: db,\n            method: \"find\"\n        }, auth)\n    },\n    createIndex: tunnelToRemote(\"createIndex\"),\n    ensureIndex: tunnelToRemote(\"ensureIndex\"),\n    indexInformation: tunnelToRemote(\"indexInformation\"),\n    dropIndex: tunnelToRemote(\"dropIndex\"),\n    dropAllIndexes: tunnelToRemote(\"dropAllIndexes\"),\n    reIndex: tunnelToRemote(\"reIndex\"),\n    mapReduce: tunnelToRemoteWithCollection(\"mapReduce\"),\n    group: tunnelToRemote(\"group\"),\n    indexExists: tunnelToRemote(\"indexExists\"),\n    geoNear: tunnelToRemote(\"geoNear\"),\n    geoHaystackSearch: tunnelToRemote(\"geoHaystackSearch\"),\n    indexes: tunnelToRemote(\"indexes\"),\n    stats: tunnelToRemote(\"stats\")\n}\n\nmodule.exports = function (name, databaseName, auth) {\n    return collection(name, auth)\n}\n\nfunction collection(name, databaseName, auth) {\n    return Object.create(Collection).constructor(name, databaseName, auth)\n}\n\nfunction cursor(options, auth) {\n    return Object.create(Cursor).constructor(options, auth)\n}\n\nfunction tunnelToRemote(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            db = this.databaseName,\n            auth = this.auth\n\n        getRemote(function (remote) {\n            remote.sendCollectionCommand({\n                method: methodName,\n                name: name,\n                db: db,\n                args: args,\n                auth: auth\n            })\n        })\n    }\n}\n\nfunction tunnelToRemoteWithCursor(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            db = this.databaseName,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            getRemote(function (remote) {\n                remote.sendCollectionCommand({\n                    method: methodName, \n                    name: name, \n                    db: db,\n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            db: db,\n            method: methodName\n        }, auth)\n    }\n}\n\nfunction tunnelToRemoteWithCollection(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            cb = args[args.length - 1],\n            auth = this.auth,\n            db = this.databaseName,\n            name = this._name\n\n        args[args.length - 1] = function (err, collectionName) {\n            cb(err, \n                collectionName && collection(collectionName, auth))\n        }\n\n        getRemote(function (remote) {\n            remote.sendCommandWithCollection({\n                method: methodName,\n                name: name,\n                db: db,\n                auth: auth,\n                args: args\n            })\n        })   \n    }\n}\n//@ sourceURL=/node_modules/clientmongo/lib/client.js"
));

require.define("/shared/dataSources/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var clientmongo = require(\"clientmongo\")\n\nmodule.exports = {\n    mongo: clientmongo(\"Posts\", \"fyp-db\")\n}\n//@ sourceURL=/shared/dataSources/post.js"
));

require.define("/shared/dataSources/scraper.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var scraper = require(\"../util/scraper\")\n\nmodule.exports = {\n    scraper: scraper\n}\n//@ sourceURL=/shared/dataSources/scraper.js"
));

require.define("/client/app.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    init: function () {\n        \n    }\n}\n//@ sourceURL=/client/app.js"
));

require.define("/browser.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "window.nCore = require(\"./core\")\n//@ sourceURL=/browser.js"
));
require("/browser.js");

require.define("/dummy.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function () { \nvar Core = Object.create(nCore).constructor()\ndelete window.nCore \nCore.use('shared.domains.user', require('./shared/domains/user.js')) \nCore.use('shared.domains.post', require('./shared/domains/post.js')) \nCore.use('client.controllers.user', require('./client/controllers/user.js')) \nCore.use('client.controllers.post', require('./client/controllers/post.js')) \nCore.use('client.views.user', require('./client/views/user.js')) \nCore.use('client.views.post', require('./client/views/post.js')) \nCore.use('shared.util.scraper.client', require('./shared/util/scraper.client.js')) \nCore.use('shared.util.gReader.client', require('./shared/util/gReader.client.js')) \nCore.use('shared.util.gReader', require('./shared/util/gReader.js')) \nCore.use('shared.util.scraper', require('./shared/util/scraper.js')) \nCore.use('shared.dataSources.gReader', require('./shared/dataSources/gReader.js')) \nCore.use('shared.dataSources.user', require('./shared/dataSources/user.js')) \nCore.use('shared.dataSources.post', require('./shared/dataSources/post.js')) \nCore.use('shared.dataSources.scraper', require('./shared/dataSources/scraper.js')) \nCore.use('client.util.store', require('./client/util/store.js')) \nCore.use('client.app', require('./client/app.js')) \nCore.dependencies = {\"client.controllers.user\":{\"domain\":\"shared.domains.user\",\"view\":\"client.views.user\"},\"client.controllers.post\":{\"domain\":\"shared.domains.post\",\"view\":\"client.views.post\"},\"client.views.user\":{\"domain\":\"shared.domains.user\"},\"client.views.post\":{\"domain\":\"shared.domains.post\"},\"shared.domains.user\":{\"dataSources\":{\"gReader\":\"shared.dataSources.gReader\",\"user\":\"shared.dataSources.user\",\"post\":\"shared.dataSources.post\",\"scraper\":\"shared.dataSources.scraper\"}},\"shared.domains.post\":{\"dataSources\":{\"gReader\":\"shared.dataSources.gReader\",\"user\":\"shared.dataSources.user\",\"post\":\"shared.dataSources.post\",\"scraper\":\"shared.dataSources.scraper\"}}}\nCore.init()\n})()\n//@ sourceURL=/dummy.js"
));
require("/dummy.js");
