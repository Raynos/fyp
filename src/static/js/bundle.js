var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = (function () {
    var queue = [];
    var canPost = typeof window !== 'undefined'
        && window.postMessage && window.addEventListener
    ;
    
    if (canPost) {
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'browserify-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);
    }
    
    return function (fn) {
        if (canPost) {
            queue.push(fn);
            window.postMessage('browserify-tick', '*');
        }
        else setTimeout(fn, 0);
    };
})();

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

require.define("path", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("/core.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "\"use strict\"\n\nvar EventEmitter = require(\"eventemitter-light\"),\n    pd = require(\"pd\");\n\n/*\n    Modules have four phases. The first two are handled for you\n\n    The definition phase:\n\n        When a module is used on the core, the core will inspect the module\n            by reading it's expose property. It then copies the methods in the\n            expose array out of the array and calls it the interface of the \n            module\n\n        At this the interface is wrapped in a proxy that invokes it indirectly.\n            this proxy is the public interface, this indirection is added to\n            support hot reloading of interfaces\n\n    Someone calls Core.init() and then the following three phases occur\n\n    The injection phase:\n\n        When the core is initialized all the dependencies are injected into\n            all the modules. This injection is based on the dependency mapping\n            passed into the core when it's constructed\n\n        Injection basically means mixing in the dependencies into the module\n\n    The setup phase:\n\n        The setup phase happens after dependencies are injected for all the\n            modules. In this phase the core calls the setup method of\n            the modules with an optional done callback\n\n        This allows modules to do asynchronous setup logic and tell the Core\n            \"hey I'm ready to go now\"\n\n    The init phase:\n\n        After all the modules are ready the init method is invoked on \n            modules that have it.\n\n        The init method is used to start your application, i.e. create your \n            HTTP server or start your cron jobs, etc.\n\n    Note that inside the interfaces methods the thisContext value is the module\n        itself.\n*/\nmodule.exports = {\n    /*\n        Construct a Core with dependencies and an optional EventEmitter \n            prototype. \n\n        The dependencies contain the dependency mapping setup for\n            modules, so the core knows what dependencies to inject into what\n            modules. \n\n        The eventemitter prototype is used to choose the eventEmitter \n            implementation that interfaces have.\n\n        @param {Object} dependencies - This is a map of dependencies.\n            {\n                <ModuleName>: {\n                    <PropertyName>: <OtherModuleName>\n                }\n            }\n\n            This means that <ModuleName> will have a deps object injected with\n                a property <PropertyName> which contains the public interface\n                of <OtherModuleName>\n\n        @param {Object} [ee] - An optional EventEmitter prototype. Used if you \n            want the interface to inherit from a different EventEmitter then\n            eventemitter-light\n    */\n    constructor: function constructor(dependencies, ee) {\n        var that = this;\n        that.interfaces  = {};\n        that._ee = ee || EventEmitter;\n        that._modules = {};\n        that._interfaces = {};\n        that.dependencies = dependencies || {};\n        return that;\n    },\n    /*\n        This is used to attach a module to the core. When a module is attached\n            the core asks the module what interface it exposes\n        \n        @param {String} name - The name of this module\n\n        @param {Object} module - The implementation of the module. \n\n        @return {Object} interface - the public interface of this module is\n            returned\n    */\n    use: function use(name, module) {\n        var _interface = pd.bindAll({}, this._ee);\n        pd.bindAll(module, {\n            emit: _interface.emit\n        })\n        _interface.constructor()\n        if (Array.isArray(module.expose)) {\n            module.expose.forEach(addToInterface)\n        } else {\n            pd.extend(_interface, module.expose || module)\n        }\n        _interface.on && _interface.on(\"ncore::expose\", addPropsToInterface)\n        var proxy = this._makeProxy(name, _interface, module)\n        return proxy\n\n        function addPropsToInterface(obj) {\n            pd.extend(proxy, obj)\n        }\n\n        function addToInterface(name) {\n            _interface[name] = module[name]\n        }\n    },\n    /*\n        init will initialize the Core. This means injecting the dependencies\n            into modules based on the dependency mapping. \n\n        @param {Function} [callback] - optional callback to be invoked when\n            all modules are done injecting dependencies\n    */\n    init: function init(callback) {\n        var that = this,\n            counter = 1\n\n        Object.keys(that._interfaces).forEach(injectDeps)\n        Object.keys(that._interfaces).forEach(setupModules)\n        next()\n\n        function injectDeps(name) {\n            var module = that._modules[name],\n                deps = {}\n\n            if (that.dependencies[name]) {\n                Object.keys(that.dependencies[name]).forEach(mapToInterface)\n            }\n            pd.extend(module, deps);\n\n            function mapToInterface(key) {\n                var dependency = that.dependencies[name][key]\n                if (typeof dependency === \"string\") {\n                    deps[key] = that.interfaces[dependency]   \n                } else if (Array.isArray(dependency)) {\n                    deps[key] = dependency.map(returnInterface)\n                } else if (typeof dependency === \"object\") {\n                    deps[key] = {}\n                    Object.keys(dependency).forEach(setDependency)\n                }\n                \n                function returnInterface(dependency) {\n                    return that.interfaces[dependency]\n                }\n\n                function setDependency(name) {\n                    deps[key][name] = that.interfaces[dependency[name]]\n                }\n            }\n        }\n\n        function setupModules(name) {\n            var module = that._modules[name]\n\n            if (module.setup) {\n                if (module.setup.length === 1) {\n                    counter++\n                }\n                module.setup(next)\n            }\n        }\n\n        function next() {\n            if (--counter === 0) {\n                callback && callback()\n                Object.keys(that._modules).forEach(invokeInit)\n            }\n        }\n\n        function invokeInit(name) {\n            var module = that._modules[name]\n            module.init && module.init()\n        }\n    },\n    /*\n        remove, removes the module from the Core. It will also invoke the \n            module's destroy method, allowing the module to do clean up logic.  \n\n        @param {String} name - The module to remove\n    */\n    remove: function remove(name) {\n        var that = this,\n            module = that._modules[name]\n\n        delete that.interfaces[name]\n        delete that._interfaces[name]\n        delete that._modules[name]\n\n        module.destroy && module.destroy()\n    },\n    /*\n        purge just removes all modules from the Core. basically resetting the\n            core to a clean state.\n    */\n    purge: function purge() {\n        Object.keys(this.interfaces).forEach(callRemove, this)\n        \n        function callRemove(name) {\n            this.remove(name)\n        }\n    },\n    /*\n        makeProxy takes an interface and a module and stores a proxy of the \n            interface as the public interface under Core.interfaces\n\n        @param {String} name - name of module\n\n        @param {Object} interface - internal interface object\n\n        @param {Object} module - module object of module\n    */\n    _makeProxy: function _makeProxy(name, _interface, module) {\n        var proxy = {},\n            that = this\n\n        Object.keys(_interface).forEach(proxyProperty)\n        that._interfaces[name] = _interface\n        that._modules[name] = module\n        that.interfaces[name] = proxy\n\n        return proxy\n\n        function proxyProperty(name) {\n            var value = _interface[name]\n            if (typeof value === \"function\") {\n                _interface[name] = value.bind(module)\n                proxy[name] = proxyFunction(name)\n            } else {\n                proxy[name] = value\n            }\n        }\n\n        function proxyFunction(functionName) {\n            return proxy\n\n            function proxy() {\n                return that._interfaces[name][functionName]\n                    .apply(this, arguments)\n            }\n        }\n    }\n}\n//@ sourceURL=/core.js"
));

require.define("/node_modules/eventemitter-light/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/ee\"}\n//@ sourceURL=/node_modules/eventemitter-light/package.json"
));

require.define("/node_modules/eventemitter-light/lib/ee.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    on: function on(ev, handler) {\n        var events = this._events;\n\n        (events[ev] || (events[ev] = [])).push(handler);\n    },\n    removeListener: function removeListener(ev, handler) {\n        var array = this._events[ev];\n\n        array && array.splice(array.indexOf(handler), 1);\n    },\n    emit: function emit(ev) {\n        var args = [].slice.call(arguments, 1),\n            array = this._events[ev] || [];\n\n        for (var i = 0, len = array.length; i < len; i++) {\n            array[i].apply(this, args);\n        }\n    },\n    once: function once(ev, handler) {\n        this.on(ev, proxy);\n\n        function proxy() {\n            handler.apply(this, arguments);\n            this.removeListener(ev, handler);\n        }\n    },\n    constructor: function constructor() {\n        this._events = {};\n        return this;\n    }\n};\n//@ sourceURL=/node_modules/eventemitter-light/lib/ee.js"
));

require.define("/node_modules/pd/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/pd\"}\n//@ sourceURL=/node_modules/pd/package.json"
));

require.define("/node_modules/pd/lib/pd.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n    pd(obj) -> propertyDescriptorsOfObject {\n        bindAll: function that binds all the methods of an object to the object,\n        extend: function that extends the first argument with the rest\n        Name: returns a namespace(anyKey) -> uniqueObject function\n    }\n    \n    pd requires ES5. Uses the shimmable subset of ES5.\n*/\n;(function (Object, slice) {\n    \"use strict\"\n    \n    pd.bindAll = bindAll\n    pd.extend = extend\n    pd.Name = Name\n    \n    typeof module !== \"undefined\" ? module.exports = pd : window.pd = pd\n\n    /*\n        pd will return all the own propertydescriptors of the object\n\n        @param Object object - object to get pds from.\n\n        @return Object - A hash of key/propertyDescriptors\n    */    \n    function pd(obj) {\n        var pds = {}\n        Object.getOwnPropertyNames(obj).forEach(function(key) {\n            pds[key] = Object.getOwnPropertyDescriptor(obj, key)\n        })\n        return pds\n    }\n\n    /*\n        Extend will extend the firat parameter with any other parameters \n        passed in. Only the own property names will be extended into\n        the object\n\n        @param Object target - target to be extended\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the target\n\n        @return Object - the target\n    */\n    function extend(target) {\n        slice.call(arguments, 1).forEach(function(source) {\n            Object.defineProperties(target, pd(source))\n        });\n        return target\n    }\n\n    /*\n        defines a namespace object. This hides a \"privates\" object on object \n        under the \"key\" namespace\n\n        @param Object object - object to hide a privates object on\n        @param Object key - key to hide it under\n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Object privates\n    */\n    function namespace(object, key) {\n        var privates = Object.create(object),\n            valueOf = object.valueOf\n        \n        Object.defineProperty(object, \"valueOf\", {\n            value: function(value) {\n                return value !== key ? valueOf.apply(this, arguments) : privates\n            },\n            writable: true,\n            configurable: true\n        })\n        \n        return privates\n    }\n    \n    /*\n        Constructs a Name function, when given an object it will return a\n        privates object. \n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Function name\n    */\n    function Name() {\n        var key = {}\n        return name\n        \n        function name(object) {\n            var privates = object.valueOf(key)\n            return privates !== object ? privates : namespace(object, key)\n        }\n    }\n    \n    /*\n        bindAll binds all methods to have their context set to the object\n\n        @param Object obj - the object to bind methods on\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the obj\n\n        @return Object - the bound object\n    */\n    function bindAll(obj) {\n        pd.extend.apply(null, arguments) \n        Object.keys(obj).filter(isMethod).forEach(bindMethods)\n        return obj\n        \n        function isMethod(name) {\n            return obj[name] && obj[name].bind === isMethod.bind\n        }\n        \n        function bindMethods(name) {\n            obj[name] = obj[name].bind(obj)\n        }\n    }\n\n})(Object, [].slice)\n//@ sourceURL=/node_modules/pd/lib/pd.js"
));

require.define("/client/app.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    init: function () {\n        \n    }\n}\n//@ sourceURL=/client/app.js"
));

require.define("/shared/domains/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var pd = require(\"pd\")\n\nvar GetUser = {\n    start: function () {\n        this.collection.findOne({ \n            email: this.user.email \n        }, this.createIfNeeded)\n    },\n    createIfNeeded: function (err, user) {\n        if (err) return this.callback(err)\n        if (user === null) {\n            this.collection.insert(this.user, (function (err, result) {\n                this.callback(null, user)\n            }).bind(this))\n        } else {\n            this.callback(null, user)    \n        }\n    }\n}\n\nmodule.exports = {\n    setup: function () {\n        this.collection = this.dataSources.user.mongo\n    },\n    get: function (user, callback) {\n        pd.bindAll({}, GetUser, {\n            user: user,\n            callback: callback\n        }, this).start()\n    }\n}\n//@ sourceURL=/shared/domains/user.js"
));

require.define("/node_modules/pd/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"lib/pd\"}\n//@ sourceURL=/node_modules/pd/package.json"
));

require.define("/node_modules/pd/lib/pd.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n    pd(obj) -> propertyDescriptorsOfObject {\n        bindAll: function that binds all the methods of an object to the object,\n        extend: function that extends the first argument with the rest\n        Name: returns a namespace(anyKey) -> uniqueObject function\n    }\n    \n    pd requires ES5. Uses the shimmable subset of ES5.\n*/\n;(function (Object, slice) {\n    \"use strict\"\n    \n    pd.bindAll = bindAll\n    pd.extend = extend\n    pd.Name = Name\n    \n    typeof module !== \"undefined\" ? module.exports = pd : window.pd = pd\n\n    /*\n        pd will return all the own propertydescriptors of the object\n\n        @param Object object - object to get pds from.\n\n        @return Object - A hash of key/propertyDescriptors\n    */    \n    function pd(obj) {\n        var pds = {}\n        Object.getOwnPropertyNames(obj).forEach(function(key) {\n            pds[key] = Object.getOwnPropertyDescriptor(obj, key)\n        })\n        return pds\n    }\n\n    /*\n        Extend will extend the firat parameter with any other parameters \n        passed in. Only the own property names will be extended into\n        the object\n\n        @param Object target - target to be extended\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the target\n\n        @return Object - the target\n    */\n    function extend(target) {\n        slice.call(arguments, 1).forEach(function(source) {\n            Object.defineProperties(target, pd(source))\n        });\n        return target\n    }\n\n    /*\n        defines a namespace object. This hides a \"privates\" object on object \n        under the \"key\" namespace\n\n        @param Object object - object to hide a privates object on\n        @param Object key - key to hide it under\n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Object privates\n    */\n    function namespace(object, key) {\n        var privates = Object.create(object),\n            valueOf = object.valueOf\n        \n        Object.defineProperty(object, \"valueOf\", {\n            value: function(value) {\n                return value !== key ? valueOf.apply(this, arguments) : privates\n            },\n            writable: true,\n            configurable: true\n        })\n        \n        return privates\n    }\n    \n    /*\n        Constructs a Name function, when given an object it will return a\n        privates object. \n\n        @author Gozala : https://gist.github.com/1269991\n\n        @return Function name\n    */\n    function Name() {\n        var key = {}\n        return name\n        \n        function name(object) {\n            var privates = object.valueOf(key)\n            return privates !== object ? privates : namespace(object, key)\n        }\n    }\n    \n    /*\n        bindAll binds all methods to have their context set to the object\n\n        @param Object obj - the object to bind methods on\n        @arguments Array [target, ...] - the rest of the objects passed\n            in will extended into the obj\n\n        @return Object - the bound object\n    */\n    function bindAll(obj) {\n        pd.extend.apply(null, arguments) \n        Object.keys(obj).filter(isMethod).forEach(bindMethods)\n        return obj\n        \n        function isMethod(name) {\n            return obj[name] && obj[name].bind === isMethod.bind\n        }\n        \n        function bindMethods(name) {\n            obj[name] = obj[name].bind(obj)\n        }\n    }\n\n})(Object, [].slice)\n//@ sourceURL=/node_modules/pd/lib/pd.js"
));

require.define("/shared/domains/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\n    setup: function () {\n        this.scraper = this.dataSources.scraper.scraper\n    },\n    find: function (uri, callback) {\n        this.scraper(uri, callback)\n    }\n}\n//@ sourceURL=/shared/domains/post.js"
));

require.define("/client/routes/post.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "console.log(\"routes loaded\")\n\n\nmodule.exports = {\n    init: function () {\n        console.log(\"init routes\")\n        this.domain.find(\"http://raynos.org/blog/\", function (err, uris) {\n            console.log(\"uris found\", uris)\n        })\n    }\n}\n//@ sourceURL=/client/routes/post.js"
));

require.define("/shared/util/scraper.client.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = function (uri, callback) {\n    var iframe = document.createElement(\"iframe\")\n    iframe.onload = handleLoad\n    iframe.src = uri\n    iframe.style.display = 'none'\n    document.head.appendChild(iframe)\n\n    function handleLoad() {\n        var uris = [].slice.call(iframe.contentWindow.document.links)\n        uris = uris.map(toString)\n        document.head.removeChild(iframe)\n        cb(null, uris)\n\n        function toString(node) {\n            return node.href\n        }\n    }\n}\n//@ sourceURL=/shared/util/scraper.client.js"
));

require.define("/shared/util/scraper.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (typeof process !== \"undefined\" && process.title === \"node\") {\n    module.exports = (require)(\"./scraper.server.js\")\n} else if (typeof window !== \"undefined\" && window.window) {\n    module.exports = require(\"./scraper.client.js\")\n}\n//@ sourceURL=/shared/util/scraper.js"
));

require.define("/shared/dataSources/user.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var clientmongo = require(\"clientmongo\")\n\nmodule.exports = {\n    mongo: clientmongo(\"Users\")\n}\n//@ sourceURL=/shared/dataSources/user.js"
));

require.define("/node_modules/clientmongo/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {}\n//@ sourceURL=/node_modules/clientmongo/package.json"
));

require.define("/node_modules/clientmongo/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (typeof process !== \"undefined\" && process.title === \"node\") {\n    module.exports = require(\"./lib/\" + \"server\")\n} else if (typeof window !== \"undefined\") {\n    module.exports = require(\"./lib/client\")\n}\n//@ sourceURL=/node_modules/clientmongo/index.js"
));

require.define("/node_modules/clientmongo/lib/client.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var dnode = require(\"dnode\"),\n    uuid = require(\"node-uuid\"),\n    cached,\n    callbackList = []\n\ndnode.connect(function (remote) {\n    cached = remote\n    callbackList.forEach(function (cb) {\n        cb(remote)\n    })\n})\n\nvar Cursor = {\n    constructor: function (options) {\n        this.name = options.name\n        var args = this.args = (options.args || []).slice()\n        this.cursor = options.cursor || uuid()\n        this.method = options.method\n        this.commands = []\n\n        if (typeof args[args.length - 1] === \"function\") {\n            args[args.length - 1] = function () {}\n        }\n\n        return this\n    },\n    toArray: tunnelCursorRemote(\"toArray\"),\n    nextObject: tunnelCursorRemote(\"nextObject\"),\n    each: tunnelCursorRemote(\"each\"),\n    count: tunnelCursorRemote(\"count\"),\n    sort: storeOrTunnelCommand(\"sort\"),\n    limit: storeOrTunnelCommand(\"limit\"),\n    skip: storeOrTunnelCommand(\"skip\"),\n    batchSize: storeOrTunnelCommand(\"batchSize\"),\n    explain: tunnelCursorRemote(\"explain\"),\n    close: function (callback) {\n        var self = this,\n            commands = self.commands.slice()\n\n        commands.push({\n            method: \"close\",\n            args: [function () {\n                self._closed = true\n                callback.apply(this, arguments)\n            }]\n        })\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n    },\n    isClosed: function () {\n        return this._closed\n    },\n    rewind: storeCommand(\"rewind\")\n}\n\nfunction tunnelCursorRemote(method) {\n    return function () {\n        var self = this,\n            commands = self.commands.slice()\n\n        commands.push({\n            method: method,\n            args: [].slice.call(arguments)\n        })\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n\n        return self\n    }\n}\n\nfunction storeOrTunnelCommand(method) {\n    return function () {\n        var self = this,\n            args = [].slice.call(arguments),\n            auth = this.auth,\n            cb = args[args.length - 1]\n\n        self.commands.push({\n            method: method,\n            args: args\n        })\n\n        if (typeof cb !== \"function\") {\n            return self\n        }\n        \n        var commands = self.commands.slice()\n\n        args[args.length - 1] = function (err) {\n            cb(err, self)\n        }\n\n        self.commands = []\n\n        getRemote(function (remote) {\n            remote.sendCursorCommand({\n                method: self.method,\n                args: self.args,\n                cursor: self.cursor,\n                name: self.name,\n                auth: self.auth,\n                commands: commands\n            })\n        })\n\n        return self\n    }\n}\n\nfunction storeCommand(method) {\n    return function () {\n        var self = this\n\n        self.commands.push({\n            method: method,\n            args: [].slice.call(arguments)\n        })\n\n        return self\n    }\n}\n\nvar Collection = {\n    constructor: function (collectionName, auth) {\n        this._name = collectionName\n        this.collectionName = collectionName\n        this.auth = auth\n        return this\n    },\n    findOne: tunnelToRemote(\"findOne\"),\n    insert: tunnelToRemote(\"insert\"),\n    remove: tunnelToRemote(\"remove\"),\n    rename: tunnelToRemoteWithCollection(\"rename\"),\n    save: tunnelToRemote(\"save\"),\n    update: tunnelToRemote(\"update\"),\n    distinct: tunnelToRemote(\"distinct\"),\n    count: tunnelToRemote(\"count\"),\n    drop: tunnelToRemote(\"drop\"),\n    findAndModify: tunnelToRemote(\"findAndModify\"),\n    findAndRemove: tunnelToRemote(\"findAndRemove\"),\n    findOne: function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            getRemote(function (remote) {\n                remote.sendCollectionCommand({\n                    method: \"findOne\", \n                    name: name,\n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            method: \"findOne\"\n        }, auth)\n    },\n    find: function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            args[args.length - 1] = function (err, cursorName) {\n                callback.call(this, err, cursor({\n                    cursor: cursorName\n                }, auth))\n            }\n\n            return getRemote(function (remote) {\n                remote.sendCommandWithCursor({\n                    method: \"find\", \n                    name: name,\n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            method: \"find\"\n        }, auth)\n    },\n    createIndex: tunnelToRemote(\"createIndex\"),\n    ensureIndex: tunnelToRemote(\"ensureIndex\"),\n    indexInformation: tunnelToRemote(\"indexInformation\"),\n    dropIndex: tunnelToRemote(\"dropIndex\"),\n    dropAllIndexes: tunnelToRemote(\"dropAllIndexes\"),\n    reIndex: tunnelToRemote(\"reIndex\"),\n    mapReduce: tunnelToRemoteWithCollection(\"mapReduce\"),\n    group: tunnelToRemote(\"group\"),\n    indexExists: tunnelToRemote(\"indexExists\"),\n    geoNear: tunnelToRemote(\"geoNear\"),\n    geoHaystackSearch: tunnelToRemote(\"geoHaystackSearch\"),\n    indexes: tunnelToRemote(\"indexes\"),\n    stats: tunnelToRemote(\"stats\")\n}\n\nmodule.exports = function (name, auth) {\n    return collection(name, auth)\n}\n\nfunction collection(name, auth) {\n    return Object.create(Collection).constructor(name, auth)\n}\n\nfunction cursor(options, auth) {\n    return Object.create(Cursor).constructor(options, auth)\n}\n\nfunction getRemote(cb) {\n    if (cached) {\n        cb(cached)\n    } else {\n        callbackList.push(cb)\n    }\n}\n\nfunction tunnelToRemote(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            auth = this.auth\n\n        getRemote(function (remote) {\n            remote.sendCollectionCommand({\n                method: methodName,\n                name: name,\n                args: args,\n                auth: auth\n            })\n        })\n    }\n}\n\nfunction tunnelToRemoteWithCursor(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            name = this._name,\n            auth = this.auth,\n            callback = args[args.length - 1]\n\n        if (typeof callback === \"function\") {\n            getRemote(function (remote) {\n                remote.sendCollectionCommand({\n                    method: methodName, \n                    name: name, \n                    auth: auth,\n                    args: args\n                })\n            })\n        }\n        return cursor({\n            name: name,\n            args: args,\n            method: methodName\n        }, auth)\n    }\n}\n\nfunction tunnelToRemoteWithCollection(methodName) {\n    return function () {\n        var args = [].slice.call(arguments),\n            cb = args[args.length - 1],\n            auth = this.auth,\n            name = this._name\n\n        args[args.length - 1] = function (err, collectionName) {\n            cb(err, \n                collectionName && collection(collectionName, auth))\n        }\n\n        getRemote(function (remote) {\n            remote.sendCommandWithCollection({\n                method: methodName,\n                name: name,\n                auth: auth,\n                args: args\n            })\n        })   \n    }\n}\n//@ sourceURL=/node_modules/clientmongo/lib/client.js"
));

require.define("/node_modules/dnode/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index.js\",\"browserify\":\"browser/index.js\"}\n//@ sourceURL=/node_modules/dnode/package.json"
));

require.define("/node_modules/dnode/browser/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var protocol = require('dnode-protocol');\nvar EventEmitter = require('events').EventEmitter;\nvar io = require('socket.io-client');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\n\nvar exports = module.exports = dnode;\n\nfunction dnode (wrapper) {\n    if (!(this instanceof dnode)) return new dnode(wrapper);\n    this.proto = protocol(wrapper);\n    this.stack = [];\n    return this;\n}\n\ndnode.prototype = new EventEmitter;\n\ndnode.prototype.use = function (middleware) {\n    this.stack.push(middleware);\n    return this;\n};\n\ndnode.prototype.connect = function () {\n    var self = this;\n    var params = protocol.parseArgs(arguments);\n    var client = self.proto.create();\n    \n    var proto = (params.proto || window.location.protocol)\n        .replace(/:.*/, '') + '://';\n    \n    var sock = client.socketio = io.connect(\n        proto + (params.host || window.location.host),\n        params\n    );\n    \n    client.end = function () {\n        sock.disconnect();\n    };\n    \n    sock.on('connect', function () {\n        client.start();\n        self.emit('connect');\n    });\n    \n    sock.on('disconnect', function () {\n        client.emit('end');\n        self.emit('end');\n    });\n    \n    sock.on('message', client.parse);\n    \n    client.on('request', function (req) {\n        sock.send(json.stringify(req) + '\\n');\n    });\n    \n    if (params.block) {\n        client.on('remote', function () {\n            params.block.call(client.instance, client.remote, client);\n        });\n    }\n    \n    this.stack.forEach(function (middleware) {\n        middleware.call(client.instance, client.remote, client);\n    });\n};\n\nexports.connect = function () {\n    var d = exports();\n    return d.connect.apply(d, arguments);\n};\n\n//@ sourceURL=/node_modules/dnode/browser/index.js"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/package.json"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var traverse = require('traverse');\nvar EventEmitter = require('events').EventEmitter;\nvar stream = require('stream');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\n\nvar exports = module.exports = function (wrapper) {\n    var self = {};\n    \n    self.sessions = {};\n    \n    self.create = function () {\n        var id = null;\n        do {\n            id = Math.floor(\n                Math.random() * Math.pow(2,32)\n            ).toString(16);\n        } while (self.sessions[id]);\n        \n        var s = Session(id, wrapper);\n        self.sessions[id] = s;\n        return s;\n    };\n    \n    self.destroy = function (id) {\n        delete self.sessions[id];\n    };\n    \n    return self;\n};\n\nvar Session = exports.Session = function (id, wrapper) {\n    var self = new EventEmitter;\n    \n    self.id = id;\n    self.remote = {};\n    \n    var instance = self.instance =\n        typeof(wrapper) == 'function'\n            ? new wrapper(self.remote, self)\n            : wrapper || {}\n    ;\n    \n    self.localStore = new Store;\n    self.remoteStore = new Store;\n    \n    self.localStore.on('cull', function (id) {\n        self.emit('request', {\n            method : 'cull',\n            arguments : [id],\n            callbacks : {}\n        });\n    });\n    \n    var scrubber = new Scrubber(self.localStore);\n    \n    self.start = function () {\n        self.request('methods', [ instance ]);\n    };\n    \n    self.request = function (method, args) {\n        var scrub = scrubber.scrub(args);\n        \n        self.emit('request', {\n            method : method,\n            arguments : scrub.arguments,\n            callbacks : scrub.callbacks,\n            links : scrub.links\n        });\n    };\n    \n    self.parse = function (line) {\n        var msg = null;\n        try { msg = json.parse(line) }\n        catch (err) {\n            self.emit('error', new SyntaxError(\n                'Error parsing JSON message: ' + json.stringify(line))\n            );\n            return;\n        }\n        \n        try { self.handle(msg) }\n        catch (err) { self.emit('error', err) }\n    };\n    \n    self.handle = function (req) {\n        var args = scrubber.unscrub(req, function (id) {\n            if (!self.remoteStore.has(id)) {\n                // create a new function only if one hasn't already been created\n                // for a particular id\n                self.remoteStore.add(function () {\n                    self.request(id, [].slice.apply(arguments));\n                }, id);\n            }\n            return self.remoteStore.get(id);\n        });\n        \n        if (req.method === 'methods') {\n            handleMethods(args[0]);\n        }\n        else if (req.method === 'error') {\n            var methods = args[0];\n            self.emit('remoteError', methods);\n        }\n        else if (req.method === 'cull') {\n            args.forEach(function (id) {\n                self.remoteStore.cull(args);\n            });\n        }\n        else if (typeof req.method === 'string') {\n            if (self.instance.propertyIsEnumerable(req.method)) {\n                apply(self.instance[req.method], self.instance, args);\n            }\n            else {\n                self.emit('error', new Error(\n                    'Request for non-enumerable method: ' + req.method\n                ));\n            }\n        }\n        else if (typeof req.method == 'number') {\n            apply(self.localStore.get(req.method), self.instance, args);\n        }\n    }\n    \n    function handleMethods (methods) {\n        if (typeof methods != 'object') {\n            methods = {};\n        }\n        \n        // copy since assignment discards the previous refs\n        Object.keys(self.remote).forEach(function (key) {\n            delete self.remote[key];\n        });\n        \n        Object.keys(methods).forEach(function (key) {\n            self.remote[key] = methods[key];\n        });\n        \n        self.emit('remote', self.remote);\n        self.emit('ready');\n    }\n    \n    function apply(f, obj, args) {\n        try { f.apply(obj, args) }\n        catch (err) { self.emit('error', err) }\n    }\n    \n    return self;\n};\n\n// scrub callbacks out of requests in order to call them again later\nvar Scrubber = exports.Scrubber = function (store) {\n    var self = {};\n    store = store || new Store;\n    self.callbacks = store.items;\n    \n    // Take the functions out and note them for future use\n    self.scrub = function (obj) {\n        var paths = {};\n        var links = [];\n        \n        var args = traverse(obj).map(function (node) {\n            if (typeof(node) == 'function') {\n                var i = store.indexOf(node);\n                if (i >= 0 && !(i in paths)) {\n                    // Keep previous function IDs only for the first function\n                    // found. This is somewhat suboptimal but the alternatives\n                    // are worse.\n                    paths[i] = this.path;\n                }\n                else {\n                    var id = store.add(node);\n                    paths[id] = this.path;\n                }\n                \n                this.update('[Function]');\n            }\n            else if (this.circular) {\n                links.push({ from : this.circular.path, to : this.path });\n                this.update('[Circular]');\n            }\n        });\n        \n        return {\n            arguments : args,\n            callbacks : paths,\n            links : links\n        };\n    };\n    \n    // Replace callbacks. The supplied function should take a callback id and\n    // return a callback of its own.\n    self.unscrub = function (msg, f) {\n        var args = msg.arguments || [];\n        Object.keys(msg.callbacks || {}).forEach(function (strId) {\n            var id = parseInt(strId,10);\n            var path = msg.callbacks[id];\n            args = setAt(args, path, f(id));\n        });\n        \n        (msg.links || []).forEach(function (link) {\n            var value = getAt(args, link.from);\n            args = setAt(args, link.to, value);\n        });\n        \n        return args;\n    };\n    \n    function setAt (ref, path, value) {\n        var node = ref;\n        for (var i = 0; i < path.length - 1; i++) {\n            var key = path[i];\n            if (Object.propertyIsEnumerable.call(node, key)) {\n                node = node[key];\n            }\n            else return undefined;\n        };\n        var last = path.slice(-1)[0];\n        if (last === undefined) {\n            return value;\n        }\n        else {\n            node[last] = value;\n            return ref;\n        }\n    }\n    \n    function getAt (node, path) {\n        for (var i = 0; i < path.length; i++) {\n            var key = path[i];\n            if (Object.propertyIsEnumerable.call(node, key)) {\n                node = node[key];\n            }\n            else return undefined;\n        }\n        return node;\n    }\n    \n    return self;\n}\n\nvar Store = exports.Store = function() {\n    var self = new EventEmitter;\n    var items = self.items = [];\n    \n    self.has = function (id) {\n        return items[id] != undefined;\n    };\n    \n    self.get = function (id) {\n        if (!self.has(id)) return null;\n        return wrap(items[id]);\n    };\n    \n    self.add = function (fn, id) {\n        if (id == undefined) id = items.length;\n        items[id] = fn;\n        return id;\n    };\n    \n    self.cull = function (arg) {\n        if (typeof arg == 'function') {\n            arg = items.indexOf(arg);\n        }\n        delete items[arg];\n        return arg;\n    };\n    \n    self.indexOf = function (fn) {\n        return items.indexOf(fn);\n    };\n    \n    function wrap (fn) {\n        return function() {\n            fn.apply(this, arguments);\n            autoCull(fn);\n        };\n    }\n    \n    function autoCull (fn) {\n        if (typeof fn.times == 'number') {\n            fn.times--;\n            if (fn.times == 0) {\n                var id = self.cull(fn);\n                self.emit('cull', id);\n            }\n        }\n    }\n    \n    return self;\n};\n\nvar parseArgs = exports.parseArgs = function (argv) {\n    var params = {};\n    \n    [].slice.call(argv).forEach(function (arg) {\n        if (typeof arg === 'string') {\n            if (arg.match(/^\\d+$/)) {\n                params.port = parseInt(arg, 10);\n            }\n            else if (arg.match('^/')) {\n                params.path = arg;\n            }\n            else {\n                params.host = arg;\n            }\n        }\n        else if (typeof arg === 'number') {\n            params.port = arg;\n        }\n        else if (typeof arg === 'function') {\n            params.block = arg;\n        }\n        else if (typeof arg === 'object') {\n            if (arg.__proto__ === Object.prototype) {\n                // merge vanilla objects into params\n                Object.keys(arg).forEach(function (key) {\n                    params[key] = key === 'port'\n                        ? parseInt(arg[key], 10)\n                        : arg[key]\n                    ;\n                });\n            }\n            else if (stream.Stream && arg instanceof stream.Stream) {\n                params.stream = arg;\n            }\n            else {\n                // and non-Stream, non-vanilla objects are probably servers\n                params.server = arg;\n            }\n        }\n        else if (typeof arg === 'undefined') {\n            // ignore\n        }\n        else {\n            throw new Error('Not sure what to do about '\n                + typeof arg + ' objects');\n        }\n    });\n    \n    return params;\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/index.js"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./index\"}\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/package.json"
));

require.define("/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var traverse = module.exports = function (obj) {\n    return new Traverse(obj);\n};\n\nfunction Traverse (obj) {\n    this.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) {\n            node = undefined;\n            break;\n        }\n        node = node[key];\n    }\n    return node;\n};\n\nTraverse.prototype.has = function (ps) {\n    var node = this.value;\n    for (var i = 0; i < ps.length; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) {\n            return false;\n        }\n        node = node[key];\n    }\n    return true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n    var node = this.value;\n    for (var i = 0; i < ps.length - 1; i ++) {\n        var key = ps[i];\n        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};\n        node = node[key];\n    }\n    node[ps[i]] = value;\n    return value;\n};\n\nTraverse.prototype.map = function (cb) {\n    return walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n    this.value = walk(this.value, cb, false);\n    return this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n    var skip = arguments.length === 1;\n    var acc = skip ? this.value : init;\n    this.forEach(function (x) {\n        if (!this.isRoot || !skip) {\n            acc = cb.call(this, acc, x);\n        }\n    });\n    return acc;\n};\n\nTraverse.prototype.paths = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.path); \n    });\n    return acc;\n};\n\nTraverse.prototype.nodes = function () {\n    var acc = [];\n    this.forEach(function (x) {\n        acc.push(this.node);\n    });\n    return acc;\n};\n\nTraverse.prototype.clone = function () {\n    var parents = [], nodes = [];\n    \n    return (function clone (src) {\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[i] === src) {\n                return nodes[i];\n            }\n        }\n        \n        if (typeof src === 'object' && src !== null) {\n            var dst = copy(src);\n            \n            parents.push(src);\n            nodes.push(dst);\n            \n            forEach(Object_keys(src), function (key) {\n                dst[key] = clone(src[key]);\n            });\n            \n            parents.pop();\n            nodes.pop();\n            return dst;\n        }\n        else {\n            return src;\n        }\n    })(this.value);\n};\n\nfunction walk (root, cb, immutable) {\n    var path = [];\n    var parents = [];\n    var alive = true;\n    \n    return (function walker (node_) {\n        var node = immutable ? copy(node_) : node_;\n        var modifiers = {};\n        \n        var keepGoing = true;\n        \n        var state = {\n            node : node,\n            node_ : node_,\n            path : [].concat(path),\n            parent : parents[parents.length - 1],\n            parents : parents,\n            key : path.slice(-1)[0],\n            isRoot : path.length === 0,\n            level : path.length,\n            circular : null,\n            update : function (x, stopHere) {\n                if (!state.isRoot) {\n                    state.parent.node[state.key] = x;\n                }\n                state.node = x;\n                if (stopHere) keepGoing = false;\n            },\n            'delete' : function (stopHere) {\n                delete state.parent.node[state.key];\n                if (stopHere) keepGoing = false;\n            },\n            remove : function (stopHere) {\n                if (Array_isArray(state.parent.node)) {\n                    state.parent.node.splice(state.key, 1);\n                }\n                else {\n                    delete state.parent.node[state.key];\n                }\n                if (stopHere) keepGoing = false;\n            },\n            keys : null,\n            before : function (f) { modifiers.before = f },\n            after : function (f) { modifiers.after = f },\n            pre : function (f) { modifiers.pre = f },\n            post : function (f) { modifiers.post = f },\n            stop : function () { alive = false },\n            block : function () { keepGoing = false }\n        };\n        \n        if (!alive) return state;\n        \n        if (typeof node === 'object' && node !== null) {\n            state.keys = Object_keys(node);\n            \n            state.isLeaf = state.keys.length == 0;\n            \n            for (var i = 0; i < parents.length; i++) {\n                if (parents[i].node_ === node_) {\n                    state.circular = parents[i];\n                    break;\n                }\n            }\n        }\n        else {\n            state.isLeaf = true;\n        }\n        \n        state.notLeaf = !state.isLeaf;\n        state.notRoot = !state.isRoot;\n        \n        // use return values to update if defined\n        var ret = cb.call(state, state.node);\n        if (ret !== undefined && state.update) state.update(ret);\n        \n        if (modifiers.before) modifiers.before.call(state, state.node);\n        \n        if (!keepGoing) return state;\n        \n        if (typeof state.node == 'object'\n        && state.node !== null && !state.circular) {\n            parents.push(state);\n            \n            forEach(state.keys, function (key, i) {\n                path.push(key);\n                \n                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);\n                \n                var child = walker(state.node[key]);\n                if (immutable && Object.hasOwnProperty.call(state.node, key)) {\n                    state.node[key] = child.node;\n                }\n                \n                child.isLast = i == state.keys.length - 1;\n                child.isFirst = i == 0;\n                \n                if (modifiers.post) modifiers.post.call(state, child);\n                \n                path.pop();\n            });\n            parents.pop();\n        }\n        \n        if (modifiers.after) modifiers.after.call(state, state.node);\n        \n        return state;\n    })(root).node;\n}\n\nfunction copy (src) {\n    if (typeof src === 'object' && src !== null) {\n        var dst;\n        \n        if (Array_isArray(src)) {\n            dst = [];\n        }\n        else if (isDate(src)) {\n            dst = new Date(src);\n        }\n        else if (isRegExp(src)) {\n            dst = new RegExp(src);\n        }\n        else if (isError(src)) {\n            dst = { message: src.message };\n        }\n        else if (isBoolean(src)) {\n            dst = new Boolean(src);\n        }\n        else if (isNumber(src)) {\n            dst = new Number(src);\n        }\n        else if (isString(src)) {\n            dst = new String(src);\n        }\n        else if (Object.create && Object.getPrototypeOf) {\n            dst = Object.create(Object.getPrototypeOf(src));\n        }\n        else if (src.__proto__ || src.constructor.prototype) {\n            var proto = src.__proto__ || src.constructor.prototype || {};\n            var T = function () {};\n            T.prototype = proto;\n            dst = new T;\n            if (!dst.__proto__) dst.__proto__ = proto;\n        }\n        \n        forEach(Object_keys(src), function (key) {\n            dst[key] = src[key];\n        });\n        return dst;\n    }\n    else return src;\n}\n\nvar Object_keys = Object.keys || function keys (obj) {\n    var res = [];\n    for (var key in obj) res.push(key)\n    return res;\n};\n\nfunction toS (obj) { return Object.prototype.toString.call(obj) }\nfunction isDate (obj) { return toS(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toS(obj) === '[object RegExp]' }\nfunction isError (obj) { return toS(obj) === '[object Error]' }\nfunction isBoolean (obj) { return toS(obj) === '[object Boolean]' }\nfunction isNumber (obj) { return toS(obj) === '[object Number]' }\nfunction isString (obj) { return toS(obj) === '[object String]' }\n\nvar Array_isArray = Array.isArray || function isArray (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nforEach(Object_keys(Traverse.prototype), function (key) {\n    traverse[key] = function (obj) {\n        var args = [].slice.call(arguments, 1);\n        var t = new Traverse(obj);\n        return t[key].apply(t, args);\n    };\n});\n\n//@ sourceURL=/node_modules/dnode/node_modules/dnode-protocol/node_modules/traverse/index.js"
));

require.define("events", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("stream", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("util", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/dnode/node_modules/jsonify/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/package.json"
));

require.define("/node_modules/dnode/node_modules/jsonify/index.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/index.js"
));

require.define("/node_modules/dnode/node_modules/jsonify/lib/parse.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/lib/parse.js"
));

require.define("/node_modules/dnode/node_modules/jsonify/lib/stringify.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n\n//@ sourceURL=/node_modules/dnode/node_modules/jsonify/lib/stringify.js"
));

require.define("/node_modules/dnode/node_modules/socket.io-client/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/io.js\",\"browserify\":\"./dist/browserify.js\"}\n//@ sourceURL=/node_modules/dnode/node_modules/socket.io-client/package.json"
));

require.define("/node_modules/dnode/node_modules/socket.io-client/dist/browserify.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function () {var io = module.exports;/*! Socket.IO.js build:0.8.6, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * IO namespace.\n   *\n   * @namespace\n   */\n\n  var io = exports;\n\n  /**\n   * Socket.IO version\n   *\n   * @api public\n   */\n\n  io.version = '0.8.6';\n\n  /**\n   * Protocol implemented.\n   *\n   * @api public\n   */\n\n  io.protocol = 1;\n\n  /**\n   * Available transports, these will be populated with the available transports\n   *\n   * @api public\n   */\n\n  io.transports = [];\n\n  /**\n   * Keep track of jsonp callbacks.\n   *\n   * @api private\n   */\n\n  io.j = [];\n\n  /**\n   * Keep track of our io.Sockets\n   *\n   * @api private\n   */\n  io.sockets = {};\n\n\n  /**\n   * Manages connections to hosts.\n   *\n   * @param {String} uri\n   * @Param {Boolean} force creation of new socket (defaults to false)\n   * @api public\n   */\n\n  io.connect = function (host, details) {\n    var uri = io.util.parseUri(host)\n      , uuri\n      , socket;\n\n    if (global && global.location) {\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\n      uri.host = uri.host || (global.document\n        ? global.document.domain : global.location.hostname);\n      uri.port = uri.port || global.location.port;\n    }\n\n    uuri = io.util.uniqueUri(uri);\n\n    var options = {\n        host: uri.host\n      , secure: 'https' == uri.protocol\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\n      , query: uri.query || ''\n    };\n\n    io.util.merge(options, details);\n\n    if (options['force new connection'] || !io.sockets[uuri]) {\n      socket = new io.Socket(options);\n    }\n\n    if (!options['force new connection'] && socket) {\n      io.sockets[uuri] = socket;\n    }\n\n    socket = socket || io.sockets[uuri];\n\n    // if path is different from '' or /\n    return socket.of(uri.path.length > 1 ? uri.path : '');\n  };\n\n})('object' === typeof module ? module.exports : (this.io = {}), this);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, global) {\n\n  /**\n   * Utilities namespace.\n   *\n   * @namespace\n   */\n\n  var util = exports.util = {};\n\n  /**\n   * Parses an URI\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api public\n   */\n\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\n               'anchor'];\n\n  util.parseUri = function (str) {\n    var m = re.exec(str || '')\n      , uri = {}\n      , i = 14;\n\n    while (i--) {\n      uri[parts[i]] = m[i] || '';\n    }\n\n    return uri;\n  };\n\n  /**\n   * Produces a unique url that identifies a Socket.IO connection.\n   *\n   * @param {Object} uri\n   * @api public\n   */\n\n  util.uniqueUri = function (uri) {\n    var protocol = uri.protocol\n      , host = uri.host\n      , port = uri.port;\n\n    if ('document' in global) {\n      host = host || document.domain;\n      port = port || (protocol == 'https'\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\n    } else {\n      host = host || 'localhost';\n\n      if (!port && protocol == 'https') {\n        port = 443;\n      }\n    }\n\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\n  };\n\n  /**\n   * Mergest 2 query strings in to once unique query string\n   *\n   * @param {String} base\n   * @param {String} addition\n   * @api public\n   */\n\n  util.query = function (base, addition) {\n    var query = util.chunkQuery(base || '')\n      , components = [];\n\n    util.merge(query, util.chunkQuery(addition || ''));\n    for (var part in query) {\n      if (query.hasOwnProperty(part)) {\n        components.push(part + '=' + query[part]);\n      }\n    }\n\n    return components.length ? '?' + components.join('&') : '';\n  };\n\n  /**\n   * Transforms a querystring in to an object\n   *\n   * @param {String} qs\n   * @api public\n   */\n\n  util.chunkQuery = function (qs) {\n    var query = {}\n      , params = qs.split('&')\n      , i = 0\n      , l = params.length\n      , kv;\n\n    for (; i < l; ++i) {\n      kv = params[i].split('=');\n      if (kv[0]) {\n        query[kv[0]] = decodeURIComponent(kv[1]);\n      }\n    }\n\n    return query;\n  };\n\n  /**\n   * Executes the given function when the page is loaded.\n   *\n   *     io.util.load(function () { console.log('page loaded'); });\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  var pageLoaded = false;\n\n  util.load = function (fn) {\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\n      return fn();\n    }\n\n    util.on(global, 'load', fn, false);\n  };\n\n  /**\n   * Adds an event.\n   *\n   * @api private\n   */\n\n  util.on = function (element, event, fn, capture) {\n    if (element.attachEvent) {\n      element.attachEvent('on' + event, fn);\n    } else if (element.addEventListener) {\n      element.addEventListener(event, fn, capture);\n    }\n  };\n\n  /**\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\n   *\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\n   * @api private\n   */\n\n  util.request = function (xdomain) {\n\n    if (xdomain && 'undefined' != typeof XDomainRequest) {\n      return new XDomainRequest();\n    }\n\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\n      return new XMLHttpRequest();\n    }\n\n    if (!xdomain) {\n      try {\n        return new ActiveXObject('Microsoft.XMLHTTP');\n      } catch(e) { }\n    }\n\n    return null;\n  };\n\n  /**\n   * XHR based transport constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  /**\n   * Change the internal pageLoaded value.\n   */\n\n  if ('undefined' != typeof window) {\n    util.load(function () {\n      pageLoaded = true;\n    });\n  }\n\n  /**\n   * Defers a function to ensure a spinner is not displayed by the browser\n   *\n   * @param {Function} fn\n   * @api public\n   */\n\n  util.defer = function (fn) {\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\n      return fn();\n    }\n\n    util.load(function () {\n      setTimeout(fn, 100);\n    });\n  };\n\n  /**\n   * Merges two objects.\n   *\n   * @api public\n   */\n  \n  util.merge = function merge (target, additional, deep, lastseen) {\n    var seen = lastseen || []\n      , depth = typeof deep == 'undefined' ? 2 : deep\n      , prop;\n\n    for (prop in additional) {\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\n        if (typeof target[prop] !== 'object' || !depth) {\n          target[prop] = additional[prop];\n          seen.push(additional[prop]);\n        } else {\n          util.merge(target[prop], additional[prop], depth - 1, seen);\n        }\n      }\n    }\n\n    return target;\n  };\n\n  /**\n   * Merges prototypes from objects\n   *\n   * @api public\n   */\n  \n  util.mixin = function (ctor, ctor2) {\n    util.merge(ctor.prototype, ctor2.prototype);\n  };\n\n  /**\n   * Shortcut for prototypical and static inheritance.\n   *\n   * @api private\n   */\n\n  util.inherit = function (ctor, ctor2) {\n    function f() {};\n    f.prototype = ctor2.prototype;\n    ctor.prototype = new f;\n  };\n\n  /**\n   * Checks if the given object is an Array.\n   *\n   *     io.util.isArray([]); // true\n   *     io.util.isArray({}); // false\n   *\n   * @param Object obj\n   * @api public\n   */\n\n  util.isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  /**\n   * Intersects values of two arrays into a third\n   *\n   * @api public\n   */\n\n  util.intersect = function (arr, arr2) {\n    var ret = []\n      , longest = arr.length > arr2.length ? arr : arr2\n      , shortest = arr.length > arr2.length ? arr2 : arr;\n\n    for (var i = 0, l = shortest.length; i < l; i++) {\n      if (~util.indexOf(longest, shortest[i]))\n        ret.push(shortest[i]);\n    }\n\n    return ret;\n  }\n\n  /**\n   * Array indexOf compatibility.\n   *\n   * @see bit.ly/a5Dxa2\n   * @api public\n   */\n\n  util.indexOf = function (arr, o, i) {\n    if (Array.prototype.indexOf) {\n      return Array.prototype.indexOf.call(arr, o, i);\n    }\n\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; \n         i < j && arr[i] !== o; i++) {}\n\n    return j <= i ? -1 : i;\n  };\n\n  /**\n   * Converts enumerables to array.\n   *\n   * @api public\n   */\n\n  util.toArray = function (enu) {\n    var arr = [];\n\n    for (var i = 0, l = enu.length; i < l; i++)\n      arr.push(enu[i]);\n\n    return arr;\n  };\n\n  /**\n   * UA / engines detection namespace.\n   *\n   * @namespace\n   */\n\n  util.ua = {};\n\n  /**\n   * Whether the UA supports CORS for XHR.\n   *\n   * @api public\n   */\n\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n    try {\n      var a = new XMLHttpRequest();\n    } catch (e) {\n      return false;\n    }\n\n    return a.withCredentials != undefined;\n  })();\n\n  /**\n   * Detect webkit.\n   *\n   * @api public\n   */\n\n  util.ua.webkit = 'undefined' != typeof navigator\n    && /webkit/i.test(navigator.userAgent);\n\n})('undefined' != typeof io ? io : module.exports, this);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.EventEmitter = EventEmitter;\n\n  /**\n   * Event emitter constructor.\n   *\n   * @api public.\n   */\n\n  function EventEmitter () {};\n\n  /**\n   * Adds a listener\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.on = function (name, fn) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = fn;\n    } else if (io.util.isArray(this.$events[name])) {\n      this.$events[name].push(fn);\n    } else {\n      this.$events[name] = [this.$events[name], fn];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  /**\n   * Adds a volatile listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.once = function (name, fn) {\n    var self = this;\n\n    function on () {\n      self.removeListener(name, on);\n      fn.apply(this, arguments);\n    };\n\n    on.listener = fn;\n    this.on(name, on);\n\n    return this;\n  };\n\n  /**\n   * Removes a listener.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeListener = function (name, fn) {\n    if (this.$events && this.$events[name]) {\n      var list = this.$events[name];\n\n      if (io.util.isArray(list)) {\n        var pos = -1;\n\n        for (var i = 0, l = list.length; i < l; i++) {\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n            pos = i;\n            break;\n          }\n        }\n\n        if (pos < 0) {\n          return this;\n        }\n\n        list.splice(pos, 1);\n\n        if (!list.length) {\n          delete this.$events[name];\n        }\n      } else if (list === fn || (list.listener && list.listener === fn)) {\n        delete this.$events[name];\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Removes all listeners for an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.removeAllListeners = function (name) {\n    // TODO: enable this when node 0.5 is stable\n    //if (name === undefined) {\n      //this.$events = {};\n      //return this;\n    //}\n\n    if (this.$events && this.$events[name]) {\n      this.$events[name] = null;\n    }\n\n    return this;\n  };\n\n  /**\n   * Gets all listeners for a certain event.\n   *\n   * @api publci\n   */\n\n  EventEmitter.prototype.listeners = function (name) {\n    if (!this.$events) {\n      this.$events = {};\n    }\n\n    if (!this.$events[name]) {\n      this.$events[name] = [];\n    }\n\n    if (!io.util.isArray(this.$events[name])) {\n      this.$events[name] = [this.$events[name]];\n    }\n\n    return this.$events[name];\n  };\n\n  /**\n   * Emits an event.\n   *\n   * @api public\n   */\n\n  EventEmitter.prototype.emit = function (name) {\n    if (!this.$events) {\n      return false;\n    }\n\n    var handler = this.$events[name];\n\n    if (!handler) {\n      return false;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if ('function' == typeof handler) {\n      handler.apply(this, args);\n    } else if (io.util.isArray(handler)) {\n      var listeners = handler.slice();\n\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].apply(this, args);\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Based on JSON2 (http://www.JSON.org/js.html).\n */\n\n(function (exports, nativeJSON) {\n  \"use strict\";\n\n  // use native JSON if it's available\n  if (nativeJSON && nativeJSON.parse){\n    return exports.JSON = {\n      parse: nativeJSON.parse\n    , stringify: nativeJSON.stringify\n    }\n  }\n\n  var JSON = exports.JSON = {};\n\n  function f(n) {\n      // Format integers to have at least two digits.\n      return n < 10 ? '0' + n : n;\n  }\n\n  function date(d, key) {\n    return isFinite(d.valueOf()) ?\n        d.getUTCFullYear()     + '-' +\n        f(d.getUTCMonth() + 1) + '-' +\n        f(d.getUTCDate())      + 'T' +\n        f(d.getUTCHours())     + ':' +\n        f(d.getUTCMinutes())   + ':' +\n        f(d.getUTCSeconds())   + 'Z' : null;\n  };\n\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = {    // table of character substitutions\n          '\\b': '\\\\b',\n          '\\t': '\\\\t',\n          '\\n': '\\\\n',\n          '\\f': '\\\\f',\n          '\\r': '\\\\r',\n          '\"' : '\\\\\"',\n          '\\\\': '\\\\\\\\'\n      },\n      rep;\n\n\n  function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n      escapable.lastIndex = 0;\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n          var c = meta[a];\n          return typeof c === 'string' ? c :\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + string + '\"';\n  }\n\n\n  function str(key, holder) {\n\n// Produce a string from holder[key].\n\n      var i,          // The loop counter.\n          k,          // The member key.\n          v,          // The member value.\n          length,\n          mind = gap,\n          partial,\n          value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n      if (value instanceof Date) {\n          value = date(key);\n      }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n      if (typeof rep === 'function') {\n          value = rep.call(holder, key, value);\n      }\n\n// What happens next depends on the value's type.\n\n      switch (typeof value) {\n      case 'string':\n          return quote(value);\n\n      case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n          return isFinite(value) ? String(value) : 'null';\n\n      case 'boolean':\n      case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n          return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n      case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n          if (!value) {\n              return 'null';\n          }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n          gap += indent;\n          partial = [];\n\n// Is the value an array?\n\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n              length = value.length;\n              for (i = 0; i < length; i += 1) {\n                  partial[i] = str(i, value) || 'null';\n              }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n              v = partial.length === 0 ? '[]' : gap ?\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                  '[' + partial.join(',') + ']';\n              gap = mind;\n              return v;\n          }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n          if (rep && typeof rep === 'object') {\n              length = rep.length;\n              for (i = 0; i < length; i += 1) {\n                  if (typeof rep[i] === 'string') {\n                      k = rep[i];\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = str(k, value);\n                      if (v) {\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                      }\n                  }\n              }\n          }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n          v = partial.length === 0 ? '{}' : gap ?\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n              '{' + partial.join(',') + '}';\n          gap = mind;\n          return v;\n      }\n  }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n  JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n      var i;\n      gap = '';\n      indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n      if (typeof space === 'number') {\n          for (i = 0; i < space; i += 1) {\n              indent += ' ';\n          }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n      } else if (typeof space === 'string') {\n          indent = space;\n      }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n      rep = replacer;\n      if (replacer && typeof replacer !== 'function' &&\n              (typeof replacer !== 'object' ||\n              typeof replacer.length !== 'number')) {\n          throw new Error('JSON.stringify');\n      }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n      return str('', {'': value});\n  };\n\n// If the JSON object does not yet have a parse method, give it one.\n\n  JSON.parse = function (text, reviver) {\n  // The parse method takes a text and an optional reviver function, and returns\n  // a JavaScript value if the text is a valid JSON text.\n\n      var j;\n\n      function walk(holder, key) {\n\n  // The walk method is used to recursively walk the resulting structure so\n  // that modifications can be made.\n\n          var k, v, value = holder[key];\n          if (value && typeof value === 'object') {\n              for (k in value) {\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\n                      v = walk(value, k);\n                      if (v !== undefined) {\n                          value[k] = v;\n                      } else {\n                          delete value[k];\n                      }\n                  }\n              }\n          }\n          return reviver.call(holder, key, value);\n      }\n\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n\n      text = String(text);\n      cx.lastIndex = 0;\n      if (cx.test(text)) {\n          text = text.replace(cx, function (a) {\n              return '\\\\u' +\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n          });\n      }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n      if (/^[\\],:{}\\s]*$/\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n  // In the third stage we use the eval function to compile the text into a\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\n  // in parens to eliminate the ambiguity.\n\n          j = eval('(' + text + ')');\n\n  // In the optional fourth stage, we recursively walk the new structure, passing\n  // each name/value pair to a reviver function for possible transformation.\n\n          return typeof reviver === 'function' ?\n              walk({'': j}, '') : j;\n      }\n\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\n\n      throw new SyntaxError('JSON.parse');\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , typeof JSON !== 'undefined' ? JSON : undefined\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Parser namespace.\n   *\n   * @namespace\n   */\n\n  var parser = exports.parser = {};\n\n  /**\n   * Packet types.\n   */\n\n  var packets = parser.packets = [\n      'disconnect'\n    , 'connect'\n    , 'heartbeat'\n    , 'message'\n    , 'json'\n    , 'event'\n    , 'ack'\n    , 'error'\n    , 'noop'\n  ];\n\n  /**\n   * Errors reasons.\n   */\n\n  var reasons = parser.reasons = [\n      'transport not supported'\n    , 'client not handshaken'\n    , 'unauthorized'\n  ];\n\n  /**\n   * Errors advice.\n   */\n\n  var advice = parser.advice = [\n      'reconnect'\n  ];\n\n  /**\n   * Shortcuts.\n   */\n\n  var JSON = io.JSON\n    , indexOf = io.util.indexOf;\n\n  /**\n   * Encodes a packet.\n   *\n   * @api private\n   */\n\n  parser.encodePacket = function (packet) {\n    var type = indexOf(packets, packet.type)\n      , id = packet.id || ''\n      , endpoint = packet.endpoint || ''\n      , ack = packet.ack\n      , data = null;\n\n    switch (packet.type) {\n      case 'error':\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\n\n        if (reason !== '' || adv !== '')\n          data = reason + (adv !== '' ? ('+' + adv) : '');\n\n        break;\n\n      case 'message':\n        if (packet.data !== '')\n          data = packet.data;\n        break;\n\n      case 'event':\n        var ev = { name: packet.name };\n\n        if (packet.args && packet.args.length) {\n          ev.args = packet.args;\n        }\n\n        data = JSON.stringify(ev);\n        break;\n\n      case 'json':\n        data = JSON.stringify(packet.data);\n        break;\n\n      case 'connect':\n        if (packet.qs)\n          data = packet.qs;\n        break;\n\n      case 'ack':\n        data = packet.ackId\n          + (packet.args && packet.args.length\n              ? '+' + JSON.stringify(packet.args) : '');\n        break;\n    }\n\n    // construct packet with required fragments\n    var encoded = [\n        type\n      , id + (ack == 'data' ? '+' : '')\n      , endpoint\n    ];\n\n    // data fragment is optional\n    if (data !== null && data !== undefined)\n      encoded.push(data);\n\n    return encoded.join(':');\n  };\n\n  /**\n   * Encodes multiple messages (payload).\n   *\n   * @param {Array} messages\n   * @api private\n   */\n\n  parser.encodePayload = function (packets) {\n    var decoded = '';\n\n    if (packets.length == 1)\n      return packets[0];\n\n    for (var i = 0, l = packets.length; i < l; i++) {\n      var packet = packets[i];\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\n    }\n\n    return decoded;\n  };\n\n  /**\n   * Decodes a packet\n   *\n   * @api private\n   */\n\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\n\n  parser.decodePacket = function (data) {\n    var pieces = data.match(regexp);\n\n    if (!pieces) return {};\n\n    var id = pieces[2] || ''\n      , data = pieces[5] || ''\n      , packet = {\n            type: packets[pieces[1]]\n          , endpoint: pieces[4] || ''\n        };\n\n    // whether we need to acknowledge the packet\n    if (id) {\n      packet.id = id;\n      if (pieces[3])\n        packet.ack = 'data';\n      else\n        packet.ack = true;\n    }\n\n    // handle different packet types\n    switch (packet.type) {\n      case 'error':\n        var pieces = data.split('+');\n        packet.reason = reasons[pieces[0]] || '';\n        packet.advice = advice[pieces[1]] || '';\n        break;\n\n      case 'message':\n        packet.data = data || '';\n        break;\n\n      case 'event':\n        try {\n          var opts = JSON.parse(data);\n          packet.name = opts.name;\n          packet.args = opts.args;\n        } catch (e) { }\n\n        packet.args = packet.args || [];\n        break;\n\n      case 'json':\n        try {\n          packet.data = JSON.parse(data);\n        } catch (e) { }\n        break;\n\n      case 'connect':\n        packet.qs = data || '';\n        break;\n\n      case 'ack':\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\n        if (pieces) {\n          packet.ackId = pieces[1];\n          packet.args = [];\n\n          if (pieces[3]) {\n            try {\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\n            } catch (e) { }\n          }\n        }\n        break;\n\n      case 'disconnect':\n      case 'heartbeat':\n        break;\n    };\n\n    return packet;\n  };\n\n  /**\n   * Decodes data payload. Detects multiple messages\n   *\n   * @return {Array} messages\n   * @api public\n   */\n\n  parser.decodePayload = function (data) {\n    // IE doesn't like data[i] for unicode chars, charAt works fine\n    if (data.charAt(0) == '\\ufffd') {\n      var ret = [];\n\n      for (var i = 1, length = ''; i < data.length; i++) {\n        if (data.charAt(i) == '\\ufffd') {\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\n          i += Number(length) + 1;\n          length = '';\n        } else {\n          length += data.charAt(i);\n        }\n      }\n\n      return ret;\n    } else {\n      return [parser.decodePacket(data)];\n    }\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Transport = Transport;\n\n  /**\n   * This is the transport template for all supported transport methods.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function Transport (socket, sessid) {\n    this.socket = socket;\n    this.sessid = sessid;\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Transport, io.EventEmitter);\n\n  /**\n   * Handles the response from the server. When a new response is received\n   * it will automatically update the timeout, decode the message and\n   * forwards the response to the onMessage function for further processing.\n   *\n   * @param {String} data Response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onData = function (data) {\n    this.clearCloseTimeout();\n    \n    // If the connection in currently open (or in a reopening state) reset the close \n    // timeout since we have just received data. This check is necessary so\n    // that we don't reset the timeout on an explicitly disconnected connection.\n    if (this.connected || this.connecting || this.reconnecting) {\n      this.setCloseTimeout();\n    }\n\n    if (data !== '') {\n      // todo: we should only do decodePayload for xhr transports\n      var msgs = io.parser.decodePayload(data);\n\n      if (msgs && msgs.length) {\n        for (var i = 0, l = msgs.length; i < l; i++) {\n          this.onPacket(msgs[i]);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles packets.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onPacket = function (packet) {\n    if (packet.type == 'heartbeat') {\n      return this.onHeartbeat();\n    }\n\n    if (packet.type == 'connect' && packet.endpoint == '') {\n      this.onConnect();\n    }\n\n    this.socket.onPacket(packet);\n\n    return this;\n  };\n\n  /**\n   * Sets close timeout\n   *\n   * @api private\n   */\n  \n  Transport.prototype.setCloseTimeout = function () {\n    if (!this.closeTimeout) {\n      var self = this;\n\n      this.closeTimeout = setTimeout(function () {\n        self.onDisconnect();\n      }, this.socket.closeTimeout);\n    }\n  };\n\n  /**\n   * Called when transport disconnects.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onDisconnect = function () {\n    if (this.close && this.open) this.close();\n    this.clearTimeouts();\n    this.socket.onDisconnect();\n    return this;\n  };\n\n  /**\n   * Called when transport connects\n   *\n   * @api private\n   */\n\n  Transport.prototype.onConnect = function () {\n    this.socket.onConnect();\n    return this;\n  }\n\n  /**\n   * Clears close timeout\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearCloseTimeout = function () {\n    if (this.closeTimeout) {\n      clearTimeout(this.closeTimeout);\n      this.closeTimeout = null;\n    }\n  };\n\n  /**\n   * Clear timeouts\n   *\n   * @api private\n   */\n\n  Transport.prototype.clearTimeouts = function () {\n    this.clearCloseTimeout();\n\n    if (this.reopenTimeout) {\n      clearTimeout(this.reopenTimeout);\n    }\n  };\n\n  /**\n   * Sends a packet\n   *\n   * @param {Object} packet object.\n   * @api private\n   */\n\n  Transport.prototype.packet = function (packet) {\n    this.send(io.parser.encodePacket(packet));\n  };\n\n  /**\n   * Send the received heartbeat message back to server. So the server\n   * knows we are still connected.\n   *\n   * @param {String} heartbeat Heartbeat response from the server.\n   * @api private\n   */\n\n  Transport.prototype.onHeartbeat = function (heartbeat) {\n    this.packet({ type: 'heartbeat' });\n  };\n \n  /**\n   * Called when the transport opens.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onOpen = function () {\n    this.open = true;\n    this.clearCloseTimeout();\n    this.socket.onOpen();\n  };\n\n  /**\n   * Notifies the base when the connection with the Socket.IO server\n   * has been disconnected.\n   *\n   * @api private\n   */\n\n  Transport.prototype.onClose = function () {\n    var self = this;\n\n    /* FIXME: reopen delay causing a infinit loop\n    this.reopenTimeout = setTimeout(function () {\n      self.open();\n    }, this.socket.options['reopen delay']);*/\n\n    this.open = false;\n    this.socket.onClose();\n    this.onDisconnect();\n  };\n\n  /**\n   * Generates a connection url based on the Socket.IO URL Protocol.\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\n   *\n   * @returns {String} Connection url\n   * @api private\n   */\n\n  Transport.prototype.prepareUrl = function () {\n    var options = this.socket.options;\n\n    return this.scheme() + '://'\n      + options.host + ':' + options.port + '/'\n      + options.resource + '/' + io.protocol\n      + '/' + this.name + '/' + this.sessid;\n  };\n\n  /**\n   * Checks if the transport is ready to start a connection.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Transport.prototype.ready = function (socket, fn) {\n    fn.call(this);\n  };\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.Socket = Socket;\n\n  /**\n   * Create a new `Socket.IO client` which can establish a persistent\n   * connection with a Socket.IO enabled server.\n   *\n   * @api public\n   */\n\n  function Socket (options) {\n    this.options = {\n        port: 80\n      , secure: false\n      , document: 'document' in global ? document : false\n      , resource: 'socket.io'\n      , transports: io.transports\n      , 'connect timeout': 10000\n      , 'try multiple transports': true\n      , 'reconnect': true\n      , 'reconnection delay': 500\n      , 'reconnection limit': Infinity\n      , 'reopen delay': 3000\n      , 'max reconnection attempts': 10\n      , 'sync disconnect on unload': true\n      , 'auto connect': true\n      , 'flash policy port': 10843\n    };\n\n    io.util.merge(this.options, options);\n\n    this.connected = false;\n    this.open = false;\n    this.connecting = false;\n    this.reconnecting = false;\n    this.namespaces = {};\n    this.buffer = [];\n    this.doBuffer = false;\n\n    if (this.options['sync disconnect on unload'] &&\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\n      var self = this;\n\n      io.util.on(global, 'beforeunload', function () {\n        self.disconnectSync();\n      }, false);\n    }\n\n    if (this.options['auto connect']) {\n      this.connect();\n    }\n};\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(Socket, io.EventEmitter);\n\n  /**\n   * Returns a namespace listener/emitter for this socket\n   *\n   * @api public\n   */\n\n  Socket.prototype.of = function (name) {\n    if (!this.namespaces[name]) {\n      this.namespaces[name] = new io.SocketNamespace(this, name);\n\n      if (name !== '') {\n        this.namespaces[name].packet({ type: 'connect' });\n      }\n    }\n\n    return this.namespaces[name];\n  };\n\n  /**\n   * Emits the given event to the Socket and all namespaces\n   *\n   * @api private\n   */\n\n  Socket.prototype.publish = function () {\n    this.emit.apply(this, arguments);\n\n    var nsp;\n\n    for (var i in this.namespaces) {\n      if (this.namespaces.hasOwnProperty(i)) {\n        nsp = this.of(i);\n        nsp.$emit.apply(nsp, arguments);\n      }\n    }\n  };\n\n  /**\n   * Performs the handshake\n   *\n   * @api private\n   */\n\n  function empty () { };\n\n  Socket.prototype.handshake = function (fn) {\n    var self = this\n      , options = this.options;\n\n    function complete (data) {\n      if (data instanceof Error) {\n        self.onError(data.message);\n      } else {\n        fn.apply(null, data.split(':'));\n      }\n    };\n\n    var url = [\n          'http' + (options.secure ? 's' : '') + ':/'\n        , options.host + ':' + options.port\n        , options.resource\n        , io.protocol\n        , io.util.query(this.options.query, 't=' + +new Date)\n      ].join('/');\n\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\n      var insertAt = document.getElementsByTagName('script')[0]\n        , script = document.createElement('script');\n\n      script.src = url + '&jsonp=' + io.j.length;\n      insertAt.parentNode.insertBefore(script, insertAt);\n\n      io.j.push(function (data) {\n        complete(data);\n        script.parentNode.removeChild(script);\n      });\n    } else {\n      var xhr = io.util.request();\n\n      xhr.open('GET', url, true);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          xhr.onreadystatechange = empty;\n\n          if (xhr.status == 200) {\n            complete(xhr.responseText);\n          } else {\n            !self.reconnecting && self.onError(xhr.responseText);\n          }\n        }\n      };\n      xhr.send(null);\n    }\n  };\n\n  /**\n   * Find an available transport based on the options supplied in the constructor.\n   *\n   * @api private\n   */\n\n  Socket.prototype.getTransport = function (override) {\n    var transports = override || this.transports, match;\n\n    for (var i = 0, transport; transport = transports[i]; i++) {\n      if (io.Transport[transport]\n        && io.Transport[transport].check(this)\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck())) {\n        return new io.Transport[transport](this, this.sessionid);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Connects to the server.\n   *\n   * @param {Function} [fn] Callback.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.connect = function (fn) {\n    if (this.connecting) {\n      return this;\n    }\n\n    var self = this;\n\n    this.handshake(function (sid, heartbeat, close, transports) {\n      self.sessionid = sid;\n      self.closeTimeout = close * 1000;\n      self.heartbeatTimeout = heartbeat * 1000;\n      self.transports = io.util.intersect(\n          transports.split(',')\n        , self.options.transports\n      );\n\n      function connect (transports){\n        if (self.transport) self.transport.clearTimeouts();\n\n        self.transport = self.getTransport(transports);\n        if (!self.transport) return self.publish('connect_failed');\n\n        // once the transport is ready\n        self.transport.ready(self, function () {\n          self.connecting = true;\n          self.publish('connecting', self.transport.name);\n          self.transport.open();\n\n          if (self.options['connect timeout']) {\n            self.connectTimeoutTimer = setTimeout(function () {\n              if (!self.connected) {\n                self.connecting = false;\n\n                if (self.options['try multiple transports']) {\n                  if (!self.remainingTransports) {\n                    self.remainingTransports = self.transports.slice(0);\n                  }\n\n                  var remaining = self.remainingTransports;\n\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\n                         self.transport.name) {}\n\n                    if (remaining.length){\n                      connect(remaining);\n                    } else {\n                      self.publish('connect_failed');\n                    }\n                }\n              }\n            }, self.options['connect timeout']);\n          }\n        });\n      }\n\n      connect();\n\n      self.once('connect', function (){\n        clearTimeout(self.connectTimeoutTimer);\n\n        fn && typeof fn == 'function' && fn();\n      });\n    });\n\n    return this;\n  };\n\n  /**\n   * Sends a message.\n   *\n   * @param {Object} data packet.\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.packet = function (data) {\n    if (this.connected && !this.doBuffer) {\n      this.transport.packet(data);\n    } else {\n      this.buffer.push(data);\n    }\n\n    return this;\n  };\n\n  /**\n   * Sets buffer state\n   *\n   * @api private\n   */\n\n  Socket.prototype.setBuffer = function (v) {\n    this.doBuffer = v;\n\n    if (!v && this.connected && this.buffer.length) {\n      this.transport.payload(this.buffer);\n      this.buffer = [];\n    }\n  };\n\n  /**\n   * Disconnect the established connect.\n   *\n   * @returns {io.Socket}\n   * @api public\n   */\n\n  Socket.prototype.disconnect = function () {\n    if (this.connected) {\n      if (this.open) {\n        this.of('').packet({ type: 'disconnect' });\n      }\n\n      // handle disconnection immediately\n      this.onDisconnect('booted');\n    }\n\n    return this;\n  };\n\n  /**\n   * Disconnects the socket with a sync XHR.\n   *\n   * @api private\n   */\n\n  Socket.prototype.disconnectSync = function () {\n    // ensure disconnection\n    var xhr = io.util.request()\n      , uri = this.resource + '/' + io.protocol + '/' + this.sessionid;\n\n    xhr.open('GET', uri, true);\n\n    // handle disconnection immediately\n    this.onDisconnect('booted');\n  };\n\n  /**\n   * Check if we need to use cross domain enabled transports. Cross domain would\n   * be a different port or different domain name.\n   *\n   * @returns {Boolean}\n   * @api private\n   */\n\n  Socket.prototype.isXDomain = function () {\n\n    var port = global.location.port ||\n      ('https:' == global.location.protocol ? 443 : 80);\n\n    return this.options.host !== global.location.hostname \n      || this.options.port != port;\n  };\n\n  /**\n   * Called upon handshake.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onConnect = function () {\n    if (!this.connected) {\n      this.connected = true;\n      this.connecting = false;\n      if (!this.doBuffer) {\n        // make sure to flush the buffer\n        this.setBuffer(false);\n      }\n      this.emit('connect');\n    }\n  };\n\n  /**\n   * Called when the transport opens\n   *\n   * @api private\n   */\n\n  Socket.prototype.onOpen = function () {\n    this.open = true;\n  };\n\n  /**\n   * Called when the transport closes.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onClose = function () {\n    this.open = false;\n  };\n\n  /**\n   * Called when the transport first opens a connection\n   *\n   * @param text\n   */\n\n  Socket.prototype.onPacket = function (packet) {\n    this.of(packet.endpoint).onPacket(packet);\n  };\n\n  /**\n   * Handles an error.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onError = function (err) {\n    if (err && err.advice) {\n      if (err.advice === 'reconnect' && this.connected) {\n        this.disconnect();\n        this.reconnect();\n      }\n    }\n\n    this.publish('error', err && err.reason ? err.reason : err);\n  };\n\n  /**\n   * Called when the transport disconnects.\n   *\n   * @api private\n   */\n\n  Socket.prototype.onDisconnect = function (reason) {\n    var wasConnected = this.connected;\n\n    this.connected = false;\n    this.connecting = false;\n    this.open = false;\n\n    if (wasConnected) {\n      this.transport.close();\n      this.transport.clearTimeouts();\n      this.publish('disconnect', reason);\n\n      if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\n        this.reconnect();\n      }\n    }\n  };\n\n  /**\n   * Called upon reconnection.\n   *\n   * @api private\n   */\n\n  Socket.prototype.reconnect = function () {\n    this.reconnecting = true;\n    this.reconnectionAttempts = 0;\n    this.reconnectionDelay = this.options['reconnection delay'];\n\n    var self = this\n      , maxAttempts = this.options['max reconnection attempts']\n      , tryMultiple = this.options['try multiple transports']\n      , limit = this.options['reconnection limit'];\n\n    function reset () {\n      if (self.connected) {\n        for (var i in self.namespaces) {\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\n              self.namespaces[i].packet({ type: 'connect' });\n          }\n        }\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\n      }\n\n      self.removeListener('connect_failed', maybeReconnect);\n      self.removeListener('connect', maybeReconnect);\n\n      self.reconnecting = false;\n\n      delete self.reconnectionAttempts;\n      delete self.reconnectionDelay;\n      delete self.reconnectionTimer;\n      delete self.redoTransports;\n\n      self.options['try multiple transports'] = tryMultiple;\n    };\n\n    function maybeReconnect () {\n      if (!self.reconnecting) {\n        return;\n      }\n\n      if (self.connected) {\n        return reset();\n      };\n\n      if (self.connecting && self.reconnecting) {\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\n      }\n\n      if (self.reconnectionAttempts++ >= maxAttempts) {\n        if (!self.redoTransports) {\n          self.on('connect_failed', maybeReconnect);\n          self.options['try multiple transports'] = true;\n          self.transport = self.getTransport();\n          self.redoTransports = true;\n          self.connect();\n        } else {\n          self.publish('reconnect_failed');\n          reset();\n        }\n      } else {\n        if (self.reconnectionDelay < limit) {\n          self.reconnectionDelay *= 2; // exponential back off\n        }\n\n        self.connect();\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\n      }\n    };\n\n    this.options['try multiple transports'] = false;\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\n\n    this.on('connect', maybeReconnect);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.SocketNamespace = SocketNamespace;\n\n  /**\n   * Socket namespace constructor.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function SocketNamespace (socket, name) {\n    this.socket = socket;\n    this.name = name || '';\n    this.flags = {};\n    this.json = new Flag(this, 'json');\n    this.ackPackets = 0;\n    this.acks = {};\n  };\n\n  /**\n   * Apply EventEmitter mixin.\n   */\n\n  io.util.mixin(SocketNamespace, io.EventEmitter);\n\n  /**\n   * Copies emit since we override it\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\n\n  /**\n   * Creates a new namespace, by proxying the request to the socket. This\n   * allows us to use the synax as we do on the server.\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.of = function () {\n    return this.socket.of.apply(this.socket, arguments);\n  };\n\n  /**\n   * Sends a packet.\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.packet = function (packet) {\n    packet.endpoint = this.name;\n    this.socket.packet(packet);\n    this.flags = {};\n    return this;\n  };\n\n  /**\n   * Sends a message\n   *\n   * @api public\n   */\n\n  SocketNamespace.prototype.send = function (data, fn) {\n    var packet = {\n        type: this.flags.json ? 'json' : 'message'\n      , data: data\n    };\n\n    if ('function' == typeof fn) {\n      packet.id = ++this.ackPackets;\n      packet.ack = true;\n      this.acks[packet.id] = fn;\n    }\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Emits an event\n   *\n   * @api public\n   */\n  \n  SocketNamespace.prototype.emit = function (name) {\n    var args = Array.prototype.slice.call(arguments, 1)\n      , lastArg = args[args.length - 1]\n      , packet = {\n            type: 'event'\n          , name: name\n        };\n\n    if ('function' == typeof lastArg) {\n      packet.id = ++this.ackPackets;\n      packet.ack = 'data';\n      this.acks[packet.id] = lastArg;\n      args = args.slice(0, args.length - 1);\n    }\n\n    packet.args = args;\n\n    return this.packet(packet);\n  };\n\n  /**\n   * Disconnects the namespace\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.disconnect = function () {\n    if (this.name === '') {\n      this.socket.disconnect();\n    } else {\n      this.packet({ type: 'disconnect' });\n      this.$emit('disconnect');\n    }\n\n    return this;\n  };\n\n  /**\n   * Handles a packet\n   *\n   * @api private\n   */\n\n  SocketNamespace.prototype.onPacket = function (packet) {\n    var self = this;\n\n    function ack () {\n      self.packet({\n          type: 'ack'\n        , args: io.util.toArray(arguments)\n        , ackId: packet.id\n      });\n    };\n\n    switch (packet.type) {\n      case 'connect':\n        this.$emit('connect');\n        break;\n\n      case 'disconnect':\n        if (this.name === '') {\n          this.socket.onDisconnect(packet.reason || 'booted');\n        } else {\n          this.$emit('disconnect', packet.reason);\n        }\n        break;\n\n      case 'message':\n      case 'json':\n        var params = ['message', packet.data];\n\n        if (packet.ack == 'data') {\n          params.push(ack);\n        } else if (packet.ack) {\n          this.packet({ type: 'ack', ackId: packet.id });\n        }\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'event':\n        var params = [packet.name].concat(packet.args);\n\n        if (packet.ack == 'data')\n          params.push(ack);\n\n        this.$emit.apply(this, params);\n        break;\n\n      case 'ack':\n        if (this.acks[packet.ackId]) {\n          this.acks[packet.ackId].apply(this, packet.args);\n          delete this.acks[packet.ackId];\n        }\n        break;\n\n      case 'error':\n        if (packet.advice){\n          this.socket.onError(packet);\n        } else {\n          if (packet.reason == 'unauthorized') {\n            this.$emit('connect_failed', packet.reason);\n          } else {\n            this.$emit('error', packet.reason);\n          }\n        }\n        break;\n    }\n  };\n\n  /**\n   * Flag interface.\n   *\n   * @api private\n   */\n\n  function Flag (nsp, name) {\n    this.namespace = nsp;\n    this.name = name;\n  };\n\n  /**\n   * Send a message\n   *\n   * @api public\n   */\n\n  Flag.prototype.send = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.send.apply(this.namespace, arguments);\n  };\n\n  /**\n   * Emit an event\n   *\n   * @api public\n   */\n\n  Flag.prototype.emit = function () {\n    this.namespace.flags[this.name] = true;\n    this.namespace.emit.apply(this.namespace, arguments);\n  };\n\n})(\n    'undefined' != typeof io ? io : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.websocket = WS;\n\n  /**\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\n   * persistent connection with the Socket.IO server. This transport will also\n   * be inherited by the FlashSocket fallback as it provides a API compatible\n   * polyfill for the WebSockets.\n   *\n   * @constructor\n   * @extends {io.Transport}\n   * @api public\n   */\n\n  function WS (socket) {\n    io.Transport.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(WS, io.Transport);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  WS.prototype.name = 'websocket';\n\n  /**\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\n   * all the appropriate listeners to handle the responses from the server.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.open = function () {\n    var query = io.util.query(this.socket.options.query)\n      , self = this\n      , Socket\n\n\n    if (!Socket) {\n      Socket = global.MozWebSocket || global.WebSocket;\n    }\n\n    this.websocket = new Socket(this.prepareUrl() + query);\n\n    this.websocket.onopen = function () {\n      self.onOpen();\n      self.socket.setBuffer(false);\n    };\n    this.websocket.onmessage = function (ev) {\n      self.onData(ev.data);\n    };\n    this.websocket.onclose = function () {\n      self.onClose();\n      self.socket.setBuffer(true);\n    };\n    this.websocket.onerror = function (e) {\n      self.onError(e);\n    };\n\n    return this;\n  };\n\n  /**\n   * Send a message to the Socket.IO server. The message will automatically be\n   * encoded in the correct message format.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.send = function (data) {\n    this.websocket.send(data);\n    return this;\n  };\n\n  /**\n   * Payload\n   *\n   * @api private\n   */\n\n  WS.prototype.payload = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      this.packet(arr[i]);\n    }\n    return this;\n  };\n\n  /**\n   * Disconnect the established `WebSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  WS.prototype.close = function () {\n    this.websocket.close();\n    return this;\n  };\n\n  /**\n   * Handle the errors that `WebSocket` might be giving when we\n   * are attempting to connect or send messages.\n   *\n   * @param {Error} e The error.\n   * @api private\n   */\n\n  WS.prototype.onError = function (e) {\n    this.socket.onError(e);\n  };\n\n  /**\n   * Returns the appropriate scheme for the URI generation.\n   *\n   * @api private\n   */\n  WS.prototype.scheme = function () {\n    return this.socket.options.secure ? 'wss' : 'ws';\n  };\n\n  /**\n   * Checks if the browser has support for native `WebSockets` and that\n   * it's not the polyfill created for the FlashSocket transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  WS.check = function () {\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\n          || 'MozWebSocket' in global;\n  };\n\n  /**\n   * Check if the `WebSocket` transport support cross domain communications.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  WS.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('websocket');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.flashsocket = Flashsocket;\n\n  /**\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\n   * specification. It uses a .swf file to communicate with the server. If you want\n   * to serve the .swf file from a other server than where the Socket.IO script is\n   * coming from you need to use the insecure version of the .swf. More information\n   * about this can be found on the github page.\n   *\n   * @constructor\n   * @extends {io.Transport.websocket}\n   * @api public\n   */\n\n  function Flashsocket () {\n    io.Transport.websocket.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(Flashsocket, io.Transport.websocket);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  Flashsocket.prototype.name = 'flashsocket';\n\n  /**\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.open = function () {\n    var self = this\n      , args = arguments;\n\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.open.apply(self, args);\n    });\n    return this;\n  };\n  \n  /**\n   * Sends a message to the Socket.IO server. This is done by adding a new\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \n   * transport.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.send = function () {\n    var self = this, args = arguments;\n    WebSocket.__addTask(function () {\n      io.Transport.websocket.prototype.send.apply(self, args);\n    });\n    return this;\n  };\n\n  /**\n   * Disconnects the established `FlashSocket` connection.\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  Flashsocket.prototype.close = function () {\n    WebSocket.__tasks.length = 0;\n    io.Transport.websocket.prototype.close.call(this);\n    return this;\n  };\n\n  /**\n   * The WebSocket fall back needs to append the flash container to the body\n   * element, so we need to make sure we have access to it. Or defer the call\n   * until we are sure there is a body element.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  Flashsocket.prototype.ready = function (socket, fn) {\n    function init () {\n      var options = socket.options\n        , port = options['flash policy port']\n        , path = [\n              'http' + (options.secure ? 's' : '') + ':/'\n            , options.host + ':' + options.port\n            , options.resource\n            , 'static/flashsocket'\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\n          ];\n\n      // Only start downloading the swf file when the checked that this browser\n      // actually supports it\n      if (!Flashsocket.loaded) {\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\n          // Set the correct file based on the XDomain settings\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\n        }\n\n        if (port !== 843) {\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\n        }\n\n        WebSocket.__initialize();\n        Flashsocket.loaded = true;\n      }\n\n      fn.call(self);\n    }\n\n    var self = this;\n    if (document.body) return init();\n\n    io.util.load(init);\n  };\n\n  /**\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\n   * the polyfill is correctly loaded.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.check = function () {\n    if (\n        typeof WebSocket == 'undefined'\n      || !('__initialize' in WebSocket) || !swfobject\n    ) return false;\n\n    return swfobject.getFlashPlayerVersion().major >= 10;\n  };\n\n  /**\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \n   * transport. Because we can't see which type (secure or insecure) of .swf is used\n   * we will just return true.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  Flashsocket.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Disable AUTO_INITIALIZATION\n   */\n\n  if (typeof window != 'undefined') {\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n  }\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('flashsocket');\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \n\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \n*/\nif ('undefined' != typeof window) {\nvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O.ActiveXObject!=D){try{var ad=new ActiveXObject(W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?\"ActiveX\":\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\n}\n// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\n// License: New BSD License\n// Reference: http://dev.w3.org/html5/websockets/\n// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\n\n(function() {\n  \n  if ('undefined' == typeof window || window.WebSocket) return;\n\n  var console = window.console;\n  if (!console || !console.log || !console.error) {\n    console = {log: function(){ }, error: function(){ }};\n  }\n  \n  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\n    console.error(\"Flash Player >= 10.0.0 is required.\");\n    return;\n  }\n  if (location.protocol == \"file:\") {\n    console.error(\n      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\n      \"unless you set Flash Security Settings properly. \" +\n      \"Open the page via Web server i.e. http://...\");\n  }\n\n  /**\n   * This class represents a faux web socket.\n   * @param {string} url\n   * @param {array or string} protocols\n   * @param {string} proxyHost\n   * @param {int} proxyPort\n   * @param {string} headers\n   */\n  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\n    var self = this;\n    self.__id = WebSocket.__nextId++;\n    WebSocket.__instances[self.__id] = self;\n    self.readyState = WebSocket.CONNECTING;\n    self.bufferedAmount = 0;\n    self.__events = {};\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols == \"string\") {\n      protocols = [protocols];\n    }\n    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\n    // Otherwise, when onopen fires immediately, onopen is called before it is set.\n    setTimeout(function() {\n      WebSocket.__addTask(function() {\n        WebSocket.__flash.create(\n            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\n      });\n    }, 0);\n  };\n\n  /**\n   * Send data to the web socket.\n   * @param {string} data  The data to send to the socket.\n   * @return {boolean}  True for success, false for failure.\n   */\n  WebSocket.prototype.send = function(data) {\n    if (this.readyState == WebSocket.CONNECTING) {\n      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\n    }\n    // We use encodeURIComponent() here, because FABridge doesn't work if\n    // the argument includes some characters. We don't use escape() here\n    // because of this:\n    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\n    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\n    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\n    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\n    // additional testing.\n    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\n    if (result < 0) { // success\n      return true;\n    } else {\n      this.bufferedAmount += result;\n      return false;\n    }\n  };\n\n  /**\n   * Close this web socket gracefully.\n   */\n  WebSocket.prototype.close = function() {\n    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\n      return;\n    }\n    this.readyState = WebSocket.CLOSING;\n    WebSocket.__flash.close(this.__id);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) {\n      this.__events[type] = [];\n    }\n    this.__events[type].push(listener);\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {boolean} useCapture\n   * @return void\n   */\n  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\n    if (!(type in this.__events)) return;\n    var events = this.__events[type];\n    for (var i = events.length - 1; i >= 0; --i) {\n      if (events[i] === listener) {\n        events.splice(i, 1);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\n   *\n   * @param {Event} event\n   * @return void\n   */\n  WebSocket.prototype.dispatchEvent = function(event) {\n    var events = this.__events[event.type] || [];\n    for (var i = 0; i < events.length; ++i) {\n      events[i](event);\n    }\n    var handler = this[\"on\" + event.type];\n    if (handler) handler(event);\n  };\n\n  /**\n   * Handles an event from Flash.\n   * @param {Object} flashEvent\n   */\n  WebSocket.prototype.__handleEvent = function(flashEvent) {\n    if (\"readyState\" in flashEvent) {\n      this.readyState = flashEvent.readyState;\n    }\n    if (\"protocol\" in flashEvent) {\n      this.protocol = flashEvent.protocol;\n    }\n    \n    var jsEvent;\n    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\n      jsEvent = this.__createSimpleEvent(flashEvent.type);\n    } else if (flashEvent.type == \"close\") {\n      // TODO implement jsEvent.wasClean\n      jsEvent = this.__createSimpleEvent(\"close\");\n    } else if (flashEvent.type == \"message\") {\n      var data = decodeURIComponent(flashEvent.message);\n      jsEvent = this.__createMessageEvent(\"message\", data);\n    } else {\n      throw \"unknown event type: \" + flashEvent.type;\n    }\n    \n    this.dispatchEvent(jsEvent);\n  };\n  \n  WebSocket.prototype.__createSimpleEvent = function(type) {\n    if (document.createEvent && window.Event) {\n      var event = document.createEvent(\"Event\");\n      event.initEvent(type, false, false);\n      return event;\n    } else {\n      return {type: type, bubbles: false, cancelable: false};\n    }\n  };\n  \n  WebSocket.prototype.__createMessageEvent = function(type, data) {\n    if (document.createEvent && window.MessageEvent && !window.opera) {\n      var event = document.createEvent(\"MessageEvent\");\n      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\n      return event;\n    } else {\n      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\n      return {type: type, data: data, bubbles: false, cancelable: false};\n    }\n  };\n  \n  /**\n   * Define the WebSocket readyState enumeration.\n   */\n  WebSocket.CONNECTING = 0;\n  WebSocket.OPEN = 1;\n  WebSocket.CLOSING = 2;\n  WebSocket.CLOSED = 3;\n\n  WebSocket.__flash = null;\n  WebSocket.__instances = {};\n  WebSocket.__tasks = [];\n  WebSocket.__nextId = 0;\n  \n  /**\n   * Load a new flash security policy file.\n   * @param {string} url\n   */\n  WebSocket.loadFlashPolicyFile = function(url){\n    WebSocket.__addTask(function() {\n      WebSocket.__flash.loadManualPolicyFile(url);\n    });\n  };\n\n  /**\n   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\n   */\n  WebSocket.__initialize = function() {\n    if (WebSocket.__flash) return;\n    \n    if (WebSocket.__swfLocation) {\n      // For backword compatibility.\n      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\n    }\n    if (!window.WEB_SOCKET_SWF_LOCATION) {\n      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\n      return;\n    }\n    var container = document.createElement(\"div\");\n    container.id = \"webSocketContainer\";\n    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\n    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\n    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\n    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\n    // the best we can do as far as we know now.\n    container.style.position = \"absolute\";\n    if (WebSocket.__isFlashLite()) {\n      container.style.left = \"0px\";\n      container.style.top = \"0px\";\n    } else {\n      container.style.left = \"-100px\";\n      container.style.top = \"-100px\";\n    }\n    var holder = document.createElement(\"div\");\n    holder.id = \"webSocketFlash\";\n    container.appendChild(holder);\n    document.body.appendChild(container);\n    // See this article for hasPriority:\n    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\n    swfobject.embedSWF(\n      WEB_SOCKET_SWF_LOCATION,\n      \"webSocketFlash\",\n      \"1\" /* width */,\n      \"1\" /* height */,\n      \"10.0.0\" /* SWF version */,\n      null,\n      null,\n      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\n      null,\n      function(e) {\n        if (!e.success) {\n          console.error(\"[WebSocket] swfobject.embedSWF failed\");\n        }\n      });\n  };\n  \n  /**\n   * Called by Flash to notify JS that it's fully loaded and ready\n   * for communication.\n   */\n  WebSocket.__onFlashInitialized = function() {\n    // We need to set a timeout here to avoid round-trip calls\n    // to flash during the initialization process.\n    setTimeout(function() {\n      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\n      WebSocket.__flash.setCallerUrl(location.href);\n      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\n      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\n        WebSocket.__tasks[i]();\n      }\n      WebSocket.__tasks = [];\n    }, 0);\n  };\n  \n  /**\n   * Called by Flash to notify WebSockets events are fired.\n   */\n  WebSocket.__onFlashEvent = function() {\n    setTimeout(function() {\n      try {\n        // Gets events using receiveEvents() instead of getting it from event object\n        // of Flash event. This is to make sure to keep message order.\n        // It seems sometimes Flash events don't arrive in the same order as they are sent.\n        var events = WebSocket.__flash.receiveEvents();\n        for (var i = 0; i < events.length; ++i) {\n          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }, 0);\n    return true;\n  };\n  \n  // Called by Flash.\n  WebSocket.__log = function(message) {\n    console.log(decodeURIComponent(message));\n  };\n  \n  // Called by Flash.\n  WebSocket.__error = function(message) {\n    console.error(decodeURIComponent(message));\n  };\n  \n  WebSocket.__addTask = function(task) {\n    if (WebSocket.__flash) {\n      task();\n    } else {\n      WebSocket.__tasks.push(task);\n    }\n  };\n  \n  /**\n   * Test if the browser is running flash lite.\n   * @return {boolean} True if flash lite is running, false otherwise.\n   */\n  WebSocket.__isFlashLite = function() {\n    if (!window.navigator || !window.navigator.mimeTypes) {\n      return false;\n    }\n    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\n    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\n      return false;\n    }\n    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\n  };\n  \n  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", function(){\n        WebSocket.__initialize();\n      }, false);\n    } else {\n      window.attachEvent(\"onload\", function(){\n        WebSocket.__initialize();\n      });\n    }\n  }\n  \n})();\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   *\n   * @api public\n   */\n  \n  exports.XHR = XHR;\n\n  /**\n   * XHR constructor\n   *\n   * @costructor\n   * @api public\n   */\n\n  function XHR (socket) {\n    if (!socket) return;\n\n    io.Transport.apply(this, arguments);\n    this.sendBuffer = [];\n  };\n\n  /**\n   * Inherits from Transport.\n   */\n\n  io.util.inherit(XHR, io.Transport);\n\n  /**\n   * Establish a connection\n   *\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.open = function () {\n    this.socket.setBuffer(false);\n    this.onOpen();\n    this.get();\n\n    // we need to make sure the request succeeds since we have no indication\n    // whether the request opened or not until it succeeded.\n    this.setCloseTimeout();\n\n    return this;\n  };\n\n  /**\n   * Check if we need to send data to the Socket.IO server, if we have data in our\n   * buffer we encode it and forward it to the `post` method.\n   *\n   * @api private\n   */\n\n  XHR.prototype.payload = function (payload) {\n    var msgs = [];\n\n    for (var i = 0, l = payload.length; i < l; i++) {\n      msgs.push(io.parser.encodePacket(payload[i]));\n    }\n\n    this.send(io.parser.encodePayload(msgs));\n  };\n\n  /**\n   * Send data to the Socket.IO server.\n   *\n   * @param data The message\n   * @returns {Transport}\n   * @api public\n   */\n\n  XHR.prototype.send = function (data) {\n    this.post(data);\n    return this;\n  };\n\n  /**\n   * Posts a encoded message to the Socket.IO server.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  function empty () { };\n\n  XHR.prototype.post = function (data) {\n    var self = this;\n    this.socket.setBuffer(true);\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n        self.posting = false;\n\n        if (this.status == 200){\n          self.socket.setBuffer(false);\n        } else {\n          self.onClose();\n        }\n      }\n    }\n\n    function onload () {\n      this.onload = empty;\n      self.socket.setBuffer(false);\n    };\n\n    this.sendXHR = this.request('POST');\n\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\n    } else {\n      this.sendXHR.onreadystatechange = stateChange;\n    }\n\n    this.sendXHR.send(data);\n  };\n\n  /**\n   * Disconnects the established `XHR` connection.\n   *\n   * @returns {Transport} \n   * @api public\n   */\n\n  XHR.prototype.close = function () {\n    this.onClose();\n    return this;\n  };\n\n  /**\n   * Generates a configured XHR request\n   *\n   * @param {String} url The url that needs to be requested.\n   * @param {String} method The method the request should use.\n   * @returns {XMLHttpRequest}\n   * @api private\n   */\n\n  XHR.prototype.request = function (method) {\n    var req = io.util.request(this.socket.isXDomain())\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\n\n    req.open(method || 'GET', this.prepareUrl() + query, true);\n\n    if (method == 'POST') {\n      try {\n        if (req.setRequestHeader) {\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        } else {\n          // XDomainRequest\n          req.contentType = 'text/plain';\n        }\n      } catch (e) {}\n    }\n\n    return req;\n  };\n\n  /**\n   * Returns the scheme to use for the transport URLs.\n   *\n   * @api private\n   */\n\n  XHR.prototype.scheme = function () {\n    return this.socket.options.secure ? 'https' : 'http';\n  };\n\n  /**\n   * Check if the XHR transports are supported\n   *\n   * @param {Boolean} xdomain Check if we support cross domain requests.\n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.check = function (socket, xdomain) {\n    try {\n      if (io.util.request(xdomain)) {\n        return true;\n      }\n    } catch(e) {}\n\n    return false;\n  };\n\n  /**\n   * Check if the XHR transport supports corss domain requests.\n   * \n   * @returns {Boolean}\n   * @api public\n   */\n\n  XHR.xdomainCheck = function () {\n    return XHR.check(null, true);\n  };\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports.htmlfile = HTMLFile;\n\n  /**\n   * The HTMLFile transport creates a `forever iframe` based transport\n   * for Internet Explorer. Regular forever iframe implementations will \n   * continuously trigger the browsers buzy indicators. If the forever iframe\n   * is created inside a `htmlfile` these indicators will not be trigged.\n   *\n   * @constructor\n   * @extends {io.Transport.XHR}\n   * @api public\n   */\n\n  function HTMLFile (socket) {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(HTMLFile, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  HTMLFile.prototype.name = 'htmlfile';\n\n  /**\n   * Creates a new ActiveX `htmlfile` with a forever loading iframe\n   * that can be used to listen to messages. Inside the generated\n   * `htmlfile` a reference will be made to the HTMLFile transport.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.get = function () {\n    this.doc = new ActiveXObject('htmlfile');\n    this.doc.open();\n    this.doc.write('<html></html>');\n    this.doc.close();\n    this.doc.parentWindow.s = this;\n\n    var iframeC = this.doc.createElement('div');\n    iframeC.className = 'socketio';\n\n    this.doc.body.appendChild(iframeC);\n    this.iframe = this.doc.createElement('iframe');\n\n    iframeC.appendChild(this.iframe);\n\n    var self = this\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\n\n    this.iframe.src = this.prepareUrl() + query;\n\n    io.util.on(window, 'unload', function () {\n      self.destroy();\n    });\n  };\n\n  /**\n   * The Socket.IO server will write script tags inside the forever\n   * iframe, this function will be used as callback for the incoming\n   * information.\n   *\n   * @param {String} data The message\n   * @param {document} doc Reference to the context\n   * @api private\n   */\n\n  HTMLFile.prototype._ = function (data, doc) {\n    this.onData(data);\n    try {\n      var script = doc.getElementsByTagName('script')[0];\n      script.parentNode.removeChild(script);\n    } catch (e) { }\n  };\n\n  /**\n   * Destroy the established connection, iframe and `htmlfile`.\n   * And calls the `CollectGarbage` function of Internet Explorer\n   * to release the memory.\n   *\n   * @api private\n   */\n\n  HTMLFile.prototype.destroy = function () {\n    if (this.iframe){\n      try {\n        this.iframe.src = 'about:blank';\n      } catch(e){}\n\n      this.doc = null;\n      this.iframe.parentNode.removeChild(this.iframe);\n      this.iframe = null;\n\n      CollectGarbage();\n    }\n  };\n\n  /**\n   * Disconnects the established connection.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  HTMLFile.prototype.close = function () {\n    this.destroy();\n    return io.Transport.XHR.prototype.close.call(this);\n  };\n\n  /**\n   * Checks if the browser supports this transport. The browser\n   * must have an `ActiveXObject` implementation.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  HTMLFile.check = function () {\n    if ('ActiveXObject' in window){\n      try {\n        var a = new ActiveXObject('htmlfile');\n        return a && io.Transport.XHR.check();\n      } catch(e){}\n    }\n    return false;\n  };\n\n  /**\n   * Check if cross domain requests are supported.\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  HTMLFile.xdomainCheck = function () {\n    // we can probably do handling for sub-domains, we should\n    // test that it's cross domain but a subdomain here\n    return false;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('htmlfile');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['xhr-polling'] = XHRPolling;\n\n  /**\n   * The XHR-polling transport uses long polling XHR requests to create a\n   * \"persistent\" connection with the server.\n   *\n   * @constructor\n   * @api public\n   */\n\n  function XHRPolling () {\n    io.Transport.XHR.apply(this, arguments);\n  };\n\n  /**\n   * Inherits from XHR transport.\n   */\n\n  io.util.inherit(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Merge the properties from XHR transport\n   */\n\n  io.util.merge(XHRPolling, io.Transport.XHR);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  XHRPolling.prototype.name = 'xhr-polling';\n\n  /** \n   * Establish a connection, for iPhone and Android this will be done once the page\n   * is loaded.\n   *\n   * @returns {Transport} Chaining.\n   * @api public\n   */\n\n  XHRPolling.prototype.open = function () {\n    var self = this;\n\n    io.Transport.XHR.prototype.open.call(self);\n    return false;\n  };\n\n  /**\n   * Starts a XHR request to wait for incoming messages.\n   *\n   * @api private\n   */\n\n  function empty () {};\n\n  XHRPolling.prototype.get = function () {\n    if (!this.open) return;\n\n    var self = this;\n\n    function stateChange () {\n      if (this.readyState == 4) {\n        this.onreadystatechange = empty;\n\n        if (this.status == 200) {\n          self.onData(this.responseText);\n          self.get();\n        } else {\n          self.onClose();\n        }\n      }\n    };\n\n    function onload () {\n      this.onload = empty;\n      self.onData(this.responseText);\n      self.get();\n    };\n\n    this.xhr = this.request();\n\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\n      this.xhr.onload = this.xhr.onerror = onload;\n    } else {\n      this.xhr.onreadystatechange = stateChange;\n    }\n\n    this.xhr.send(null);\n  };\n\n  /**\n   * Handle the unclean close behavior.\n   *\n   * @api private\n   */\n\n  XHRPolling.prototype.onClose = function () {\n    io.Transport.XHR.prototype.onClose.call(this);\n\n    if (this.xhr) {\n      this.xhr.onreadystatechange = this.xhr.onload = empty;\n      try {\n        this.xhr.abort();\n      } catch(e){}\n      this.xhr = null;\n    }\n  };\n\n  /**\n   * Webkit based browsers show a infinit spinner when you start a XHR request\n   * before the browsers onload event is called so we need to defer opening of\n   * the transport until the onload event is called. Wrapping the cb in our\n   * defer method solve this.\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  XHRPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n\n    io.util.defer(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('xhr-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n\n/**\n * socket.io\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n(function (exports, io, global) {\n  /**\n   * There is a way to hide the loading indicator in Firefox. If you create and\n   * remove a iframe it will stop showing the current loading indicator.\n   * Unfortunately we can't feature detect that and UA sniffing is evil.\n   *\n   * @api private\n   */\n\n  var indicator = global.document && \"MozAppearance\" in\n    global.document.documentElement.style;\n\n  /**\n   * Expose constructor.\n   */\n\n  exports['jsonp-polling'] = JSONPPolling;\n\n  /**\n   * The JSONP transport creates an persistent connection by dynamically\n   * inserting a script tag in the page. This script tag will receive the\n   * information of the Socket.IO server. When new information is received\n   * it creates a new script tag for the new data stream.\n   *\n   * @constructor\n   * @extends {io.Transport.xhr-polling}\n   * @api public\n   */\n\n  function JSONPPolling (socket) {\n    io.Transport['xhr-polling'].apply(this, arguments);\n\n    this.index = io.j.length;\n\n    var self = this;\n\n    io.j.push(function (msg) {\n      self._(msg);\n    });\n  };\n\n  /**\n   * Inherits from XHR polling transport.\n   */\n\n  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n  JSONPPolling.prototype.name = 'jsonp-polling';\n\n  /**\n   * Posts a encoded message to the Socket.IO server using an iframe.\n   * The iframe is used because script tags can create POST based requests.\n   * The iframe is positioned outside of the view so the user does not\n   * notice it's existence.\n   *\n   * @param {String} data A encoded message.\n   * @api private\n   */\n\n  JSONPPolling.prototype.post = function (data) {\n    var self = this\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (!this.form) {\n      var form = document.createElement('form')\n        , area = document.createElement('textarea')\n        , id = this.iframeId = 'socketio_iframe_' + this.index\n        , iframe;\n\n      form.className = 'socketio';\n      form.style.position = 'absolute';\n      form.style.top = '-1000px';\n      form.style.left = '-1000px';\n      form.target = id;\n      form.method = 'POST';\n      form.setAttribute('accept-charset', 'utf-8');\n      area.name = 'd';\n      form.appendChild(area);\n      document.body.appendChild(form);\n\n      this.form = form;\n      this.area = area;\n    }\n\n    this.form.action = this.prepareUrl() + query;\n\n    function complete () {\n      initIframe();\n      self.socket.setBuffer(false);\n    };\n\n    function initIframe () {\n      if (self.iframe) {\n        self.form.removeChild(self.iframe);\n      }\n\n      try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\n      } catch (e) {\n        iframe = document.createElement('iframe');\n        iframe.name = self.iframeId;\n      }\n\n      iframe.id = self.iframeId;\n\n      self.form.appendChild(iframe);\n      self.iframe = iframe;\n    };\n\n    initIframe();\n\n    // we temporarily stringify until we figure out how to prevent\n    // browsers from turning `\\n` into `\\r\\n` in form inputs\n    this.area.value = io.JSON.stringify(data);\n\n    try {\n      this.form.submit();\n    } catch(e) {}\n\n    if (this.iframe.attachEvent) {\n      iframe.onreadystatechange = function () {\n        if (self.iframe.readyState == 'complete') {\n          complete();\n        }\n      };\n    } else {\n      this.iframe.onload = complete;\n    }\n\n    this.socket.setBuffer(true);\n  };\n  \n  /**\n   * Creates a new JSONP poll that can be used to listen\n   * for messages from the Socket.IO server.\n   *\n   * @api private\n   */\n\n  JSONPPolling.prototype.get = function () {\n    var self = this\n      , script = document.createElement('script')\n      , query = io.util.query(\n             this.socket.options.query\n          , 't='+ (+new Date) + '&i=' + this.index\n        );\n\n    if (this.script) {\n      this.script.parentNode.removeChild(this.script);\n      this.script = null;\n    }\n\n    script.async = true;\n    script.src = this.prepareUrl() + query;\n    script.onerror = function () {\n      self.onClose();\n    };\n\n    var insertAt = document.getElementsByTagName('script')[0]\n    insertAt.parentNode.insertBefore(script, insertAt);\n    this.script = script;\n\n    if (indicator) {\n      setTimeout(function () {\n        var iframe = document.createElement('iframe');\n        document.body.appendChild(iframe);\n        document.body.removeChild(iframe);\n      }, 100);\n    }\n  };\n\n  /**\n   * Callback function for the incoming message stream from the Socket.IO server.\n   *\n   * @param {String} data The message\n   * @api private\n   */\n\n  JSONPPolling.prototype._ = function (msg) {\n    this.onData(msg);\n    if (this.open) {\n      this.get();\n    }\n    return this;\n  };\n\n  /**\n   * The indicator hack only works after onload\n   *\n   * @param {Socket} socket The socket instance that needs a transport\n   * @param {Function} fn The callback\n   * @api private\n   */\n\n  JSONPPolling.prototype.ready = function (socket, fn) {\n    var self = this;\n    if (!indicator) return fn.call(this);\n\n    io.util.load(function () {\n      fn.call(self);\n    });\n  };\n\n  /**\n   * Checks if browser supports this transport.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.check = function () {\n    return 'document' in global;\n  };\n\n  /**\n   * Check if cross domain requests are supported\n   *\n   * @returns {Boolean}\n   * @api public\n   */\n\n  JSONPPolling.xdomainCheck = function () {\n    return true;\n  };\n\n  /**\n   * Add the transport to your public io.transports array.\n   *\n   * @api private\n   */\n\n  io.transports.push('jsonp-polling');\n\n})(\n    'undefined' != typeof io ? io.Transport : module.exports\n  , 'undefined' != typeof io ? io : module.parent.exports\n  , this\n);\n}).call(window)\n//@ sourceURL=/node_modules/dnode/node_modules/socket.io-client/dist/browserify.js"
));

require.define("/node_modules/node-uuid/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./uuid.js\"}\n//@ sourceURL=/node_modules/node-uuid/package.json"
));

require.define("/node_modules/node-uuid/uuid.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(byte) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[byte];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());\n\n//@ sourceURL=/node_modules/node-uuid/uuid.js"
));

require.define("crypto", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// todo\n\n//@ sourceURL=crypto"
));

require.define("/shared/dataSources/g-reader.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "/*\n This library was developed by Will Honey.\n It is licensed under the GPLv3 Open Source License\n\n This library requires the underscore library found at http://documentcloud.github.com/underscore/\n This library requires the underscore string library found at http://edtsech.github.com/underscore.string/\n This library requires the support of localStorage. Updates could be easily made to change that.\n */\n\n/* jslint adsafe: false, devel: true, regexp: true, browser: true, vars: true, nomen: true, maxerr: 50, indent: 4 */\n/* global localStorage, window, reader, _ */\nfunction createReader() {\"use strict\";\n    //hack start-----------------------------------------------------------\n    //npm install -g underscore\n    //npm install -g underscore.string\n    //npm install -g xmlhttprequest\n    var _  = require('underscore');\n    // Import Underscore.string to separate object, because there are conflict functions (include, reverse, contains)\n    _.str = require('underscore.string');\n    // Mix in non-conflict functions to Underscore namespace if you want\n    _.mixin(_.str.exports());\n    // All functions, include conflict, will be available through _.str object\n    _.str.include('Underscore.string', 'string'); // => true\n\n    var localStorage = {};\n    if (typeof window === \"undefined\") {\n        var XMLHttpRequest = require(\"xml\" + \"httprequest\").XMLHttpRequest;    \n    } else {\n        var XMLHttpRequest = window.XMLHttpRequest;    \n    }\n    \n    var reader = {};\n    //hack end--------------------------------------------------------------\n\n    //global constants that will likely be used outside of this file\n    reader.TAGS = {\n        \"like\" : \"user/-/state/com.google/like\",\n        \"label\" : \"user/-/label/\",\n        \"star\" : \"user/-/state/com.google/starred\",\n        \"read\" : \"user/-/state/com.google/read\",\n        \"fresh\" : \"user/-/state/com.google/fresh\",\n        \"share\" : \"user/-/state/com.google/broadcast\",\n        \"kept-unread\" : \"user/-/state/com.google/kept-unread\",\n        \"reading-list\" : \"user/-/state/com.google/reading-list\"\n    };\n    //global variables\n    reader.is_logged_in = false;\n    reader.is_initialized = false;\n    reader.has_loaded_prefs = false;\n\n    //constants that will only be used in this file\n    var CLIENT = \"Tibfib\",\n    //base urls\n    LOGIN_URL = \"https://www.google.com/accounts/ClientLogin\", BASE_URL = \"http://www.google.com/reader/api/0/\",\n    //url paths\n    PREFERENCES_PATH = \"preference/stream/list\", STREAM_PATH = \"stream/contents/\", SUBSCRIPTIONS_PATH = \"subscription/\", LABEL_PATH = \"user/-/label/\", TAGS_PATH = \"tag/\",\n    //url actions\n    LIST_SUFFIX = \"list\", EDIT_SUFFIX = \"edit\", MARK_ALL_READ_SUFFIX = \"mark-all-as-read\", TOKEN_SUFFIX = \"token\", USERINFO_SUFFIX = \"user-info\", UNREAD_SUFFIX = \"unread-count\", RENAME_LABEL_SUFFIX = \"rename-tag\", EDIT_TAG_SUFFIX = \"edit-tag\";\n\n    //managing the feeds\n    var readerFeeds = [];\n    reader.setFeeds = function(feeds) {\n        readerFeeds = feeds;\n    };\n    reader.getFeeds = function() {\n        return readerFeeds;\n    };\n    reader.getLabels = function() {\n        return _(reader.getFeeds()).select(function(feed) {\n            return feed.isLabel;\n        });\n    };\n    //managing the logged in user\n    reader.setUser = function(user) {\n        localStorage.User = JSON.stringify(user);\n    };\n    reader.getUser = function() {\n        return JSON.parse(localStorage.User);\n    };\n    //managing the app authentication\n    var readerAuth = \"\", readerToken = \"\";\n    reader.getAuth = function() {\n        if(readerAuth !== \"undefined\") {\n            return readerAuth;\n        }\n    };\n    reader.setAuth = function(auth) {\n        readerAuth = auth;\n    };\n    //the core ajax function\n    var requests = [], makeRequest = function(obj, noAuth) {\n        //make sure we have a method\n        if(!obj.method) {\n            obj.method = \"GET\";\n        }\n        //make sure we have a parameters object\n        if(!obj.parameters) {\n            obj.parameters = {};\n        }\n\n        //add the necessary parameters to get our requests to function properly\n        if(obj.method === \"GET\") {\n            obj.parameters.ck = Date.now() || new Date().getTime();\n            obj.parameters.accountType = \"GOOGLE\";\n            obj.parameters.service = \"reader\";\n            obj.parameters.output = \"json\";\n            obj.parameters.client = CLIENT;\n        }\n\n        //if we have a token, add it to the parameters\n        if(readerToken) {\n            if(obj.method === \"POST\") {\n                //it seems that \"GET\" requests don't care about your token\n                obj.parameters.T = readerToken;\n            }\n        }\n        //turn our parameters object into a query string\n        var queries = [], key, queryString;\n\n        for(key in obj.parameters) {\n            if(obj.parameters.hasOwnProperty(key)) {\n                queries.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(obj.parameters[key]));\n            }\n        }\n        queryString = queries.join(\"&\");\n        //for get requests, attach the queryString\n        //for post requests, attach just the client constant\n        var url = (obj.method === \"GET\") ? (obj.url + \"?\" + queryString) : (obj.url + \"?\" + encodeURIComponent(\"client\") + \"=\" + encodeURIComponent(CLIENT));\n        var request = new XMLHttpRequest();\n        request.open(obj.method, url, true);\n\n        //set request header\n        request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n        if(reader.getAuth() && !noAuth) {\n            //this one is important. This is how google does authorization.\n            request.setRequestHeader(\"Authorization\", \"GoogleLogin auth=\" + reader.getAuth());\n        }\n\n        var requestIndex = requests.length;\n        request.onreadystatechange = function() {\n            if((request.readyState === 4) && request.status === 200) {\n                if(obj.onSuccess) {\n                    obj.onSuccess(request);\n                    if(requests[requestIndex]) {\n                        delete requests[requestIndex];\n                    }\n                }\n            } else if(request.readyState === 4) {\n                if(obj.method === \"POST\") {\n                    if(!obj.tried) {\n                        //If it failed and this is a post request, try getting a new token, then do the request again\n                        reader.getToken(function() {\n                            obj.tried = true;\n                            makeRequest(obj);\n                            if(requests[requestIndex]) {\n                                delete requests[requestIndex];\n                            }\n                        }, obj.onFailure);\n                    }\n                } else {\n                    if(obj.onFailure) {\n                        obj.onFailure(request);\n                        if(requests[requestIndex]) {\n                            delete requests[requestIndex];\n                        }\n                    }\n                }\n                if(request.status === 401 && request.statusText === \"Unauthorized\") {\n                    //Humane is a notification lib.\n                    if(humane) {\n                        humane(request.statusText + \". \" + \"Try logging in again.\");\n                    }\n                }\n\n                console.error(request);\n            }\n        };\n\n        request.send((obj.method === \"POST\") ? queryString : \"\");\n        requests.push(request);\n    };\n    // *************************************\n    // *\n    // * Authentication\n    // *\n    // *************************************\n\n    reader.load = function() {\n        reader.is_logged_in = false;\n        reader.is_initialized = true;\n        //check storage for the tokens we need.\n        if(localStorage.Auth && localStorage.Auth !== \"undefined\") {\n            reader.setAuth(localStorage.Auth);\n            reader.is_logged_in = true;\n        }\n        return (reader.is_logged_in);\n    };\n\n    reader.login = function(email, password, successCallback, failCallback) {\n        if(email.length === 0 || password.length === 0) {\n            failCallback(\"Blank Info...\");\n        }\n        makeRequest({\n            method : \"GET\",\n            url : LOGIN_URL,\n            parameters : {\n                Email : email,\n                Passwd : password\n            },\n            onSuccess : function(transport) {\n                localStorage.Auth = _(transport.responseText).lines()[2].replace(\"Auth=\", \"\");\n                reader.load();\n\n                getUserInfo(successCallback);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n                failCallback(reader.normalizeError(transport.responseText));\n            }\n        });\n    };\n\n    reader.logout = function() {\n        reader.is_logged_in = false;\n        localStorage.Auth = undefined;\n        reader.setUser({});\n        reader.setAuth(\"\");\n        reader.setFeeds([]);\n    };\n    var getUserInfo = function(successCallback, failCallback) {\n        makeRequest({\n            method : \"GET\",\n            url : BASE_URL + USERINFO_SUFFIX,\n            parameters : {},\n            onSuccess : function(transport) {\n                reader.setUser(JSON.parse(transport.responseText));\n\n                successCallback();\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n                if(failCallback) {\n                    failCallback(reader.normalizeError(transport.responseText));\n                }\n            }\n        });\n    };\n    var getUserPreferences = function(successCallback, failCallback) {\n        makeRequest({\n            method : \"GET\",\n            url : BASE_URL + PREFERENCES_PATH,\n            parameters : {},\n            onSuccess : function(transport) {\n                reader.has_loaded_prefs = true;\n                reader.userPrefs = JSON.parse(transport.responseText).streamprefs;\n                if(successCallback) {\n                    successCallback();\n                }\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n                if(failCallback) {\n                    failCallback(reader.normalizeError(transport.responseText));\n                }\n            }\n        });\n    };\n    //Get the token\n    reader.getToken = function(successCallback, failCallback) {\n        makeRequest({\n            method : \"GET\",\n            url : BASE_URL + TOKEN_SUFFIX,\n            parameters : {},\n            onSuccess : function(transport) {\n                readerToken = transport.responseText;\n                successCallback();\n            },\n            onFailure : function(transport) {\n                console.error(\"failed\", transport);\n                if(failCallback) {\n                    failCallback(reader.normalizeError(transport.responseText));\n                }\n            }\n        });\n    };\n    // *************************************\n    // *\n    // * Loading Feeds\n    // *\n    // *************************************\n\n    //Get the user's subscribed feeds\n    reader.loadFeeds = function(successCallback) {\n        function loadFeeds() {\n            makeRequest({\n                method : \"GET\",\n                url : BASE_URL + SUBSCRIPTIONS_PATH + LIST_SUFFIX,\n                onSuccess : function(transport) {\n                    //save feeds in an organized state.\n\n                    loadTags(function(tags) {\n                        //get unread counts\n                        reader.getUnreadCounts(function(unreadcounts) {\n\n                            //organize and save feeds\n                            reader.setFeeds(organizeFeeds(JSON.parse(transport.responseText).subscriptions, tags, unreadcounts, reader.userPrefs));\n\n                            //callback with our feeds\n                            successCallback(reader.getFeeds());\n                        });\n                    });\n                },\n                onFailure : function(transport) {\n                    console.error(transport);\n                }\n            });\n        }\n\n        if(reader.has_loaded_prefs) {\n            loadFeeds();\n        } else {\n            getUserPreferences(loadFeeds);\n        }\n    };\n    var loadTags = function(successCallback) {\n        makeRequest({\n            method : \"GET\",\n            url : BASE_URL + TAGS_PATH + LIST_SUFFIX,\n            onSuccess : function(transport) {\n                //save feeds in an organized state.\n                successCallback(JSON.parse(transport.responseText).tags);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    //organizes feeds based on categories/labels.\n    //this function is ridiculous. like really, holy crap.\n    var organizeFeeds = function(subscriptions, tags, unreadCounts, userPrefs) {\n        var uncategorized = [];\n\n        //prepare tags\n        tags.unshift({\n            title : \"All\",\n            id : reader.TAGS[\"reading-list\"],\n            feeds : subscriptions,\n            isAll : true,\n            isSpecial : true\n        });\n        tags.pop();\n        //remove \"user/-/state/com.blogger/blogger-following\". not exactly future friendly *shrug*\n        var tagTitleRegExp = /[^\\/]+$/i;\n        _(tags).each(function(tag) {\n            //give tags a .title\n            if(!tag.title) {\n                tag.title = tagTitleRegExp.exec(tag.id)[0];\n            }\n\n            //based on title add unique properties\n            if(tag.title === \"starred\") {\n                tag.title = _(tag.title).capitalize();\n                tag.isSpecial = true;\n            } else if(tag.title === \"broadcast\") {\n                tag.title = \"Shared\";\n                tag.isSpecial = true;\n            } else if(!tag.isSpecial) {\n                tag.isLabel = true;\n            }\n\n            tag.feeds = [];\n            //remove digits from the id\n            tag.id = reader.correctId(tag.id);\n\n            //apply unreadCounts\n            _(unreadCounts).each(function(unreadCount) {\n                unreadCount.id = reader.correctId(unreadCount.id);\n\n                if(tag.id === unreadCount.id) {\n                    tag.count = unreadCount.count;\n                    tag.newestItemTimestamp = unreadCount.newestItemTimestampUsec;\n                }\n            });\n        });\n        //process subscriptions\n        _(subscriptions).each(function(sub) {\n            //give isFeed property, useful for identifying\n            sub.isFeed = true;\n\n            //replace digits from the id\n            sub.id = reader.correctId(sub.id);\n\n            //apply unread counts\n            _(unreadCounts).each(function(unreadCount) {\n                if(sub.id === unreadCount.id) {\n                    sub.count = unreadCount.count;\n                    sub.newestItemTimestamp = unreadCount.newestItemTimestampUsec;\n                }\n            });\n            if(sub.categories.length === 0) {\n                //if the subscription has no categories, push it onto the uncategorized array\n                uncategorized.push(sub);\n            } else {\n                //otherwise find the category from the tags array and push the sub into its feeds array\n                _(sub.categories).each(function(tag) {\n                    tag.id = reader.correctId(tag.id);\n                    _(tags).each(function(fullTag) {\n                        if(tag.id === fullTag.id) {\n                            var sub_clone = _(sub).clone();\n                            sub_clone.inside = fullTag.id;\n\n                            fullTag.feeds.push(sub_clone);\n                        }\n                    });\n                });\n            }\n\n        });\n        //replace digits\n        _(userPrefs).each(function(value, key) {\n            if(/user\\/\\d*\\//.test(key)) {\n                userPrefs[reader.correctId(key)] = value;\n            }\n        });\n        //remove tags with no feeds\n        var tagsWithFeeds = _(tags).reject(function(tag) {\n            return (tag.feeds.length === 0 && !tag.isSpecial);\n        });\n        //order the feeds within tags\n        _(tagsWithFeeds).each(function(tag) {\n            //get the ordering id based on the userPrefs\n            var orderingId = _(userPrefs[tag.id]).detect(function(setting) {\n                return (setting.id === \"subscription-ordering\");\n            });\n            if(orderingId) {\n                tag.feeds = _(tag.feeds).sortBy(function(feed) {\n                    if(orderingId.value.indexOf(feed.sortid) === -1) {\n                        //if our sortid isn't there, the feed should be at the back.\n                        return 1000;\n                    }\n                    //return the index of our feed sortid, which will be in multiples of 8 since sortid's are 8 characters long.\n                    return (orderingId.value.indexOf(feed.sortid)) / 8;\n                });\n            } //there might be another setting we should follow like \"alphabetical\" or \"most recent\". Just a guess.\n            /*else {\n             tag.feeds.sort();\n             }*/\n        });\n        //now order ALL feeds and tags\n        var orderingId = _(userPrefs[\"user/-/state/com.google/root\"]).detect(function(setting) {\n            return (setting.id === \"subscription-ordering\");\n        }) || {\n            value : \"\"\n        };\n\n        //our feeds are our tagsWithFeeds + our uncategorized subscriptions\n        var feeds = [].concat(tagsWithFeeds, uncategorized);\n        //sort them by sortid\n        feeds = _(feeds).sortBy(function(feed) {\n            if(orderingId.value.indexOf(feed.sortid) === -1 && !feed.isSpecial) {\n                return 1000;\n            }\n            return (orderingId.value.indexOf(feed.sortid)) / 8;\n        });\n        return feeds;\n    };\n    //get unread counts from google reader\n    //passing true as the second arg gets you an object, extremely useful for notifications\n    reader.getUnreadCounts = function(successCallback, returnObject) {\n        makeRequest({\n            url : BASE_URL + UNREAD_SUFFIX,\n            onSuccess : function(transport) {\n                var unreadCounts = JSON.parse(transport.responseText).unreadcounts;\n                //console.log(transport);\n                var unreadCountsObj = {};\n                _(unreadCounts).each(function(obj) {\n                    unreadCountsObj[reader.correctId(obj.id)] = obj.count;\n                });\n                reader.unreadCountsObj = unreadCountsObj;\n\n                if(returnObject) {\n                    successCallback(unreadCountsObj);\n                } else {\n                    successCallback(unreadCounts);\n                }\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    //this is a function so we can reduce the amount of ajax calls when setting an article as read. Just manually decrement the counts, don't request new numbers.\n    reader.decrementUnreadCount = function(feedId, callback) {\n        _.each(reader.getFeeds(), function(subscription) {\n            if(subscription.id === feedId || (subscription.isAll)) {\n                subscription.count -= 1;\n            } else if(subscription.feeds && subscription.feeds.length > 0) {\n                _.each(subscription.feeds, function(feed) {\n                    if(feed.id === feedId) {\n                        subscription.count -= 1;\n                    }\n                });\n            }\n        });\n        callback();\n    };\n    // *************************************\n    // *\n    // * Editing Feeds\n    // *\n    // *************************************\n\n    var editFeed = function(params, successCallback) {\n        if(!params) {\n            console.error(\"No params for feed edit\");\n            return;\n        }\n        makeRequest({\n            method : \"POST\",\n            url : BASE_URL + SUBSCRIPTIONS_PATH + EDIT_SUFFIX,\n            parameters : params,\n            onSuccess : function(transport) {\n                successCallback(transport.responseText);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    //edit feed title\n    reader.editFeedTitle = function(feedId, newTitle, successCallback) {\n        editFeed({\n            ac : \"edit\",\n            t : newTitle,\n            s : feedId\n        }, successCallback);\n    };\n    reader.editFeedLabel = function(feedId, label, opt, successCallback) {\n        var obj = {\n            ac : \"edit\",\n            s : feedId\n        };\n        if(opt) {\n            obj.a = label;\n        } else {\n            obj.r = label;\n        }\n        editFeed(obj, successCallback);\n    };\n\n    reader.editLabelTitle = function(labelId, newTitle, successCallback) {\n        makeRequest({\n            method : \"POST\",\n            url : BASE_URL + RENAME_LABEL_SUFFIX,\n            parameters : {\n                s : LABEL_PATH + labelId,\n                t : labelId,\n                dest : LABEL_PATH + newTitle\n            },\n            onSuccess : function(transport) {\n                successCallback(transport.responseText);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n\n    reader.markAllAsRead = function(feedOrLabelId, successCallback) {\n        //feed or label\n        makeRequest({\n            method : \"POST\",\n            url : BASE_URL + MARK_ALL_READ_SUFFIX,\n            parameters : {\n                s : feedOrLabelId\n            },\n            onSuccess : function(transport) {\n                successCallback(transport.responseText);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    // *************************************\n    // *\n    // * Adding a Feed\n    // *\n    // *************************************\n    reader.unsubscribeFeed = function(feedId, successCallback) {\n        editFeed({\n            ac : \"unsubscribe\",\n            s : feedId\n        }, successCallback);\n    };\n\n    reader.subscribeFeed = function(feedUrl, successCallback, title) {\n        editFeed({\n            ac : \"subscribe\",\n            s : \"feed/\" + feedUrl,\n            t : title || undefined\n        }, successCallback);\n    };\n    var readerUrlRegex = /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?\\^=%&amp;:\\/~\\+#]*[\\w\\-\\@?\\^=%&amp;\\/~\\+#])?/;\n    reader.processFeedInput = function(input, inputType, successCallback, failCallback) {\n        var url = \"https://ajax.googleapis.com/ajax/services/feed/\";\n        if((readerUrlRegex.test(input) || inputType === \"url\") && inputType !== \"keyword\") {\n            url += \"load\";\n        } else {\n            url += \"find\";\n            //replace the .com, or .net from the input, since our search doesn't like that\n            input = input.replace(/\\.\\w{1,3}\\.*\\w{0,2}$/ig, \"\");\n        }\n        makeRequest({\n            url : url,\n            parameters : {\n                q : encodeURI(input),\n                v : \"1.0\"\n            },\n            onSuccess : function(transport) {\n                var response = JSON.parse(transport.responseText);\n                if(response.responseStatus === 200) {\n                    if(response.responseData.entries) {\n                        successCallback(response.responseData.entries, \"keyword\");\n                    } else {\n                        successCallback(response.responseData.feed, \"url\");\n                    }\n                } else {\n                    failCallback(response.responseDetails);\n                }\n\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        }, true);\n    };\n    // *************************************\n    // *\n    // * Loading Items\n    // *\n    // *************************************\n\n    reader.getItems = function(feedUrl, successCallback, opts) {\n        var params = opts || {\n            n : 50\n        };\n        params.r = \"d\";\n        makeRequest({\n            method : \"GET\",\n            url : BASE_URL + STREAM_PATH + encodeURIComponent(feedUrl),\n            parameters : params, /*{\n             //ot=[unix timestamp] : The time from which you want to retrieve items. Only items that have been crawled by Google Reader after this time will be returned.\n             //r=[d|n|o] : Sort order of item results. d or n gives items in descending date order, o in ascending order.\n             //xt=[exclude target] : Used to exclude certain items from the feed. For example, using xt=user/-/state/com.google/read will exclude items that the current user has marked as read, or xt=feed/[feedurl] will exclude items from a particular feed (obviously not useful in this request, but xt appears in other listing requests).\n             },*/\n            onSuccess : function(transport) {\n                successCallback(JSON.parse(transport.responseText).items);\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    // *************************************\n    // *\n    // * Editing Items\n    // *\n    // *************************************\n\n    reader.setItemTag = function(feed, item, tag, add, successCallback) {\n        //feed/label id\n        //item id\n        //tag in simple form: \"like\", \"read\", \"share\", \"label\", \"star\", \"kept-unread\"\n        //add === true, or add === false\n\n        var params = {\n            s : feed,\n            i : item,\n            async : \"true\",\n            ac : \"edit-tags\"\n        };\n        if(add === true) {\n            params.a = reader.TAGS[tag];\n        } else {\n            params.r = reader.TAGS[tag];\n        }\n        makeRequest({\n            method : \"POST\",\n            url : BASE_URL + EDIT_TAG_SUFFIX,\n            parameters : params,\n            onSuccess : function(transport) {\n                if(transport.responseText === \"OK\") {\n                    successCallback(transport.responseText);\n                }\n            },\n            onFailure : function(transport) {\n                console.error(transport);\n            }\n        });\n    };\n    // *************************************\n    // *\n    // * Useful Utilities\n    // *\n    // *************************************\n    //this function replaces the number id with a dash. Helpful for comparison\n    var readerIdRegExp = /user\\/\\d*\\//;\n    reader.correctId = function(id) {\n        return id.replace(readerIdRegExp, \"user\\/-\\/\");\n    };\n    //returns url for image to use in the icon\n    reader.getIconForFeed = function(feedUrl) {\n        return \"http://www.google.com/s2/favicons?domain_url=\" + encodeURIComponent(feedUrl);\n    };\n    //normalizes error response for logging in\n    reader.normalizeError = function(inErrorResponse) {\n        return _(inErrorResponse).lines()[0].replace(\"Error=\", \"\").replace(/(\\w)([A-Z])/g, \"$1 $2\");\n    };\n\n    return reader\n};\n\nmodule.exports = createReader\n//@ sourceURL=/shared/dataSources/g-reader.js"
));

require.define("/node_modules/underscore/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/underscore/package.json"
));

require.define("/node_modules/underscore/underscore.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n\n//@ sourceURL=/node_modules/underscore/underscore.js"
));

require.define("/node_modules/underscore.string/package.json", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "module.exports = {\"main\":\"./lib/underscore.string\"}\n//@ sourceURL=/node_modules/underscore.string/package.json"
));

require.define("/node_modules/underscore.string/lib/underscore.string.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "// Underscore.string\n// (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>\n// Underscore.strings is freely distributable under the terms of the MIT license.\n// Documentation: https://github.com/epeli/underscore.string\n// Some code is borrowed from MooTools and Alexandru Marasteanu.\n\n// Version 2.1.1\n\n(function(root){\n  'use strict';\n\n  // Defining helper functions.\n\n  var nativeTrim = String.prototype.trim;\n  var nativeTrimRight = String.prototype.trimRight;\n  var nativeTrimLeft = String.prototype.trimLeft;\n\n  var parseNumber = function(source) { return source * 1 || 0; };\n  \n  var strRepeat = function(str, qty, separator){\n    // ~~var — is the fastest available way to convert anything to Integer in javascript.\n    // We'll use it extensively in this lib.\n    str += ''; qty = ~~qty;\n    for (var repeat = []; qty > 0; repeat[--qty] = str) {}\n    return repeat.join(separator == null ? '' : separator);\n  };\n\n  var slice = function(a){\n    return Array.prototype.slice.call(a);\n  };\n\n  var defaultToWhiteSpace = function(characters){\n    if (characters != null) {\n      return '[' + _s.escapeRegExp(''+characters) + ']';\n    }\n    return '\\\\s';\n  };\n\n  // sprintf() for JavaScript 0.7-beta1\n  // http://www.diveintojavascript.com/projects/javascript-sprintf\n  //\n  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\n  // All rights reserved.\n\n  var sprintf = (function() {\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    var str_repeat = strRepeat;\n\n    var str_format = function() {\n      if (!str_format.cache.hasOwnProperty(arguments[0])) {\n        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n      }\n      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n    };\n\n    str_format.format = function(parse_tree, argv) {\n      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        }\n        else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n          if (match[2]) { // keyword argument\n            arg = argv[cursor];\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw new Error(sprintf('[_.sprintf] property \"%s\" does not exist', match[2][k]));\n              }\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) { // positional argument (explicit)\n            arg = argv[match[1]];\n          }\n          else { // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));\n          }\n          switch (match[8]) {\n            case 'b': arg = arg.toString(2); break;\n            case 'c': arg = String.fromCharCode(arg); break;\n            case 'd': arg = parseInt(arg, 10); break;\n            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n            case 'o': arg = arg.toString(8); break;\n            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n            case 'u': arg = Math.abs(arg); break;\n            case 'x': arg = arg.toString(16); break;\n            case 'X': arg = arg.toString(16).toUpperCase(); break;\n          }\n          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n      return output.join('');\n    };\n\n    str_format.cache = {};\n\n    str_format.parse = function(fmt) {\n      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        }\n        else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        }\n        else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [], replacement_field = match[2], field_match = [];\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else {\n                  throw new Error('[_.sprintf] huh?');\n                }\n              }\n            }\n            else {\n              throw new Error('[_.sprintf] huh?');\n            }\n            match[2] = field_list;\n          }\n          else {\n            arg_names |= 2;\n          }\n          if (arg_names === 3) {\n            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');\n          }\n          parse_tree.push(match);\n        }\n        else {\n          throw new Error('[_.sprintf] huh?');\n        }\n        _fmt = _fmt.substring(match[0].length);\n      }\n      return parse_tree;\n    };\n\n    return str_format;\n  })();\n\n\n\n  // Defining underscore.string\n\n  var _s = {\n\n    VERSION: '2.1.1',\n\n    isBlank: function(str){\n      return (/^\\s*$/).test(str);\n    },\n\n    stripTags: function(str){\n      return (''+str).replace(/<\\/?[^>]+>/ig, '');\n    },\n\n    capitalize : function(str) {\n      str += '';\n      return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();\n    },\n\n    chop: function(str, step){\n      str = str+'';\n      step = ~~step || str.length;\n      var arr = [];\n      for (var i = 0; i < str.length;) {\n        arr.push(str.slice(i,i + step));\n        i = i + step;\n      }\n      return arr;\n    },\n\n    clean: function(str){\n      return _s.strip((''+str).replace(/\\s+/g, ' '));\n    },\n\n    count: function(str, substr){\n      str += ''; substr += '';\n      return str.split(substr).length - 1;\n    },\n\n    chars: function(str) {\n      return (''+str).split('');\n    },\n\n    escapeHTML: function(str) {\n      return (''+str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')\n                            .replace(/\"/g, '&quot;').replace(/'/g, \"&apos;\");\n    },\n\n    unescapeHTML: function(str) {\n      return (''+str).replace(/&lt;/g, '<').replace(/&gt;/g, '>')\n                            .replace(/&quot;/g, '\"').replace(/&apos;/g, \"'\").replace(/&amp;/g, '&');\n    },\n\n    escapeRegExp: function(str){\n      // From MooTools core 1.2.4\n      return str.replace(/([-.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    },\n\n    insert: function(str, i, substr){\n      var arr = (''+str).split('');\n      arr.splice(~~i, 0, ''+substr);\n      return arr.join('');\n    },\n\n    include: function(str, needle){\n      return (''+str).indexOf(needle) !== -1;\n    },\n\n    join: function(sep) {\n      var args = slice(arguments);\n      return args.join(args.shift());\n    },\n\n    lines: function(str) {\n      return (''+str).split(\"\\n\");\n    },\n\n    reverse: function(str){\n        return Array.prototype.reverse.apply(String(str).split('')).join('');\n    },\n\n    splice: function(str, i, howmany, substr){\n      var arr = (''+str).split('');\n      arr.splice(~~i, ~~howmany, substr);\n      return arr.join('');\n    },\n\n    startsWith: function(str, starts){\n      str += ''; starts += '';\n      return str.length >= starts.length && str.substring(0, starts.length) === starts;\n    },\n\n    endsWith: function(str, ends){\n      str += ''; ends += '';\n      return str.length >= ends.length && str.substring(str.length - ends.length) === ends;\n    },\n\n    succ: function(str){\n      str += '';\n      var arr = str.split('');\n      arr.splice(str.length-1, 1, String.fromCharCode(str.charCodeAt(str.length-1) + 1));\n      return arr.join('');\n    },\n\n    titleize: function(str){\n      return (''+str).replace(/\\b./g, function(ch){ return ch.toUpperCase(); });\n    },\n\n    camelize: function(str){\n      return _s.trim(str).replace(/(\\-|_|\\s)+(.)?/g, function(match, separator, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    underscored: function(str){\n      return _s.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n    },\n\n    dasherize: function(str){\n      return _s.trim(str).replace(/[_\\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();\n    },\n\n    classify: function(str){\n      return _s.titleize(str.replace(/_/g, ' ')).replace(/\\s/g, '')\n    },\n\n    humanize: function(str){\n      return _s.capitalize(this.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));\n    },\n\n    trim: function(str, characters){\n      str += '';\n      if (!characters && nativeTrim) {\n        return nativeTrim.call(str);\n      }\n      characters = defaultToWhiteSpace(characters);\n      return str.replace(new RegExp('\\^' + characters + '+|' + characters + '+$', 'g'), '');\n    },\n\n    ltrim: function(str, characters){\n      if (!characters && nativeTrimLeft) {\n        return nativeTrimLeft.call(str);\n      }\n      characters = defaultToWhiteSpace(characters);\n      return (''+str).replace(new RegExp('\\^' + characters + '+', 'g'), '');\n    },\n\n    rtrim: function(str, characters){\n      if (!characters && nativeTrimRight) {\n        return nativeTrimRight.call(str);\n      }\n      characters = defaultToWhiteSpace(characters);\n      return (''+str).replace(new RegExp(characters + '+$', 'g'), '');\n    },\n\n    truncate: function(str, length, truncateStr){\n      str += ''; truncateStr = truncateStr || '...';\n      length = ~~length;\n      return str.length > length ? str.slice(0, length) + truncateStr : str;\n    },\n\n    /**\n     * _s.prune: a more elegant version of truncate\n     * prune extra chars, never leaving a half-chopped word.\n     * @author github.com/sergiokas\n     */\n    prune: function(str, length, pruneStr){\n      str += ''; length = ~~length;\n      pruneStr = pruneStr != null ? ''+pruneStr : '...';\n      \n      var pruned, borderChar, template = str.replace(/\\W/g, function(ch){\n        return (ch.toUpperCase() !== ch.toLowerCase()) ? 'A' : ' ';\n      });\n      \n      borderChar = template.charAt(length);\n      \n      pruned = template.slice(0, length);\n      \n      // Check if we're in the middle of a word\n      if (borderChar && borderChar.match(/\\S/))\n        pruned = pruned.replace(/\\s\\S+$/, '');\n        \n      pruned = _s.rtrim(pruned);\n      \n      return (pruned+pruneStr).length > str.length ? str : str.substring(0, pruned.length)+pruneStr;\n    },\n\n    words: function(str, delimiter) {\n      return _s.trim(str, delimiter).split(delimiter || /\\s+/);\n    },\n\n    pad: function(str, length, padStr, type) {\n      str += '';\n      \n      var padding = '', padlen  = 0;\n\n      length = ~~length;\n      \n      if (!padStr) {\n        padStr = ' ';\n      } else if (padStr.length > 1) {\n        padStr = padStr.charAt(0);\n      }\n      \n      switch(type) {\n        case 'right':\n          padlen = (length - str.length);\n          padding = strRepeat(padStr, padlen);\n          str = str+padding;\n          break;\n        case 'both':\n          padlen = (length - str.length);\n          padding = {\n            'left' : strRepeat(padStr, Math.ceil(padlen/2)),\n            'right': strRepeat(padStr, Math.floor(padlen/2))\n          };\n          str = padding.left+str+padding.right;\n          break;\n        default: // 'left'\n          padlen = (length - str.length);\n          padding = strRepeat(padStr, padlen);;\n          str = padding+str;\n        }\n      return str;\n    },\n\n    lpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr);\n    },\n\n    rpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'right');\n    },\n\n    lrpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'both');\n    },\n\n    sprintf: sprintf,\n\n    vsprintf: function(fmt, argv){\n      argv.unshift(fmt);\n      return sprintf.apply(null, argv);\n    },\n\n    toNumber: function(str, decimals) {\n      var num = parseNumber(parseNumber(str).toFixed(~~decimals));\n      return num === 0 && ''+str !== '0' ? Number.NaN : num;\n    },\n\n    strRight: function(str, sep){\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos =  (!sep) ? -1 : str.indexOf(sep);\n      return (pos != -1) ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strRightBack: function(str, sep){\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos =  (!sep) ? -1 : str.lastIndexOf(sep);\n      return (pos != -1) ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strLeft: function(str, sep){\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = (!sep) ? -1 : str.indexOf(sep);\n      return (pos != -1) ? str.slice(0, pos) : str;\n    },\n\n    strLeftBack: function(str, sep){\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = str.lastIndexOf(sep);\n      return (pos != -1) ? str.slice(0, pos) : str;\n    },\n\n    toSentence: function(array, separator, lastSeparator) {\n        separator || (separator = ', ');\n        lastSeparator || (lastSeparator = ' and ');\n        var length = array.length, str = '';\n\n        for (var i = 0; i < length; i++) {\n            str += array[i];\n            if (i === (length - 2)) { str += lastSeparator; }\n            else if (i < (length - 1)) { str += separator; }\n        }\n\n        return str;\n    },\n\n    slugify: function(str) {\n      var from  = \"ąàáäâãćęèéëêìíïîłńòóöôõùúüûñçżź·/_:;\",\n          to    = \"aaaaaaceeeeeiiiilnooooouuuunczz\",\n          regex = new RegExp(defaultToWhiteSpace(from), 'g');\n\n      str = (''+str).toLowerCase();\n\n      str = str.replace(regex, function(ch){\n        var index = from.indexOf(ch);\n        return to.charAt(index) || '-';\n      });\n\n      return _s.trim(str.replace(/[^\\w\\s-]/g, '').replace(/[-\\s]+/g, '-'), '-');\n    },\n\n    exports: function() {\n      var result = {};\n\n      for (var prop in this) {\n        if (!this.hasOwnProperty(prop) || prop == 'include' || prop == 'contains' || prop == 'reverse') continue;\n        result[prop] = this[prop];\n      }\n\n      return result;\n    },\n    \n    repeat: strRepeat\n\n  };\n\n  // Aliases\n\n  _s.strip    = _s.trim;\n  _s.lstrip   = _s.ltrim;\n  _s.rstrip   = _s.rtrim;\n  _s.center   = _s.lrpad;\n  _s.rjust    = _s.lpad;\n  _s.ljust    = _s.rpad;\n  _s.contains = _s.include;\n\n  // CommonJS module is defined\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      // Export module\n      module.exports = _s;\n    }\n    exports._s = _s;\n\n  } else if (typeof define === 'function' && define.amd) {\n    // Register as a named module with AMD.\n    define('underscore.string', function() {\n      return _s;\n    });\n\n  // Integrate with Underscore.js\n  } else if (typeof root._ !== 'undefined') {\n    // root._.mixin(_s);\n    root._.string = _s;\n    root._.str = root._.string;\n\n  // Or define it\n  } else {\n    root._ = {\n      string: _s,\n      str: _s\n    };\n  }\n\n}(this || window));\n\n//@ sourceURL=/node_modules/underscore.string/lib/underscore.string.js"
));

require.define("/shared/dataSources/scraper.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "var scraper = require(\"../util/scraper\")\n\nmodule.exports = {\n    scraper: scraper\n}\n//@ sourceURL=/shared/dataSources/scraper.js"
));

require.define("/browser.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "window.nCore = require(\"./core\")\n//@ sourceURL=/browser.js"
));
require("/browser.js");

require.define("/dummy.js", Function(
    [ 'require', 'module', 'exports', '__dirname', '__filename' ],
    "(function () { \nvar Core = Object.create(nCore).constructor()\ndelete window.nCore \nCore.use('client.app', require('./client/app.js')) \nCore.use('shared.domains.user', require('./shared/domains/user.js')) \nCore.use('shared.domains.post', require('./shared/domains/post.js')) \nCore.use('client.routes.post', require('./client/routes/post.js')) \nCore.use('shared.util.scraper.client', require('./shared/util/scraper.client.js')) \nCore.use('shared.util.scraper', require('./shared/util/scraper.js')) \nCore.use('shared.dataSources.user', require('./shared/dataSources/user.js')) \nCore.use('shared.dataSources.g-reader', require('./shared/dataSources/g-reader.js')) \nCore.use('shared.dataSources.scraper', require('./shared/dataSources/scraper.js')) \nCore.dependencies = {\"client.app\":{\"routes\":{\"post\":\"client.routes.post\"}},\"client.routes.post\":{\"domain\":\"shared.domains.post\",\"view\":\"client.views.post\"},\"shared.domains.user\":{\"dataSources\":{\"user\":\"shared.dataSources.user\",\"g-reader\":\"shared.dataSources.g-reader\",\"scraper\":\"shared.dataSources.scraper\"}},\"shared.domains.post\":{\"dataSources\":{\"user\":\"shared.dataSources.user\",\"g-reader\":\"shared.dataSources.g-reader\",\"scraper\":\"shared.dataSources.scraper\"}}}\nCore.init()\n})()\n//@ sourceURL=/dummy.js"
));
require("/dummy.js");
